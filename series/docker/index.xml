<?xml version="1.0" encoding="utf-8"?><feed version="2.0" xmlns="http://www.w3.org/2005/Atom"><id>https://picodotdev.github.io/blog-bitix/series/docker/</id><title type="text">Blog Bitix</title><subtitle>Recent content on Blog Bitix</subtitle><updated>2019-05-26T11:30:00+02:00</updated><author><name>picodotdev</name></author><generator>Hugo</generator><icon>https://picodotdev.github.io/blog-bitix/assets/images/logotipos/hugo.png</icon><logo>https://picodotdev.github.io/blog-bitix/assets/images/logotipos/hugo.png</logo><rights>https://creativecommons.org/licenses/by-sa/4.0/</rights><entry><id>https://picodotdev.github.io/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/</id><title>Registro y descubrimiento de servicios en contenedores de Docker con Consul y Registrator</title><updated>2019-05-26T11:30:00+02:00</updated><published>2019-05-26T11:30:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>En los microservicios se hace necesario un servicio de registro y descubrimiento como Eureka o Consul que permita conocer la ubicación de las instancias en cada momento. Las instancias de los servicios se pueden registrar ellas mismas o esta tarea se puede delegar en una en otro servicio. Al usar contenedores de Docker una herramienta que permite delegar el registro y desregistro en Consul de los servicios es GliderLabs Registrator.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/consul.svg" class="right " width="200" alt="Consul" title="Consul"/>
&lt;/div>
&lt;div class="logotypes" style="float: right; clear: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>El registro y descubrimiento de servicios permite a los servicios registrase y a los clientes descubrir la ubicación de otros servicios, la ubicación consiste en la dirección IP y el puerto en el que contactarles. Dado la naturaleza efímera de los servicios donde nuevas instancias de servicios se inician y se detienen en diferentes máquinas y puertos el servicio de descubrimiento es esencial.&lt;/p>
&lt;p>La funcionalidad de registro y descubrimiento consiste en dos partes, por un lado cuando se inicia una instancia de un servicio se registra su ubicación en el servicio de registro y descubrimiento y por otro lado los clientes cuando requieren una instancia de un servicio la buscan en el servicio de descubrimiento.&lt;/p>
&lt;p>El registro en el servicio de descubrimiento puede hacerse de dos formas, que sea el propio servicio el que se registra en el servicio de descubrimiento o que se sea otro servicio el que lo registra. Para el primer caso escribí un artículo con &lt;a href="https://www.consul.io/">Consul&lt;/a> como servicio de descubrimiento en una aplicación de &lt;a href="https://projects.spring.io/spring-boot/">Spring Boot&lt;/a> que se registra al iniciarse. La ventaja es que es autosuficiente pero adquiere la tarea de autoregistrarse. Por el contrario delegar la trea de registro permite extraerla de los servicios y ofrecer esa funcionalidad por un servicio con esa misión específicamente.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2017/01/registro-y-descubrimiento-de-servicios-con-spring-cloud-y-consul/">Registro y descubrimiento de servicios con Spring Cloud y Consul&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>En este artículo se usa &lt;a href="https://github.com/gliderlabs/registrator">GliderLabs Registrator&lt;/a> como servicio que se encarga de registrar en un servicio de descubrimiento como Consul los servicios que se inicien en &lt;a href="https://www.docker.com/">Docker&lt;/a>, aunque soporta otros como &lt;a href="https://etcd.io/">etcd&lt;/a>.&lt;/p>
&lt;p>Registrator es un contenedor de Docker, su funcionamiento es escuchar los eventos del demonio de Docker y monitorizar cuando se inician nuevos contenedores o cuando se paran. La monitorización la hace a través del &lt;em>socket&lt;/em> del servicio de Docker, para lo que hay que montar un volumen en este contenedor con el archivo &lt;em>/var/run/docker.sock&lt;/em> del &lt;em>host&lt;/em>.&lt;/p>
&lt;p>Primero se inicia el servicio de Consul.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ consul agent -dev
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/consul.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/consul.sh" target="_blank">consul.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Luego se inicia el contenedor Registrator indicando la ubicación con dirección IP y puerto del servicio de Consul.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker run --rm --name&lt;span class="o">=&lt;/span>registrator --net&lt;span class="o">=&lt;/span>host --volume&lt;span class="o">=&lt;/span>/var/run/docker.sock:/tmp/docker.sock gliderlabs/registrator:latest consul://localhost:8500
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-registrator.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-registrator.sh" target="_blank">docker-registrator.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Iniciados estos dos servicios en la interfaz de estado de Consul se observa que no hay ningún servicio pero cuando se inicie un nuevo contenedor será registrado en Consul por Registrator.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/images/consul_hudf2f8b03877264bacf83a564e5686ede_36482_2560x1440_fit_box_2.png" title="Dirección" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/images/consul_hudf2f8b03877264bacf83a564e5686ede_36482_300x200_fit_box_2.png" width="287"/>&lt;/a>
&lt;/figure>
&lt;/div>
&lt;p>En este caso se utiliza como servicio una base de datos &lt;a href="https://www.postgresql.org/">PostgreSQL&lt;/a>. Dado que el puerto en el que esté disponible el servicio de PostgreSQL es indiferente al utilizar un servicio de registro y descubrimiento se indica el &lt;em>-p&lt;/em> sin indicar el puerto del &lt;em>host&lt;/em>, de este modo Docker le asigna un puerto público aleatorio.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker run --rm --name postgres -e &lt;span class="nv">POSTGRES_USER&lt;/span>&lt;span class="o">=&lt;/span>user -e &lt;span class="nv">POSTGRES_PASSWORD&lt;/span>&lt;span class="o">=&lt;/span>password -e &lt;span class="nv">POSTGRES_DB&lt;/span>&lt;span class="o">=&lt;/span>database -p &lt;span class="m">5432&lt;/span> postgres:alpine
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-postgres.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-postgres.sh" target="_blank">docker-postgres.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
cb7602605725 postgres:alpine &lt;span class="s2">&amp;#34;docker-entrypoint.s…&amp;#34;&lt;/span> &lt;span class="m">54&lt;/span> seconds ago Up &lt;span class="m">53&lt;/span> seconds 0.0.0.0:32777-&amp;gt;5432/tcp postgres
d286341148cb gliderlabs/registrator:latest &lt;span class="s2">&amp;#34;/bin/registrator co…&amp;#34;&lt;/span> About a minute ago Up About a minute registrator&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-ps.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-ps.sh" target="_blank">docker-ps.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>En la salida del contenedor de Registrator se emite una traza indicando que el servicio de postgres ha sido registrado en Consul.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">2019/05/26 11:05:29 Starting registrator v7 ...
2019/05/26 11:05:29 Using consul adapter: consul://localhost:8500
2019/05/26 11:05:29 Connecting to backend (0/0)
2019/05/26 11:05:29 consul: current leader 127.0.0.1:8300
2019/05/26 11:05:29 Listening for Docker events ...
2019/05/26 11:05:29 Syncing services on 1 containers
2019/05/26 11:05:29 ignored: d286341148cb no published ports
2019/05/26 11:05:50 added: cb7602605725 archlinux:postgres:5432&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-registrator.out" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-registrator.out" target="_blank">docker-registrator.out&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Una vez iniciado el servicio de postgres en la consola de Consul se muestra con su dirección y puerto en el que se encuentra, en el contenedor utiliza su puerto por defecto &lt;em>5432&lt;/em> pero hacia el exterior en este caso al no haber especificado uno Docker le asigna un puerto aleatorio en este caso el &lt;em>32777&lt;/em>. Este puerto aleatorio es con el que los clientes acceden a la base de datos.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/images/consul-postgres-1_hu5336dadbc35299bcca8969f84d373cf0_39850_2560x1440_fit_box_2.png" title="Servicio de postgres registrado en Consul" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/images/consul-postgres-1_hu5336dadbc35299bcca8969f84d373cf0_39850_300x200_fit_box_2.png" width="300"/>&lt;/a>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/images/consul-postgres-2_huf0df6f6a3d2138a93d9a38f4927788b0_43545_2560x1440_fit_box_2.png" title="Servicio de postgres registrado en Consul" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/images/consul-postgres-2_huf0df6f6a3d2138a93d9a38f4927788b0_43545_300x200_fit_box_2.png" width="300"/>&lt;/a>
&lt;figcaption>Servicio de postgres registrado en Consul por Registrator&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>En vez de iniciar los servicios individualmente con comandos de Docker creando un archivo de &lt;a href="https://docs.docker.com/compose/">Docker Compose&lt;/a> con la definición de todos los contenedores se facilita iniciar todos los contenedores con un comando.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker-compose up&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-compose-up.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-compose-up.sh" target="_blank">docker-compose-up.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-YAML" data-lang="YAML">version&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3.7&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>services&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>consul&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>consul&lt;span class="p">:&lt;/span>latest&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>container_name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>consul&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>network_mode&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;host&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>command&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;consul&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;agent&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-dev&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-ui&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>registrator&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>gliderlabs/registrator&lt;span class="p">:&lt;/span>latest&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>container_name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>registrator&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>network_mode&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;host&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>volumes&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>/var/run/docker.sock&lt;span class="p">:&lt;/span>/tmp/docker.sock&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>entrypoint&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>/bin/registrator&lt;span class="w"> &lt;/span>consul&lt;span class="p">:&lt;/span>//localhost&lt;span class="p">:&lt;/span>&lt;span class="m">8500&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>depends_on&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>consul&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>postgres&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>postgres&lt;span class="p">:&lt;/span>alpine&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>container_name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>postgres&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>ports&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;5432&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>environment&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>POSTGRES_USER=user&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>POSTGRES_PASSWORD=password&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>POSTGRES_DB=database&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>depends_on&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>registrator&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-compose.yml" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2019/05/registro-y-descubrimiento-de-servicios-en-contenedores-de-docker-con-consul-y-registrator/code/docker-compose.yml" target="_blank">docker-compose.yml&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>El proyecto de &lt;a href="https://projects.spring.io/spring-cloud/">Spring Cloud&lt;/a> ofrece soporte para ambas tareas de registrar y descubrir servicios, aunque perfectamente la tarea de registro se puede delegar como en este caso a Registrator y utilizar en los servicios de Spring Boot únicamente la parte de descubrimiento.&lt;/p>
&lt;p>
El &lt;a href="https://github.com/picodotdev/blog-ejemplos/tree/master/Registrator">código fuente completo del ejemplo&lt;/a> puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href="https://github.com/">GitHub&lt;/a> y probarlo en tu equipo ejecutando el comando &lt;code>./docker-compose-up.sh&lt;/code>.
&lt;/p></content><category term="planeta-codigo"/><category term="programacion"/><category term="software"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2017/04/imagenes-de-docker-con-alpine-linux/</id><title>Imágenes de Docker con Alpine Linux</title><updated>2017-04-28T23:00:00+02:00</updated><published>2017-04-28T23:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/04/imagenes-de-docker-con-alpine-linux/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;div class="logotypes" style="float: right; clear: right;">
&lt;img src="assets/images/logotipos/alpinelinux.svg" class="right " width="350" alt="Alpine Linux" title="Alpine Linux"/>
&lt;/div>
&lt;p>En el repositorio de imágenes &lt;a href="https://registry.hub.docker.com/">Docker Hub&lt;/a> de &lt;a href="https://www.docker.com/">Docker&lt;/a> hay múltiples versiones de cada software &lt;em>contenirizado&lt;/em>, alguna de las versiones están etiquetadas con la palabra &lt;em>alpine&lt;/em>. Las imágenes de Docker etiquetadas con &lt;em>alpine&lt;/em> hacen referencia a que usan como base la distribución &lt;a href="https://www.alpinelinux.org/">Alpine Linux&lt;/a> y la razón de usar Alpine Linux es que al ser una distribución minimalista basada en &lt;a href="https://www.busybox.net/">busybox&lt;/a> y &lt;a href="https://www.musl-libc.org/">musl-libc&lt;/a> hace que las imágenes ocupen bastante menos que una imagen equivalente por ejemplo basada en &lt;a href="https://www.ubuntu.com/">Ubuntu&lt;/a> o &lt;a href="https://www.debian.org/">Debian&lt;/a>, seguramente porque no contienen una buena cantidad de cosas innecesarias.&lt;/p>
&lt;p>Por ejemplo, la &lt;a href="https://hub.docker.com/_/openjdk/">imagen de Docker que contiene en JDK&lt;/a> de Java basada en Debian ocupa 643 MiB y la imagen de Java basada en Alpine Linux ocupa 101 MiB, una diferencia significativa de casi 500 MiB. Con la capacidad de los discos duros actuales no es tanto por lo que ocupan en disco sino por el tiempo que las imágenes tardan en descargarse desde el repositorio e iniciarse los contenedores como es el caso en un &lt;a href="https://picodotdev.github.io/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/">cluster de contenedores Docker&lt;/a>.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/imagenes-de-docker-con-alpine-linux/images/imagenes-docker.png" title="Imágenes de Docker con su tamaño. Ver imágenes openjdk, Ubuntu y Alpine. Linux" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/imagenes-de-docker-con-alpine-linux/images/imagenes-docker-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Imágenes de Docker con su tamaño. Ver imágenes openjdk, Ubuntu y Alpine Linux.&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>El tiempo de descarga solo se emplea la primera vez que se hace uso de una imagen pero como las imágenes se van actualizando hay que tener en cuenta que en cada nueva versión que se use hay que descargar una nueva imagen, cuanto más pequeñas sean las imágenes menos tiempo se emplea en descargarlas y más rápidamente se iniciarán los contenedores.&lt;/p>
&lt;p>La &lt;a href="https://hub.docker.com/_/ubuntu/">imagen base de Ubuntu&lt;/a> con la que crear nuevas ocupa 117 MiB y la &lt;a href="https://hub.docker.com/_/alpine/">imagen base de Alpine Linux&lt;/a> únicamente 3.98 MiB. Si creamos imágenes propias basadas en Alpine Linux deberemos saber que esta distribución usa su propio gestor de paquetes &lt;em>apk&lt;/em> y su propio &lt;a href="https://pkgs.alpinelinux.org/packages">repositorio de paquetes&lt;/a>. Para &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/">crear una imagen de Docker&lt;/a> hay que usar los archivos &lt;em>Dockerfile&lt;/em> que contienen las instrucciones para construir la imagen del contenedor.&lt;/p></content><category term="blog"/><category term="planeta-codigo"/><category term="planeta-linux"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/</id><title>Información sensible en los contenedores con Docker Secrets</title><updated>2017-04-22T12:00:00+02:00</updated><published>2017-04-22T12:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Parte de la información que usan los contenedores de Docker se debe proteger de accesos no deseados. Anteriormente en algunos casos se usaban variables de entorno para lanzar los contenedores lo que no es seguro si se listan los procesos del sistema con sus parámetros, incluir archivos en las imágenes de los contenedores tampoco es recomendable. Docker Secrets permite proporcionar y mantener segura la información sensible que usen los contenedores.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>Los contenedores de &lt;a href="https://www.docker.com/">Docker&lt;/a> necesitan acceder a algunos datos sensibles desde el punto de vista de la seguridad como usuarios y contraseñas, certificados SSL, claves privadas SSH o cualquier otra información de acceso restringido. Algunos de estos datos en Docker se proporcionan mediante variables de entorno al lanzar los contenedores, esto es inseguro ya que al hacer un listado de los procesos con sus parámetros de invocación los relativos a Docker mostrarán esta información, lo que es un posible problema de seguridad.&lt;/p>
&lt;p>Con &lt;a href="https://docs.docker.com/engine/swarm/secrets/">Docker Secrets&lt;/a> se puede gestionar esta información que se necesita en tiempo de ejecución pero que no se quiere almacenar en la imagen de Docker o en el repositorio de código fuente. Algunos ejemplos de información sensible son:&lt;/p>
&lt;ul>
&lt;li>Nombres de usuario y contraseñas.&lt;/li>
&lt;li>Certificados TLS y claves.&lt;/li>
&lt;li>Claves SSH.&lt;/li>
&lt;li>Otra información sensible como el nombre de una base de datos o el nombre de un servidor interno.&lt;/li>
&lt;/ul>
&lt;p>Los secretos de Docker se proporcionan a los contenedores que los necesitan y se transmiten de forma cifrada al nodo en el que se ejecuten. Los secretos se montan en el sistema de archivos en la ruta &lt;em>/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/em> de forma descifrada al que el servicio del contenedor puede acceder.&lt;/p>
&lt;p>Algunos comandos para manejar los secretos son los siguientes:&lt;/p>
&lt;ul>
&lt;li>&lt;em>docker secret create secreto&lt;/em>: crea un secreto.&lt;/li>
&lt;li>&lt;em>docker secret inspect secreto&lt;/em>: muestra los detalles de un secreto.&lt;/li>
&lt;li>&lt;em>docker secret ls&lt;/em>: lista los secretos creados.&lt;/li>
&lt;li>&lt;em>docker secret rm secreto&lt;/em>: elimina un secreto.&lt;/li>
&lt;li>Se usa el parámetro &lt;em>&amp;ndash;secret&lt;/em> para &lt;em>docker service create&lt;/em> y &lt;em>&amp;ndash;secret-add&lt;/em> y &lt;em>&amp;ndash;secret-rm flags&lt;/em> para &lt;em>docker service update&lt;/em>.&lt;/li>
&lt;/ul>
&lt;p>Usando un &lt;em>stack&lt;/em> de servicios con un archivo de &lt;a href="https://docs.docker.com/compose/">Docker Compose&lt;/a> en la sección &lt;em>secrets&lt;/em> de los servicios se indica cuales usa, en la sección &lt;em>secrets&lt;/em> se definen los secretos de los servicios con sus nombres y su contenido referenciando archivos que pueden ser binarios o de text no superior a 500 KiB.&lt;/p>
&lt;p>Al servicio de &lt;a href="https://nginx.org/">nginx&lt;/a> la clave privada y certificado para configurar el acceso mediante el protocolo seguro HTTPS se le proporciona a través de secretos que son referenciados en el archivo de configuración del servidor web &lt;em>nginx.conf&lt;/em>.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-YAML" data-lang="YAML">version&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3.1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>services&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>nginx&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>nginx&lt;span class="p">:&lt;/span>stable-alpine&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>ports&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;80:80&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;443:443&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>networks&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>proxy&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>secrets&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>nginx.conf&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>localhost.pem&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>localhost.key&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>command&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>sh&lt;span class="w"> &lt;/span>-c&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;exec nginx -c /run/secrets/nginx.conf -g &amp;#39;daemon off;&amp;#39;&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>app&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>localhost&lt;span class="p">:&lt;/span>&lt;span class="m">5000&lt;/span>/spring-boot-app&lt;span class="p">:&lt;/span>&lt;span class="m">1.0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>ports&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;8080:8080&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>networks&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>proxy&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>volumes&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>app&lt;span class="p">:&lt;/span>/data&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>secrets&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>message.txt&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>networks&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>proxy&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>volumes&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>app&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>driver&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>rexray&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>external&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>secrets&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>nginx.conf&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>file&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>./nginx.conf&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>localhost.pem&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>file&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>./localhost.pem&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>localhost.key&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>file&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>./localhost.key&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>message.txt&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>file&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>./message.txt&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/code/docker-compose-stack-app.yml" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/code/docker-compose-stack-app.yml" target="_blank">docker-compose-stack-app.yml&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">...
http {
...
upstream app {
server app_app:8080;
}
server {
listen 80;
server_name localhost;
return 301 https://$host$request_uri;
}
server {
listen 443;
server_name localhost;
ssl on;
ssl_certificate /run/secrets/localhost.pem;
ssl_certificate_key /run/secrets/localhost.key;
ssl_session_timeout 5m;
ssl_protocols SSLv2 SSLv3 TLSv1;
ssl_ciphers HIGH:!aNULL:!MD5;
ssl_prefer_server_ciphers on;
location / {
proxy_pass http://app;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
}
}
}&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/code/nginx.conf" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/code/nginx.conf" target="_blank">nginx.conf&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Por otra parte la aplicación Java con &lt;a href="https://projects.spring.io/spring-boot/">Spring Boot&lt;/a> lista el contenido de los secretos incorporados en el contenedor cuando se solicita en la URL &lt;em>https://192.168.99.100/system/info/&lt;/em>, esto no se debe hacer porque se pierde la seguridad que proporcionan los secretos pero sirve a modo de muestra en el ejemplo.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">io.github.picodotdev.blogbitix.dockerswarm&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="nd">@Component&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">HostInfoContributor&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">InfoContributor&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">contribute&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Info&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Builder&lt;/span> &lt;span class="n">builder&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">details&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="n">File&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="n">secrets&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">FileSystems&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getDefault&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPath&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/run/secrets/&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toFile&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">listFiles&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">File&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">secrets&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">String&lt;/span> &lt;span class="n">content&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Files&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lines&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toPath&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">collect&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Collectors&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">joining&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;\n&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">details&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">content&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Exception&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Exception&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">builder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">withDetails&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">details&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/code/HostInfoContributor.java" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/code/HostInfoContributor.java" target="_blank">HostInfoContributor.java&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>&lt;span class="err">.&lt;/span>&lt;span class="err">.&lt;/span>&lt;span class="err">.&lt;/span>&lt;span class="err">,&lt;/span>&lt;span class="nt">&amp;#34;message.txt&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;Hello World!&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/code/info.json" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/code/info.json" target="_blank">info.json&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/images/message.png" title="Contenido del archivo message.txt" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/images/message-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Contenido del archivo message.txt&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Para probar el ejemplo hay que ejecutar varios comandos, la secuencia completa es la siguiente:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ ./01-cluster-create.sh
$ ./02-vboxwebsrv.sh
$ ./03-rex-ray-install.sh
$ ./04-docker-compose-stack-deploy-registry.sh
$ ./05-spring-boot-app-build.sh
$ ./06-create-volumes.sh
$ ./06-docker-compose-stack-deploy-app.sh
$ curl -k https://192.168.99.100/system/info&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/code/run.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/informacion-sensible-en-los-contenedores-con-docker-secrets/code/run.sh" target="_blank">run.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>
El &lt;a href="https://github.com/picodotdev/blog-ejemplos/tree/master/DockerSwarm">código fuente completo del ejemplo&lt;/a> puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href="https://github.com/">GitHub&lt;/a>.
&lt;/p></content><category term="blog"/><category term="planeta-codigo"/><category term="planeta-linux"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/</id><title>Contenedores en Docker Swarm con volúmenes de datos persistentes usando REX-Ray y VirtualBox</title><updated>2017-04-16T23:00:00+02:00</updated><published>2017-04-16T12:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Salvo que un servicio sea sin estado o &lt;em>stateless&lt;/em> los contenedores de Docker necesitan persistir datos y que estos sobrevivan a su terminación, como es el caso de un contenedor de una base de datos. Además en un &lt;em>cluster&lt;/em> de nodos Docker hay que tener en cuenta que los datos deben estar accesibles para todos los nodos ya que un contenedor que usase los datos podría ser lanzado en cualquiera de ellos. REX-Ray es un sistema de almacenamiento en red que cubre estas necesidades, es simple de instalar, configurar y de iniciar. En el artículo muestro un ejemplo usando REX-Ray junto con Docker Swarm y VirtualBox.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>Los contenedores de datos son efímeros, se crean y se destruyen y con ellos los datos que tuviesen en su sistema de archivos de modo que cualquier dato que queramos que sobreviva a la vida del contenedor ha de almacenarse de forma externa, este es el caso de los datos de una base de datos como &lt;a href="https://www.postgresql.org/">PostgreSQL&lt;/a> o &lt;a href="https://www.mongodb.com/">MongoDB&lt;/a>. Además usando &lt;a href="https://docs.docker.com/swarm/">Docker Swarm&lt;/a> se plantea el problema de que hay varios nodos formando un &lt;em>cluster&lt;/em> por lo que los datos han de estar accesibles independientemente del nodo en el que sea iniciado el contenedor que los utilice y significa que los datos no pueden estar almacenados en el nodo ya que un contenedor podría ser iniciado en cualquiera de ellos.&lt;/p>
&lt;p>Así que los contenedores iniciados en un &lt;em>cluster&lt;/em> de Docker Swarm que usen datos persistentes necesitan un sistema de almacenamiento en red externo a los contenedores y nodos. Una de las opciones disponibles es &lt;a href="https://rexray.codedellemc.com/">REX-Ray&lt;/a> que ofrece una configuración sencilla y múltiples proveedores de computación entre las que están las más populares como &lt;a href="http://aws.amazon.com/es/ec2/">Amazon EC2&lt;/a>, &lt;a href="https://www.digitalocean.com/">Digital Ocean&lt;/a>, &lt;a href="https://cloud.google.com/compute/">Google Compute Engine&lt;/a>, &lt;a href="https://azure.microsoft.com/es-es/">microsoft-azure&lt;/a> e incluso &lt;a href="https://www.virtualbox.org/">VirtualBox&lt;/a>.&lt;/p>
&lt;p>En el siguiente ejemplo uso un &lt;em>cluster&lt;/em> de nodos Docker, VirtualBox y REX-Ray para proporcionar volúmenes de datos persistentes para un contenedor que tiene una base de datos postgres basándome en el artículo previo &lt;a href="https://picodotdev.github.io/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/">Crear un &lt;em>cluster&lt;/em> de contenedores Docker&lt;/a> donde explicaba como crear un &lt;em>cluster&lt;/em> de nodos con Docker Swarm.&lt;/p>
&lt;p>Para la integración entre VirtualBox y REX-Ray hay que iniciar primero un servidor en el &lt;em>host&lt;/em> que permite a REX-Ray hacer llamadas remotas a VirtualBox para que gestione los volúmenes de datos.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
VBoxManage setproperty websrvauthlibrary null
vboxwebsrv -H 0.0.0.0 -v&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/02-vboxwebsrv.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/02-vboxwebsrv.sh" target="_blank">02-vboxwebsrv.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Si hay un &lt;em>firewall&lt;/em> hay que permitir el tráfico para el puerto &lt;em>18083&lt;/em>, en mi caso que uso &lt;em>ufw&lt;/em> creando la siguiente regla.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ sudo ufw allow to any port &lt;span class="m">18083&lt;/span> from 192.168.0.0/16
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/ufw.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/ufw.sh" target="_blank">ufw.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Con el &lt;em>cluster&lt;/em> creado debemos instalar y configurar REX-Ray en cada uno de los nodos ejecutando varios comandos, un comando instala REX-Ray, otro crea el archivo de configuración en &lt;em>/etc/rexray/config.yml&lt;/em> y finalmente otro inicia el servicio de REX-Ray. Algunas opciones que se indican en el archivo de configuración de REX-Ray es la ubicación en el &lt;em>host&lt;/em> donde se guardan los volúmenes con el parámetro &lt;em>volumePath&lt;/em>.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="c1">#sudo ufw allow to any port 18083 from 192.168.0.0/16&lt;/span>
&lt;span class="k">for&lt;/span> i in &lt;span class="s2">&amp;#34;01&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;02&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;03&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
docker-machine ssh node-&lt;span class="nv">$i&lt;/span> &lt;span class="s2">&amp;#34;curl -sSL https://dl.bintray.com/emccode/rexray/install | sh -&amp;#34;&lt;/span>
docker-machine ssh node-&lt;span class="nv">$i&lt;/span> &lt;span class="s2">&amp;#34;cat &amp;gt; /tmp/rexray-config.yml &amp;lt;&amp;lt; EOF
&lt;/span>&lt;span class="s2">rexray:
&lt;/span>&lt;span class="s2"> logLevel: info
&lt;/span>&lt;span class="s2">libstorage:
&lt;/span>&lt;span class="s2"> service: virtualbox
&lt;/span>&lt;span class="s2">virtualbox:
&lt;/span>&lt;span class="s2"> endpoint: http://192.168.99.1:18083
&lt;/span>&lt;span class="s2"> volumePath: /run/media/picodotdev/BMOVE ROJO/docker-machine/volumes/
&lt;/span>&lt;span class="s2"> controllerName: SATA
&lt;/span>&lt;span class="s2">EOF
&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
docker-machine ssh node-&lt;span class="nv">$i&lt;/span> &lt;span class="s2">&amp;#34;sudo mkdir -p /etc/rexray/&amp;#34;&lt;/span>
docker-machine ssh node-&lt;span class="nv">$i&lt;/span> &lt;span class="s2">&amp;#34;sudo mv /tmp/rexray-config.yml /etc/rexray/config.yml&amp;#34;&lt;/span>
docker-machine ssh node-&lt;span class="nv">$i&lt;/span> &lt;span class="s2">&amp;#34;sudo rexray start&amp;#34;&lt;/span>
&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/03-rex-ray-install.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/03-rex-ray-install.sh" target="_blank">03-rex-ray-install.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/images/instalacion-rex-ray.png" title="Instalación de REX-Ray en nodos de Docker Swarm con VirtualBox" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/images/instalacion-rex-ray-thumb.png" width="254"/>&lt;/a>
&lt;figcaption>Instalación de REX-Ray en nodos de Docker Swarm con VirtualBox&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Para probar la persistencia de datos usaré un &lt;em>stack&lt;/em> iniciado de la misma forma que en artículo &lt;a href="https://picodotdev.github.io/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/">Iniciar un stack de servicios en un cluster de Docker Swarm&lt;/a> pero con un contenedor de postgres que guarda los datos en un volumen de REX-Ray en &lt;em>/var/lib/postgresql/data&lt;/em>. Para iniciar el &lt;em>stack&lt;/em> el &lt;em>custer&lt;/em> de Docker Swarm uso un archivo de &lt;a href="https://docs.docker.com/compose/">Docker Compose&lt;/a> con la definición del &lt;em>stack&lt;/em> en formato YAML.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-YAML" data-lang="YAML">version&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3.1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>services&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>postgres&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>postgres&lt;span class="p">:&lt;/span>latest&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>ports&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;5432:5432&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>volumes&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>postgres&lt;span class="p">:&lt;/span>/var/lib/postgresql/data&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>volumes&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>postgres&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>external&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/docker-compose-stack-postgres.yml" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/docker-compose-stack-postgres.yml" target="_blank">docker-compose-stack-postgres.yml&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
docker stack deploy -c docker-compose-stack-postgres.yml postgres
sleep 30s
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Cluster services&amp;#34;&lt;/span>
docker service ls
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Nginx service tasks&amp;#34;&lt;/span>
docker service ps nginx_nginx
&lt;span class="k">for&lt;/span> i in &lt;span class="s2">&amp;#34;01&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;02&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;03&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="s2">\n# Node &lt;/span>&lt;span class="nv">$i&lt;/span>&lt;span class="s2"> containers&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-&lt;span class="nv">$i&lt;/span>&lt;span class="k">)&lt;/span>
docker ps
&lt;span class="k">done&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/06-docker-compose-stack-deploy-postgres.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/06-docker-compose-stack-deploy-postgres.sh" target="_blank">06-docker-compose-stack-deploy-postgres.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>En la siguiente captura de pantalla se observa en que nodo ha sido iniciado el contenedor de postgres y que identificativo se le ha asignado.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/images/stack-deploy-postgres.png" title="Deploy del stack de postgres" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/images/stack-deploy-postgres-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Deploy del stack de postgres&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>En el &lt;em>stack&lt;/em> el volumen de datos postgres está declarado y creado de forma externa. Usando VirtualBox con REX-Ray en el &lt;em>host&lt;/em> o anfitrión se crea un archivo que contiene los datos del volumen. Al listar los volúmenes de datos además de los creados &lt;em>postgres&lt;/em> y &lt;em>app&lt;/em> están los de los discos duros de cada uno de los nodos identificados como &lt;em>disk.vmdk&lt;/em>. El parámetro &lt;em>opt=size=5&lt;/em> indica que el volumen de datos es de una tamaño de 5GiB.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
docker volume create --driver&lt;span class="o">=&lt;/span>rexray --name&lt;span class="o">=&lt;/span>postgres --opt&lt;span class="o">=&lt;/span>&lt;span class="nv">size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">5&lt;/span>
docker volume create --driver&lt;span class="o">=&lt;/span>rexray --name&lt;span class="o">=&lt;/span>app --opt&lt;span class="o">=&lt;/span>&lt;span class="nv">size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">5&lt;/span>
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Volumes&amp;#34;&lt;/span>
docker volume ls&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/06-create-volumes.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/06-create-volumes.sh" target="_blank">06-create-volumes.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/images/volumes.png" title="Volúmenes de datos" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/images/volumes-thumb.png" width="300"/>&lt;/a>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/images/volumes-nautilus.png" title="Archivos de volúmenes en el sistema de archivos del host" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/images/volumes-nautilus-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Volúmenes de datos&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Para crear algunos datos en la base de datos hay que conectarse al contenedor y lanzar algunas sentencias SQL. Hay que obtener el identificativo del contenedor de postgres, iniciar un proceso &lt;em>bash&lt;/em>, realizar la conexión a la base de datos con el cliente &lt;em>psql&lt;/em> y lanzar las sentencias SQL.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker ps -q --filter &lt;span class="nv">label&lt;/span>&lt;span class="o">=&lt;/span>com.docker.swarm.service.name&lt;span class="o">=&lt;/span>postgres_postgres
ac90f7e1e7b5
$ docker &lt;span class="nb">exec&lt;/span> -it ac90f7e1e7b5 /bin/bash
postgres-# psql --username&lt;span class="o">=&lt;/span>postgres
&lt;span class="nv">postgres&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="c1"># CREATE TABLE COMPANY(&lt;/span>
postgres&lt;span class="o">(&lt;/span>&lt;span class="c1"># ID SERIAL PRIMARY KEY NOT NULL,&lt;/span>
postgres&lt;span class="o">(&lt;/span>&lt;span class="c1"># NAME TEXT NOT NULL,&lt;/span>
postgres&lt;span class="o">(&lt;/span>&lt;span class="c1"># AGE INT NOT NULL,&lt;/span>
postgres&lt;span class="o">(&lt;/span>&lt;span class="c1"># ADDRESS CHAR(50),&lt;/span>
postgres&lt;span class="o">(&lt;/span>&lt;span class="c1"># SALARY REAL&lt;/span>
postgres&lt;span class="o">(&lt;/span>&lt;span class="c1"># );&lt;/span>
CREATE TABLE
&lt;span class="nv">postgres&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="c1"># \dt&lt;/span>
List of relations
Schema &lt;span class="p">|&lt;/span> Name &lt;span class="p">|&lt;/span> Type &lt;span class="p">|&lt;/span> Owner
--------+---------+-------+----------
public &lt;span class="p">|&lt;/span> company &lt;span class="p">|&lt;/span> table &lt;span class="p">|&lt;/span> postgres
&lt;span class="o">(&lt;/span>&lt;span class="m">1&lt;/span> row&lt;span class="o">)&lt;/span>
&lt;span class="nv">postgres&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="c1"># \d+ company&lt;/span>
Table &lt;span class="s2">&amp;#34;public.company&amp;#34;&lt;/span>
Column &lt;span class="p">|&lt;/span> Type &lt;span class="p">|&lt;/span> Modifiers &lt;span class="p">|&lt;/span> Storage &lt;span class="p">|&lt;/span> Stats target &lt;span class="p">|&lt;/span> Descrip
tion
---------+---------------+------------------------------------------------------+----------+--------------+--------
-----
id &lt;span class="p">|&lt;/span> integer &lt;span class="p">|&lt;/span> not null default nextval&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;company_id_seq&amp;#39;&lt;/span>::regclass&lt;span class="o">)&lt;/span> &lt;span class="p">|&lt;/span> plain &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span>
name &lt;span class="p">|&lt;/span> text &lt;span class="p">|&lt;/span> not null &lt;span class="p">|&lt;/span> extended &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span>
age &lt;span class="p">|&lt;/span> integer &lt;span class="p">|&lt;/span> not null &lt;span class="p">|&lt;/span> plain &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span>
address &lt;span class="p">|&lt;/span> character&lt;span class="o">(&lt;/span>50&lt;span class="o">)&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> extended &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span>
salary &lt;span class="p">|&lt;/span> real &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> plain &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span>
Indexes:
&lt;span class="s2">&amp;#34;company_pkey&amp;#34;&lt;/span> PRIMARY KEY, btree &lt;span class="o">(&lt;/span>id&lt;span class="o">)&lt;/span>
&lt;span class="nv">postgres&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="c1"># INSERT INTO COMPANY (name, age, address, salary) VALUES (&amp;#39;Company A&amp;#39;, 21, &amp;#39;13, Rue del Percebe&amp;#39;, 45000);&lt;/span>
INSERT &lt;span class="m">0&lt;/span> &lt;span class="m">1&lt;/span>
&lt;span class="nv">postgres&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="c1"># SELECT * FROM company;&lt;/span>
id &lt;span class="p">|&lt;/span> name &lt;span class="p">|&lt;/span> age &lt;span class="p">|&lt;/span> address &lt;span class="p">|&lt;/span> salary
----+-----------+-----+----------------------------------------------------+--------
&lt;span class="m">3&lt;/span> &lt;span class="p">|&lt;/span> Company A &lt;span class="p">|&lt;/span> &lt;span class="m">21&lt;/span> &lt;span class="p">|&lt;/span> 13, Rue del Percebe &lt;span class="p">|&lt;/span> &lt;span class="m">45000&lt;/span>
&lt;span class="o">(&lt;/span>&lt;span class="m">1&lt;/span> row&lt;span class="o">)&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/postgres.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/postgres.sh" target="_blank">postgres.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Destruyendo el &lt;em>stack&lt;/em> y volviéndolo a arrancar posiblemente Docker Swarm iniciará el contenedor en otro nodo del &lt;em>cluster&lt;/em> pero los datos seguirán estando presentes en la base de datos postgres, se puede comprobar iniciando una nueva sesión bash en el nuevo contenedor, iniciando el cliente de psql y lanzando la consulta &lt;em>select&lt;/em> de SQL o con el comando &lt;code>\dt&lt;/code> para obtener las tablas de la base de datos, &lt;em>\d+ company&lt;/em> para obtener una descripción de la tabla y la consulta SQL &lt;em>SELECT * FROM company;&lt;/em>.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
docker stack rm postgres&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/docker-compose-stack-remove-postgres.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/contenedores-en-docker-swarm-con-volumenes-de-datos-persistentes-usando-rex-ray-y-virtualbox/code/docker-compose-stack-remove-postgres.sh" target="_blank">docker-compose-stack-remove-postgres.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>
El &lt;a href="https://github.com/picodotdev/blog-ejemplos/tree/master/DockerSwarm">código fuente completo del ejemplo&lt;/a> puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href="https://github.com/">GitHub&lt;/a>.
&lt;/p>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="https://rexray.readthedocs.io/en/v0.3.3/user-guide/installation/">REX-Ray Installation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rexray.readthedocs.io/en/v0.3.3/user-guide/installation/#docker-machine-virtualbox">REX-Ray Installation - Docker Machine (VirtualBox)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rexray.readthedocs.io/en/v0.3.3/user-guide/storage-providers/#virtualbox">REX-Ray Storage Providers - VirtualBox&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://rexray.readthedocs.io/en/stable/user-guide/applications/">REX-Ray - Applications&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="blog"/><category term="planeta-codigo"/><category term="planeta-linux"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/</id><title>Escalar y actualizar un servicio de un cluster de Docker Swarm</title><updated>2017-04-16T13:00:00+02:00</updated><published>2017-04-09T11:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Ya tenemos un &lt;em>cluster&lt;/em> formado por varios nodos con algún servicio ejecutándose en el &lt;em>cluster&lt;/em> de Docker Swarm. Si surge la necesidad los servicios del &lt;em>cluster&lt;/em> se pueden escalar cambiando el número de instancias de contenedores que forma el servicio para atender las necesidades computacionales o para ofrecer el servicio a más usuarios. Por otro lado, pasado un tiempo muy posiblemente se publicará una nueva imagen de los contenedores, el servicio se puede actualizar para que los contenedores utilicen esa nueva imagen.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>Una vez que ya hemos &lt;a href="https://picodotdev.github.io/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/">creado un &lt;em>cluster&lt;/em> de nodos con Docker Swarm&lt;/a> y hemos desplegado algunos servicios ya sea directamente mediante comandos para crear servicios o mediante un &lt;a href="https://picodotdev.github.io/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/">&lt;em>stack&lt;/em> con un archivo similar a un Docker Compose&lt;/a> al cabo de un tiempo necesitaremos hacer otras operaciones. Dos de esas operaciónes básicas son escalar hacia arriba o hacia abajo un servicio cambiando el número de instancias de contenedores desplegadas o actualizar la imagen que utilizan los servicios por otra diferente posiblemente más nueva.&lt;/p>
&lt;p>En la documentación de &lt;a href="https://www.docker.com/">Docker&lt;/a> están detallados y comentados los &lt;a href="https://docs.docker.com/engine/swarm/swarm-tutorial/scale-service/">comandos para escalar un servicio&lt;/a>. Por ejemplo, en el &lt;em>cluster&lt;/em> de ejemplo formado por tres nodos, uno con el rol de &lt;em>manager&lt;/em> y otros dos como &lt;em>worker&lt;/em>, ejecutándose en &lt;a href="https://www.virtualbox.org/">VirtualBox&lt;/a> y desplegando un servicio para el servidor &lt;a href="https://nginx.org/">nginx&lt;/a> con inicialmente una réplica o instancia podemos escalar el servicio para que se cree alguna instancia o contenedor más del servicio con el siguiente comando &lt;code>docker service scale&lt;/code>.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Nginx service tasks&amp;#34;&lt;/span>
docker service ps nginx
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Nginx service inspect&amp;#34;&lt;/span>
docker service inspect --pretty nginx
docker service scale &lt;span class="nv">nginx&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">4&lt;/span>
sleep 1m
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Nginx service tasks&amp;#34;&lt;/span>
docker service ps nginx
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Nginx service inspect&amp;#34;&lt;/span>
docker service inspect --pretty nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/code/06-nginx-scale.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/code/06-nginx-scale.sh" target="_blank">06-nginx-scale.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Al igual que cuando se crea un contenedor para un servicio en el &lt;em>cluster&lt;/em> &lt;a href="https://docs.docker.com/swarm/">Docker Swarm&lt;/a> si no se indica alguna restricción decidirá en qué nodos se crean las nuevas instancias o contenedores del servicio.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/images/nginx-service-1.png" title="Servicio de nginx con una réplica" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/images/nginx-service-1-thumb.png" width="300"/>&lt;/a>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/images/nginx-service-4.png" title="Servicio de nginx escalado a cuatro réplicas" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/images/nginx-service-4-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Servicio de nginx antes y después de escalarlo&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/images/nginx-service-scale.png" title="Escalado del servicio de nginx" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/images/nginx-service-scale-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Escalado del servicio de nginx&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Por otro lado, una vez desplegados en un &lt;em>cluster&lt;/em> algunos servicios llegará el momento en que queramos actualizar algún parámetro del servicio, uno de ellos será probablemente la imagen del servicio cuando se publique una nueva. En la página de documentación &lt;a href="https://docs.docker.com/engine/swarm/swarm-tutorial/rolling-update/">Aplicando actualizaciones a un servicio&lt;/a> está explicada esta funcionalidad y los comandos junto con sus opciones que hay que utilizar.&lt;/p>
&lt;p>En el ejemplo al crear el &lt;em>cluster&lt;/em> se usa la última imagen de docker para nginx, en un entorno de producción es más recomendable establecer una versión en concreto para evitar que la imagen que se usa no varía desde que se prueba hasta que se despliega. El siguiente &lt;em>script&lt;/em> actualiza la imagen a la versión &lt;em>nginx:1.10-alpine&lt;/em> en todas las réplicas del servicio de nginx en el &lt;em>cluster&lt;/em>.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Nginx service tasks&amp;#34;&lt;/span>
docker service ps nginx
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Nginx service inspect&amp;#34;&lt;/span>
docker service inspect --pretty nginx
docker service update --image nginx:1.10-alpine nginx
sleep 1m
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Nginx service tasks&amp;#34;&lt;/span>
docker service ps nginx
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Nginx service inspect&amp;#34;&lt;/span>
docker service inspect --pretty nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/code/06-nginx-update.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/code/06-nginx-update.sh" target="_blank">06-nginx-update.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/images/nginx-service-update.png" title="Actualización de la imagen del servicio de nginx" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/images/nginx-service-update-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Actualización de la imagen del servicio de nginx&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Docker Swarm realiza el proceso de actualización siguiendo los siguientes pasos:&lt;/p>
&lt;ul>
&lt;li>Detiene el primer contenedor o tarea a actualizar.&lt;/li>
&lt;li>Programa la actualización del contenedor o tarea detenida.&lt;/li>
&lt;li>Inicia una nueva tarea actualizado.&lt;/li>
&lt;li>Si la tarea actualizada retorna su estado como &lt;em>RUNNING&lt;/em> se espera un tiempo determinado y se inicia el proceso de actualización de una nueva tarea.&lt;/li>
&lt;li>Si, en cualquier momento durante la actualización, una tarea retorna su estado como &lt;em>FAILED&lt;/em>, se detiene la actualización.&lt;/li>
&lt;/ul>
&lt;p>Por defecto, el planificador actualiza las tareas o contenedores del servicio de uno en uno. Con la opción &lt;em>&amp;ndash;update-parallelism&lt;/em> se especifica el número de tareas del servicio que se actualizan simultáneamente. La opción &lt;em>&amp;ndash;update-delay&lt;/em> especifica el tiempo de espera desde que se actualiza la tarea de un servicio y la siguiente. Se puede describir como una combinación de segundos, minutos o horas, de modo que 1m30s indica una espera de 1 minuto y 30 segundos.&lt;/p>
&lt;p>En los &lt;a href="https://docs.docker.com/compose/compose-file/">archivos en formato YAML de los &lt;em>stacks&lt;/em> de Docker Compose&lt;/a> hay una sección en cada servicio en el que se indica el número de contenedores que se desea que esté formado el servicio así como las opciones de paralelismo y tiempo de espera entre actualización. Para actualizar el &lt;em>stack&lt;/em> basta con hacer de nuevo el &lt;em>deploy&lt;/em>, ya sea la imagen usada, el número de réplicas u otros parámetros.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-YAML" data-lang="YAML">...&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>deploy&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>replicas&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">4&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>update_config&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>parallelism&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>delay&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>1m30s&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>...&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/code/docker-compose-stack-app.yml" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/escalar-y-actualizar-un-servicio-de-un-cluster-de-docker-swarm/code/docker-compose-stack-app.yml" target="_blank">docker-compose-stack-app.yml&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>
El &lt;a href="https://github.com/picodotdev/blog-ejemplos/tree/master/DockerSwarm">código fuente completo del ejemplo&lt;/a> puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href="https://github.com/">GitHub&lt;/a>.
&lt;/p></content><category term="blog"/><category term="planeta-codigo"/><category term="planeta-linux"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/</id><title>Iniciar un stack de servicios en un cluster de Docker Swarm</title><updated>2017-04-02T12:00:00+02:00</updated><published>2017-04-02T12:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Los &lt;em>stacks&lt;/em> en Docker Swarm son definiciones en un archivo de texto en formato YAML de múltiples servicios además de volúmenes, redes de software y secretos. Esta definición de un &lt;em>stack&lt;/em> ejecutado en un &lt;em>cluster&lt;/em> de nodos Docker Swarm permite iniciar múltiples contenedores además de los otros elementos que necesiten para su funcionamiento. Los &lt;em>stacks&lt;/em> son el equivalente para Docker Swarm de los archivos multicontenedor de Docker Compose, y el formato de ambos muy similar.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>Con &lt;a href="https://docs.docker.com/compose/">Docker Compose&lt;/a> se pueden &lt;a href="https://picodotdev.github.io/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/">definir en un único archivo un conjunto de contenedores&lt;/a> que forma un servicio o aplicación y que se lanzan como una unidad. En vez de ejecutar los comandos individuales que inician cada contenedor el archivo en formato &lt;a href="https://www.yaml.org/">yaml&lt;/a> de Docker Compose define varios contenedores y al ser un archivo de texto es añadible a un sistema de control de versiones para registrar los cambios. La información del archivo de Docker Compose es la misma que se indicaría en el comando para iniciar un contenedor individual.&lt;/p>
&lt;p>En versiones más recientes se ha modificado ligeramente el formato del archivo de Docker Compose para añadirle las características necesarias que necesita &lt;a href="https://docs.docker.com/swarm/">Docker Swarm&lt;/a>, la &lt;a href="https://picodotdev.github.io/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/">herramienta integrada en Docker que permite crear &lt;em>clusters&lt;/em> de nodos&lt;/a> que ejecuten contenedores &lt;a href="https://www.docker.com/">Docker&lt;/a>. A estos archivos ahora se les denomina como &lt;em>stacks&lt;/em>. Así hay nuevas secciones como &lt;em>services&lt;/em>, &lt;em>networks&lt;/em>, &lt;em>volumes&lt;/em> y &lt;em>secrets&lt;/em> entre otras para soportar algunas funcionalidades adicionales. La sección &lt;em>services&lt;/em> es similar a la que usábamos en Docker Compose y define los contenedores. Por ejemplo, para definir que el servicio se componga de un contenedor con un servidor web &lt;a href="https://nginx.org/">nginx&lt;/a> usaríamos el siguiente archivo. El parámetro &lt;em>version&lt;/em> es muy importante ya que indica las opciones soportadas en el archivo.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-YAML" data-lang="YAML">version&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3.1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>services&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>nginx&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>nginx&lt;span class="p">:&lt;/span>stable-alpine&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>ports&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;80:80&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;443:443&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>deploy&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>replicas&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">2&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/code/docker-compose-stack-nginx.yml" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/code/docker-compose-stack-nginx.yml" target="_blank">docker-compose-stack-nginx.yml&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>A destacar las opciones &lt;em>deploy&lt;/em> y &lt;em>replicas&lt;/em> ya que indican cuantas instancias o contenedores de ese servicio habrá en el &lt;em>cluster&lt;/em>. Al igual que con los comandos de Docker Swarm era posible crear redes por software a las cuales conectar los contenedores para que se puedan comunicar entre sí en la sección &lt;em>networks&lt;/em> de cada servicio se indica las redes a las que conectarlo y en la sección a nivel raíz del archivo las redes a crear.&lt;/p>
&lt;p>También hay una sección propia para definir los volúmenes que dependiendo del &lt;em>driver&lt;/em> se integra con diferentes plataformas de computación como &lt;a href="http://aws.amazon.com/es/ec2/">Amazon EC2&lt;/a>, &lt;a href="https://www.digitalocean.com/">Digital Ocean&lt;/a>, &lt;a href="https://www.virtualbox.org/">VirtualBox&lt;/a> con &lt;a href="https://rexray.readthedocs.io/en/v0.3.3/">REX-Ray&lt;/a>, &amp;hellip;. Los volúmenes proporcionan persistencia a los efímeros contenedores, por un lado almacenar datos que deban sobrevivir a la vida de un contenedor en su sistema de archivos es inadecuado ya que sus datos no son compartidos si se inicia otra instancia del contenedor y son eliminados cuando el contenedor desaparece, por otro lado en un &lt;em>cluster&lt;/em> de contenedores Docker si un contenedor de un servicio finaliza inexperadamente Docker Swarm puede decidir reiniciarlo en cualquier otro nodo del &lt;em>cluster&lt;/em> para mantener el estado del servicio por lo que los archivos compartidos no pueden estar tampoco en el &lt;em>host&lt;/em> que hospeda los contenedores. Por estos motivos Docker Swarm necesita de un sistema de persistencia, que en este caso son los volúmenes definidos en la sección del mismo nombre &lt;em>volumes&lt;/em>.&lt;/p>
&lt;p>Para mayor seguridad se ha incorporado la sección &lt;em>secrets&lt;/em> en la que se especifican elementos de datos como archivos que en el contenedor se montan en el directorio &lt;em>/run/secrets/&lt;/em>. Algunos elementos sensibles como usuarios y contraseñas al proporcionarse como parámetros o variables de entorno aparecen haciendo un listado de procesos del sistema con sus respectivos comandos de lanzamiento y parámetros, lo que es un problema de seguridad. Hay otros elementos sensibles como claves SSH, claves privadas o certificados que ahora con los &lt;em>secrets&lt;/em> no es necesario incluirlos en la propia imagen del contenedor.&lt;/p>
&lt;p>La forma de iniciar y eliminar un &lt;em>stack&lt;/em> en un &lt;em>cluster&lt;/em> de nodos Docker Swarm es el siguiente:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
docker stack deploy -c docker-compose-stack-nginx.yml nginx
sleep 30s
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Cluster services&amp;#34;&lt;/span>
docker service ls
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;\n# Nginx service tasks&amp;#34;&lt;/span>
docker service ps nginx_nginx
&lt;span class="k">for&lt;/span> i in &lt;span class="s2">&amp;#34;01&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;02&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;03&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="s2">\n# Node &lt;/span>&lt;span class="nv">$i&lt;/span>&lt;span class="s2"> containers&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-&lt;span class="nv">$i&lt;/span>&lt;span class="k">)&lt;/span>
docker ps
&lt;span class="k">done&lt;/span>
&lt;span class="k">for&lt;/span> i in &lt;span class="s2">&amp;#34;01&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;02&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;03&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="s2">\n# Node &lt;/span>&lt;span class="nv">$i&lt;/span>&lt;span class="s2"> request&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="nv">NODE_IP&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>docker-machine ip node-&lt;span class="nv">$i&lt;/span>&lt;span class="k">)&lt;/span>
curl http://&lt;span class="nv">$NODE_IP&lt;/span>/
&lt;span class="k">done&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/code/06-docker-compose-stack-deploy-nginx.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/code/06-docker-compose-stack-deploy-nginx.sh" target="_blank">06-docker-compose-stack-deploy-nginx.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
docker stack rm nginx&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/code/docker-compose-stack-remove-nginx.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/code/docker-compose-stack-remove-nginx.sh" target="_blank">docker-compose-stack-remove-nginx.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/images/nginx-service.png" title="" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/images/nginx-service-thumb.png" width="281"/>&lt;/a>
&lt;figcaption>Cluster de nodos de Docker Swarm con servicio de nginx replicado con 2 instancias&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>En la captura de la terminal se aprecia como estando el &lt;em>cluster&lt;/em> formado por tres nodos y el servicio estando replicado con dos instancias Docker Swarm ha decidido iniciar una instancia de contenedor nginx en el &lt;em>nodo-01&lt;/em> y otra en el &lt;em>nodo-03&lt;/em> pero perfectamente podría haber iniciado una de ellas en el &lt;em>nodo-02&lt;/em>. Gracias a las capacidades de &lt;em>networking&lt;/em> de Docker Swarm con &lt;a href="https://docs.docker.com/engine/swarm/ingress/">Routing Mesh&lt;/a> al cualquier nodo que se le haga una petición al puerto 80 del servicio de nginx devolverá una respuesta, incluso si se hace en el ejemplo la petición al &lt;em>nodo-02&lt;/em> la respuesta será devuelta aunque en ese nodo no tenga una instancia de contenedor ejecutándose, realmente redirigirá la petición de forma transparente para el cliente la petición a un nodo que si tenga una instancia de nginx. También, al estar el servicio replicado con dos instancias Docker Swarm realizará automáticamente un &lt;a href="https://docs.docker.com/docker-cloud/getting-started/deploy-app/9_load-balance_the_service/">balanceo de carga&lt;/a> &lt;em>round-robin&lt;/em> repartiendo las peticiones entre cada una de las instancias de nginx.&lt;/p>
&lt;p>De los &lt;em>volumes&lt;/em> y &lt;em>secrets&lt;/em> en posteriores entregas de esta &lt;a href="https://picodotdev.github.io/blog-bitix/series/docker/">serie de artículos sobre Docker&lt;/a> las comentaré de forma específica. El &lt;em>stack&lt;/em> de servicios mostrado en este ejemplo es muy sencillo. Aunque también sencillo en el mismo código fuente del ejemplo incluyo otro &lt;em>stack&lt;/em> formado por un servicio de nginx y una aplicación Java con &lt;a href="https://projects.spring.io/spring-boot/">Spring Boot&lt;/a> que hace uso de &lt;em>secrets&lt;/em> y &lt;em>volumes&lt;/em>.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-YAML" data-lang="YAML">version&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3.1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>services&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>nginx&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>nginx&lt;span class="p">:&lt;/span>stable-alpine&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>ports&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;80:80&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;443:443&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>networks&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>proxy&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>secrets&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>nginx.conf&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>localhost.pem&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>localhost.key&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>command&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>sh&lt;span class="w"> &lt;/span>-c&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;exec nginx -c /run/secrets/nginx.conf -g &amp;#39;daemon off;&amp;#39;&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>app&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>localhost&lt;span class="p">:&lt;/span>&lt;span class="m">5000&lt;/span>/spring-boot-app&lt;span class="p">:&lt;/span>&lt;span class="m">1.0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>ports&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;8080:8080&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>networks&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>proxy&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>volumes&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>app&lt;span class="p">:&lt;/span>/data&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>secrets&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>message.txt&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>networks&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>proxy&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>volumes&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>app&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>driver&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>rexray&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>external&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>secrets&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>nginx.conf&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>file&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>./nginx.conf&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>localhost.pem&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>file&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>./localhost.pem&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>localhost.key&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>file&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>./localhost.key&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>message.txt&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>file&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>./message.txt&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/code/docker-compose-stack-app.yml" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/04/iniciar-un-stack-de-servicios-en-un-cluster-de-docker-swarm/code/docker-compose-stack-app.yml" target="_blank">docker-compose-stack-app.yml&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Un libro que me ha gustado mucho y que recomiendo leer sobre Docker Swarm es &lt;a href="https://amzn.to/2mIirti">The Devops 2.1 Toolkit&lt;/a> que lo explica detalladamente y todo el libro está orientado a como usarlo en un entorno de producción. Un libro más introductorio que también he leído y que está bastante bien es &lt;a href="https://amzn.to/2mF3Xtj">Docker in Action&lt;/a>.&lt;/p>
&lt;div class="media-amazon" style="text-align: center;">
&lt;iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=a6c4acab72c208d29232f2e0a8edb8ee">&lt;/iframe>
&lt;iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1542468914&amp;linkId=2101ae950cfcfe9e69b6cc1210e4bf2c">&lt;/iframe>
&lt;/div>
&lt;p>Docker Swarm es una opción simple y que está integrada en Docker pero no ofrece todas las funcionalidades de algunas otras opciones que el algunos casos de uso algo más avanzados son necesarias o convenientes. &lt;a href="https://www.nomadproject.io/">Nomad&lt;/a> es otra opción simple para gestionar un conjunto de aplicaciones o servicios pero con algunas funcionalidades adicionales que no posee Docker Swarm como escribo en &lt;a href="https://picodotdev.github.io/blog-bitix/2019/04/introduccion-a-nomad-para-gestionar-aplicaciones-y-microservicios/">Introducción a Nomad para gestionar aplicaciones y microservicios&lt;/a>.&lt;/p>
&lt;p>
El &lt;a href="https://github.com/picodotdev/blog-ejemplos/tree/master/DockerSwarm">código fuente completo del ejemplo&lt;/a> puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href="https://github.com/">GitHub&lt;/a>.
&lt;/p>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="https://docs.docker.com/engine/swarm/stack-deploy/">Deploy a stack to a swarm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/compose/compose-file/">Compose file reference&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="blog"/><category term="planeta-codigo"/><category term="planeta-linux"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/</id><title>Introducción y ejemplo de cluster de contenedores con Docker Swarm</title><updated>2017-03-19T12:00:00+01:00</updated><published>2017-03-19T12:00:00+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Las funcionalidades de Docker Swarm están incorporadas en Docker para gestionar &lt;em>clusters&lt;/em> de nodos con contenedores de los servicios que deseemos. En artículo comentaré algunas de las propiedades de &lt;em>networkning&lt;/em> distribuido incorporado en Docker, como crear un &lt;em>cluster&lt;/em> de nodos Docker usando VirtualBox con máquinas virtuales para simular múltiples máquinas junto con como lanzar un servicio en el &lt;em>cluster&lt;/em> que en este caso consistirá en un servidor web nginx.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>En &lt;a href="https://picodotdev.github.io/blog-bitix/series/docker/">artículos anteriores de la serie sobre Docker&lt;/a> comentaba varias de las herramientas de &lt;a href="https://www.docker.com/">Docker&lt;/a> como &lt;a href="https://docs.docker.com/compose/">Docker Compose&lt;/a>, Dockerfile o &lt;a href="https://docs.docker.com/machine/">Docker Machine&lt;/a> con ejemplos de como usarlo en local. Una de las herramientas que me quedaba por investigar era &lt;a href="https://docs.docker.com/swarm/">Docker Swarm&lt;/a> para crear &lt;em>clusters&lt;/em> de nodos para contenedores Docker en un entorno de producción. A partir de la versión 1.12 de Docker se han incorporado varias características a Docker para usaar contenedores de forma distribuida y que a pesar de la complejidad subjacente que debe haber es realmente simple usarlo.&lt;/p>
&lt;p>Una de las características es el &lt;em>networking&lt;/em> que hace trasnparente la comunicación en red distribuida que se hace entre los nodos y los contenedores de esos nodos. Además permite crear redes por software para que los contenedores conectados a esas redes se comuniquen de forma privada. Otra característica interesante de Docker Swarm es que se encarga de monitorizar el estado de los servicios recreando contendores si alguno deja de funcionar. También a través del denominado &lt;em>routing mesh&lt;/em> da igual al nodo del &lt;em>cluster&lt;/em> por el que se acceda y da igual en que nodo esté el contenedor que Docker Swarm con esta propiedad se encargará de hacer llegar la petición al contenedor. Además, a lo que en Docker Swarm se denomina servicio se realiza balanceo de carga entre la instancias del mismo que haya en el &lt;em>cluster&lt;/em> y al servicio se le asigna un DNS y dirección IP por el que puede ser accedido por otros servicios.&lt;/p>
&lt;p>En el siguiente ejemplo para crear el &lt;em>cluster&lt;/em> de nodos Docker usaré Docker Machine para crear las máquinas de los nodos en máquinas virtuales de &lt;a href="https://www.virtualbox.org/">VirtualBox&lt;/a> aunque su funcionamiento es similar si usásemos la nube de &lt;a href="http://aws.amazon.com/es/ec2/">Amazon EC2&lt;/a>, &lt;a href="https://www.digitalocean.com/">Digital Ocean&lt;/a> u otros.&lt;/p>
&lt;p>El siguiente &lt;em>script&lt;/em> crea primeramente varios nodos cada uno en una máquina virtual, luego establece el nodo 01 como &lt;em>manager&lt;/em> y los nodos 02 y 03 como &lt;em>workers&lt;/em> usando un &lt;em>token&lt;/em> para unirlos al &lt;em>cluster&lt;/em> según su rol. Los nodos &lt;em>manager&lt;/em> se encargan de mantener el estado del &lt;em>cluster&lt;/em> y los que a través de ellos los comandos de los servicios deben ser lanzados, en un entorno de producción posiblemente tendríamos 3 nodos &lt;em>manager&lt;/em> para soportar tolerancia a fallos. Finalmente, se obtiene lista los nodos del &lt;em>cluster&lt;/em>. El comando &lt;code>docker-machine env node-01&lt;/code> permite establecer el entorno contra el que el comando &lt;code>docker&lt;/code> lanzará las operaciones como si de la máquina local se tratase.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="k">for&lt;/span> i in &lt;span class="s2">&amp;#34;01&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;02&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;03&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
docker-machine create -d virtualbox node-&lt;span class="nv">$i&lt;/span>
&lt;span class="k">done&lt;/span>
&lt;span class="nv">MANAGER_IP&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>docker-machine ip node-01&lt;span class="k">)&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
docker swarm init --advertise-addr &lt;span class="nv">$MANAGER_IP&lt;/span>
&lt;span class="nv">MANAGER_TOKEN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>docker swarm join-token -q manager&lt;span class="k">)&lt;/span>
&lt;span class="nv">WORKER_TOKEN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>docker swarm join-token -q worker&lt;span class="k">)&lt;/span>
&lt;span class="k">for&lt;/span> i in &lt;span class="s2">&amp;#34;02&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;03&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="k">do&lt;/span>
&lt;span class="nv">WORKER_IP&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>docker-machine ip node-&lt;span class="nv">$i&lt;/span>&lt;span class="k">)&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-&lt;span class="nv">$i&lt;/span>&lt;span class="k">)&lt;/span>
docker swarm join --token &lt;span class="nv">$WORKER_TOKEN&lt;/span> --advertise-addr &lt;span class="nv">$WORKER_IP&lt;/span> &lt;span class="nv">$MANAGER_IP&lt;/span>:2377
&lt;span class="k">done&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
docker-machine ls
docker node ls&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/01-cluster-create.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/01-cluster-create.sh" target="_blank">01-cluster-create.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Una vez creado los nodos es cuando podemos empezar a crear servicios en el &lt;em>cluster&lt;/em>. Los servicios son una definición de los contenedores de Docker que queremos que el &lt;em>cluster&lt;/em> ejecute. En el ejemplo definiré el servicio de un servidor web &lt;a href="https://nginx.org/">nginx&lt;/a>, primeramente crearé una red por software en el &lt;em>cluster&lt;/em> a la que los servicios pueden conectarse que en el ejemplo (aunque para este no es necesario) utilizaré para hacer una consulta DNS con la herramienta &lt;a href="https://linux.die.net/man/1/drill">drill&lt;/a> para ver el nombre de dominio y dirección IP que asigna Docker Swarm al servicio del servidor web. Con &lt;em>docker service create&lt;/em> se crean los servicios, algunos de los parámetros del comando son el nombre del servicio que queremos asignarle, los puertos que expone en este caso el 80 y 443 en el &lt;em>host&lt;/em> para que sea accesible desde fuera del &lt;em>cluster&lt;/em>, la redes a las que está conectado y finalmente la imagen del contenedor del servicio que en este caso será la versión de &lt;a href="https://hub.docker.com/_/nginx/">nginx con Alpine para Docker&lt;/a>. Se pueden listar los servicios que contiene el &lt;em>cluster&lt;/em> con &lt;em>docker service ls&lt;/em> y los procesos de cada nodo donde podemos ver en que nodos se está ejecutando los contenedores con &lt;em>docker ps&lt;/em>.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
docker network create --driver overlay nginx
docker network ls -f &lt;span class="s2">&amp;#34;driver=overlay&amp;#34;&lt;/span>
docker service create --name nginx -p 80:80 -p 443:443 --network nginx nginx:stable-alpine
sleep 1m
docker service create --name util --network nginx --mode global alpine sleep &lt;span class="m">1000000000&lt;/span>
sleep 1m
docker service ls
docker service ps nginx
docker service ps util
&lt;span class="nv">UTIL_CONTAINER_ID&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>docker ps -q --filter &lt;span class="nv">label&lt;/span>&lt;span class="o">=&lt;/span>com.docker.swarm.service.name&lt;span class="o">=&lt;/span>util&lt;span class="k">)&lt;/span>
docker &lt;span class="nb">exec&lt;/span> -it &lt;span class="nv">$UTIL_CONTAINER_ID&lt;/span> apk add --update drill
docker &lt;span class="nb">exec&lt;/span> -it &lt;span class="nv">$UTIL_CONTAINER_ID&lt;/span> drill nginx
docker service rm util
sleep 5s
&lt;span class="k">for&lt;/span> i in &lt;span class="s2">&amp;#34;01&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;02&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;03&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-&lt;span class="nv">$i&lt;/span>&lt;span class="k">)&lt;/span>
docker ps
&lt;span class="k">done&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
&lt;span class="k">for&lt;/span> i in &lt;span class="s2">&amp;#34;01&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;02&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;03&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="nv">NODE_IP&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>docker-machine ip node-&lt;span class="nv">$i&lt;/span>&lt;span class="k">)&lt;/span>
curl http://&lt;span class="nv">$NODE_IP&lt;/span>/
&lt;span class="k">done&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/06-nginx-create.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/06-nginx-create.sh" target="_blank">06-nginx-create.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Una de las propiedades interesantes del &lt;em>networking&lt;/em> de Docker Swarm es que ofrece incorporado balanceo de carga, esto es, si el servicio de nginx del ejemplo estuviese formado por dos instancias las peticiones se distribuirían entre las instancias usando el método &lt;em>round-robin&lt;/em>. Otra característica interesante si se observa el ejemplo con detalle es que da igual el nodo al que hagamos la petición que la respuesta se obtendrá igualmente, esto es, aunque la petición se haga al nodo 01 y realmente el contenedor del servidor nginx se esté ejecutando en el nodo 02 la petición se realizará correctamente gracias al &lt;em>routing mesh&lt;/em> del &lt;em>neworking&lt;/em> de Docker Swarm, esto es gracias a que cada servicio tiene asignada una dirección IP, como se ha visto anteriormente en la salida del comando &lt;code>drill&lt;/code>.&lt;/p>
&lt;p>En este vídeo de &lt;a href="https://asciinema.org/">asciinema&lt;/a> se ve en funcionamiento todos los anteriores comandos. Y en la aplicación de VirtualBox estarán las máquinas virtuales de cada uno de los nodos que crea el ejemplo. En el vídeo se aprecia que el servicio de nginx se está ejecutando en el nodo 02 cuando se listan los procesos de Docker de cada nodo con &lt;em>docker ps&lt;/em>, nótese sin embargo que al hacer un petición HTTP a cualquiera de los nodos se devuelve la página de inicio de nginx ya que gracias al &lt;em>routing mesh&lt;/em> de Docker Swarm la petición se redirige de forma transparente para el cliente y el servicio al nodo donde realmente se está ejecutando el contenedor de nginx.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;script type="text/javascript" src="https://asciinema.org/a/107868.js" id="asciicast-107868" async>&lt;/script>
&lt;noscript>&lt;a href="https://asciinema.org/a/107868" target="_blank">&lt;img src="https://asciinema.org/a/107868.png" width="734"/>&lt;/a>&lt;/noscript>
&lt;figcaption>Introducción y ejemplo de cluster de contenedores con Docker Swarm&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/images/maquinas-virtuales-cluster.png" title="Máquinas virtuales de los nodos del _cluster_ de Docker Swarm" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/images/maquinas-virtuales-cluster-thumb.png" width="288"/>&lt;/a>
&lt;figcaption>Máquinas virtuales de los nodos del cluster de Docker Swarm&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Los comandos para eliminar un servicio del &lt;em>cluster&lt;/em> y eliminar completamente el &lt;em>cluster&lt;/em> son los siguientes.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="k">$(&lt;/span>docker-machine env node-01&lt;span class="k">)&lt;/span>
docker service rm nginx
docker network rm nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/nginx-remove.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/nginx-remove.sh" target="_blank">nginx-remove.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">#export MACHINE_STORAGE_PATH=&amp;#34;/run/media/picodotdev/BMOVE ROJO/docker-machine/&amp;#34;&lt;/span>
&lt;span class="k">for&lt;/span> i in &lt;span class="s2">&amp;#34;01&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;02&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;03&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
docker-machine rm -f node-&lt;span class="nv">$i&lt;/span>
&lt;span class="k">done&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/cluster-remove.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/cluster-remove.sh" target="_blank">cluster-remove.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Un libro que me ha gustado mucho y que recomiendo leer sobre Docker Swarm es &lt;a href="https://amzn.to/2mIirti">The Devops 2.1 Toolkit&lt;/a> que lo explica detalladamente y todo el libro está orientado a como usarlo en un entorno de producción. Un libro más introductorio que también he leído y que está bastante bien es &lt;a href="https://amzn.to/2mF3Xtj">Docker in Action&lt;/a>.&lt;/p>
&lt;div class="media-amazon" style="text-align: center;">
&lt;iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=a6c4acab72c208d29232f2e0a8edb8ee">&lt;/iframe>
&lt;iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1542468914&amp;linkId=2101ae950cfcfe9e69b6cc1210e4bf2c">&lt;/iframe>
&lt;/div>
&lt;p>Finalmente, quizás si estás usando GNU/Linux y VirtualBox como yo al crear los nodos con el comando &lt;code>docker-machine&lt;/code> te produzca el siguiente error (quizá se corrija en futuras versiones de Docker o VirtualBox).&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">Setting Docker configuration on the remote daemon...
This machine has been allocated an IP address, but Docker Machine could not
reach it successfully.
SSH for the machine should still work, but connecting to exposed ports, such as
the Docker daemon port (usually &amp;lt;ip&amp;gt;:2376), may not work properly.
You may need to add the route manually, or use another related workaround.
This could be due to a VPN, proxy, or host file configuration issue.
You also might want to clear any VirtualBox host only interfaces you are not using.
Checking connection to Docker...
Error creating machine: Error checking the host: Error checking and/or regenerating the certs: There was an error validating certificates for host &amp;#34;192.168.99.100:2376&amp;#34;: dial tcp 192.168.99.100:2376: i/o timeout
You can attempt to regenerate them using &amp;#39;docker-machine regenerate-certs [name]&amp;#39;.
Be advised that this will trigger a Docker daemon restart which might stop running containers.&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/vboxnet0-error.out" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/vboxnet0-error.out" target="_blank">vboxnet0-error.out&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>La solución que he encontrado para que funcione es asignar una dirección IP al adaptador puente solo-anfitrión y levantar la interfaz que usa Docker para comunicarse con las máquinas virtuales previamente a crear el nodo. En &lt;a href="https://www.archlinux.org/">Arch Linux&lt;/a> con los siguientes comandos.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>
sudo ip addr add 192.168.99.1/24 dev vboxnet0
sudo ip link &lt;span class="nb">set&lt;/span> dev vboxnet0 up&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/01-vboxnet0-configure.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/code/01-vboxnet0-configure.sh" target="_blank">01-vboxnet0-configure.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Se puede definir un conjunto de servicios como una unidad en un archivo en &lt;em>stacks&lt;/em> de forma similar a como es posible hacer con Docker Compose cosa que mostraré en otro artículo.&lt;/p>
&lt;p>
El &lt;a href="https://github.com/picodotdev/blog-ejemplos/tree/master/DockerSwarm">código fuente completo del ejemplo&lt;/a> puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href="https://github.com/">GitHub&lt;/a>.
&lt;/p></content><category term="gnu-linux"/><category term="planeta-codigo"/><category term="planeta-linux"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/</id><title>Cambiar la ruta raíz del entorno de Docker</title><updated>2015-11-14T12:00:00+02:00</updated><published>2015-07-24T20:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Cambiando la ruta raíz del entorno de ejecución de docker, dónde guarda las imágenes de los contenedores, los datos de los contenedores y otros metadatos, podemos almacenar esta información en un disco duro externo o memoria USB.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>Por defecto el directorio donde se guardan las imágenes y los contenedores junto con otros metadatos de &lt;a href="https://www.docker.com/">Docker&lt;/a> es &lt;em>/var/lib/docker&lt;/em>. En mi caso hace un tiempo me compre un &lt;a href="https://picodotdev.github.io/blog-bitix/2014/03/desempaquetado-y-analisis-samsung-840-evo-ssd-250-gb/">disco de estado sólido Samsung 840 EVO de 250 GiB&lt;/a> y comenté en el artículo del anterior enlace. Aunque probablemente un disco SSD sea suficientemente fiable como para que antes de que falle cambiémos de ordenador porque ya es antiguo, yo trato de evitar hacer muchas escrituras al disco. Al trabajar con Docker ya sea descargando imágenes, &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/">construyendo imágenes propias con archivos Dockerfile&lt;/a> y al arrancar contenedores cuyos procesos escriben en disco prefiero externalizar esas escrituras en una unidad USB ya sea un pendrive o un disco duro. En este artículo comentaré como modificar Docker para que las imágenes y los contenedores estén almacenados en una memoria USB o en otra localización de la por defecto.&lt;/p>
&lt;p>En Arch Linux el proceso de docker se arranca con un servicio de systemd:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ sudo systemctl start docker.service
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/code/docker-start.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/code/docker-start.sh" target="_blank">docker-start.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>En la definición del servicio de docker se establecen los parámetros de inicio del demonio de docker y deberemos cambiarlo para cambiar la localización de las imágenes y contenedores. En la información de ayuda del comando de docker podemos ver que si queremos cambiar la localización por defecto de las imágenes y contenedores de docker debemos emplear la opción &lt;em>-g &amp;ldquo;/var/lib/docker&amp;rdquo;&lt;/em>.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker --help
Usage: docker &lt;span class="o">[&lt;/span>OPTIONS&lt;span class="o">]&lt;/span> COMMAND &lt;span class="o">[&lt;/span>arg...&lt;span class="o">]&lt;/span>
A self-sufficient runtime &lt;span class="k">for&lt;/span> linux containers.
...
-g, --graph&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/var/lib/docker&amp;#34;&lt;/span> Path to use as the root of the Docker runtime
...&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/code/docker-help.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/code/docker-help.sh" target="_blank">docker-help.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>En Arch Linux el servicio de systemd de docker se guarda en &lt;em>/usr/lib/systemd/system/docker.service&lt;/em>. Modificando el parámetro &lt;em>ExecStart&lt;/em> de la sección &lt;em>[Service]&lt;/em> para añadir el parámetro &lt;em>-g&lt;/em> nos quedaría algo como:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-systemd" data-lang="systemd">&lt;span class="k">[Unit]&lt;/span>
&lt;span class="na">Description&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">Docker Application Container Engine&lt;/span>
&lt;span class="na">Documentation&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">http://docs.docker.com&lt;/span>
&lt;span class="na">After&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">network.target docker.socket&lt;/span>
&lt;span class="na">Requires&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">docker.socket&lt;/span>
&lt;span class="k">[Service]&lt;/span>
&lt;span class="na">ExecStart&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">/usr/bin/docker -d -H fd:// -g /run/media/picodotdev/BMOVE_ROJO/docker/root&lt;/span>
&lt;span class="na">MountFlags&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">slave&lt;/span>
&lt;span class="na">LimitNOFILE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">1048576&lt;/span>
&lt;span class="na">LimitNPROC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">1048576&lt;/span>
&lt;span class="k">[Install]&lt;/span>
&lt;span class="na">WantedBy&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">multi-user.target&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/code/docker.service" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/code/docker.service" target="_blank">docker.service&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Iniciando ahora el servicio de Docker veremos que en el directorio que hayamos elegido se crean los metadatos y si hacemos un &lt;em>pull&lt;/em> de una imagen se guardará en esta localización.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/images/docker-root.png" title="Directorio raíz de docker" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/images/docker-root.png" width="647"/>&lt;/a>
&lt;figcaption>Directorio raíz de docker&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;div class="alert alert-warning">
&lt;p>Cada vez que se actualice el paquete de docker el archivo del servicio de systemd se sobreescribirá y perderemos la configuración, de modo que en cada actualización de docker deberemos realizar de nuevo la modificación.&lt;/p>
&lt;/div>
&lt;p>Este artículo es uno de otros que he publicado, en otros artículos he escrito sobre otras cosas relacionadas con docker.&lt;/p></content><category term="gnu-linux"/><category term="planeta-codigo"/><category term="planeta-linux"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/</id><title>Usar docker con Docker Machine en Linux, Windows o Mac</title><updated>2015-07-18T21:00:00+02:00</updated><published>2015-07-18T12:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Aunque no usemos Linux podemos hacer uso de docker a través de una máquina virtual de VirtualBox y con Docker Machine. Docker Machine permite crear un sistema con la misión de albergar contenedores de docker, puede ser en VirtualBox pero también en Amazon EC2 o Digital Ocean además de otras muchas opciones.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>&lt;a href="https://www.docker.com/">Docker&lt;/a> ha dejado de ser únicamente una tecnología de contenedores formando un ecosistema alrededor de docker más completo, &lt;a href="https://docs.docker.com/compose/">Docker Compose&lt;/a> que permite &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/">definir un grupo de contenedores en un archivo&lt;/a>, por supuesto parte importante de este ecosistema es &lt;a href="https://registry.hub.docker.com/">Docker Hub&lt;/a> para &lt;a href="https://picodotdev.github.io/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/">compartir imágenes de contenedores&lt;/a> y &lt;a href="https://docs.docker.com/swarm/">Docker Swarm&lt;/a> que permite formar un &lt;em>cluster&lt;/em> de máquinas. En este artículo comentaré cómo usar &lt;a href="https://docs.docker.com/machine/">Docker Machine&lt;/a> y dejaré para un futuro &lt;a href="https://docs.docker.com/swarm/">Docker Swarm&lt;/a> (ya que por el momento las pruebas que he hecho no han sido exitosas).&lt;/p>
&lt;p>Antes de nada decir que tanto Docker Machine en el momento de escribir este artículo están en las fases iniciales de desarrollo y pueden cambiar significativamente antes de lanzar una versión 1.0, ahora Docker Machine está en las version 0.3.0. La combinación de Docker Machine y Docker Swarm en algunos puntos son parecidos a los que se ofrecen en &lt;a href="https://coreos.com/">CoreOS&lt;/a>.&lt;/p>
&lt;p>Si has usado &lt;a href="https://www.vagrantup.com/">Vagrant&lt;/a> te resultará Docker Machine muy similar ya que permite crear máquinas virtuales en diferentes proveedores en una máquina anfitrión con &lt;a href="https://www.virtualbox.org/">VirtualBox&lt;/a> hasta &lt;a href="http://aws.amazon.com/es/ec2/">Amazon EC2&lt;/a> o &lt;a href="https://www.digitalocean.com/">Digital Ocean&lt;/a>, la &lt;a href="https://docs.docker.com/machine/#drivers">lista de controladores soportados&lt;/a> es bastante amplia. Estas máquinas que creamos con Docker Machine están destinadas como único objetivo a albergar contenedores docker usando el sistema operativo &lt;a href="http://boot2docker.io/">boot2docker&lt;/a>.&lt;/p>
&lt;p>Para usar Docker Machine debemos &lt;a href="https://github.com/docker/machine/releases">descargar el binario&lt;/a>, darle permisos de ejecución y si queremos añadirlo a la variable &lt;em>PATH&lt;/em> del sistema.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker-machine --version
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/code/docker-machine-version.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/code/docker-machine-version.sh" target="_blank">docker-machine-version.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Con los siguientes comandos podemos crear una máquina virtual para los contenedores docker, listar las máquinas virtuales creadas, hacer SSH a ella, ejecutar un contenedor en ella, parala y eliminar una máquina virtual además de obtener la &lt;em>IP&lt;/em> asignada.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker-machine create --driver virtualbox dev
$ docker-machine ls&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/code/docker-machine-create.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/code/docker-machine-create.sh" target="_blank">docker-machine-create.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Estableciendo las variables de entorno de la máquina virtual podemos usar el comando docker como si de la máquina anfitrión fuera, todos los comandos de docker que lancemos se ejecutarán contra el contenedor docker de la máquina virtual. En el siguiente caso se ejecuta el contenedor de &lt;em>busybox&lt;/em> en la máquina virtual &lt;em>dev&lt;/em>. Con &lt;em>&amp;ndash;unset&lt;/em> podemos reiniciar la configuración a la máquina anfitrión.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker-machine env dev
$ &lt;span class="nb">eval&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>docker-machine env dev&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
$ docker run busybox &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;hello world&amp;#34;&lt;/span>
$ &lt;span class="nb">eval&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>docker-machine env --unset&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/code/docker-machine-run.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/code/docker-machine-run.sh" target="_blank">docker-machine-run.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Podemos detener, volver a iniciar, hacer SSH y eliminar la máquina virtual con:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker-machine start dev
$ docker-machine ssh dev
$ docker-machine stop dev
$ docker-machine rm dev&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/code/docker-machine-manage.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/code/docker-machine-manage.sh" target="_blank">docker-machine-manage.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;script type="text/javascript" src="https://asciinema.org/a/23600.js" id="asciicast-23600" async>&lt;/script>
&lt;noscript>&lt;a href="https://asciinema.org/a/23600" target="_blank">&lt;img src="https://asciinema.org/a/23600.png" width="734"/>&lt;/a>&lt;/noscript>
&lt;figcaption>Comandos y uso de Docker Machine en una máquina virtual&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>El directorio por defecto donde se guardarán los archivos de las máquinas virtuales es &lt;em>~/.docker/machine&lt;/em>, si queremos cambiarlo podemos utilizar el parámetro &lt;em>&amp;ndash;storage-path&lt;/em> en cada uno de los comandos anteriores de la siguiente forma, el orden de los parámetros es importante:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker-machine --storage-path &lt;span class="s2">&amp;#34;/run/media/picodotdev/BMOVE_ROJO/docker/machine&amp;#34;&lt;/span> create --driver virtualbox dev
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/code/docker-machine-storage-path.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/code/docker-machine-storage-path.sh" target="_blank">docker-machine-storage-path.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>En el administrador de VirtualBox veremos que se ha creado la máquina virtual &lt;em>dev&lt;/em> además de poder cambiar la configuración de memoria y otros parámetros de la máquina virtual.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/images/virtualbox.png" title="Máquina de Docker Machine ne VirtualBox" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/images/virtualbox-thumb.png" width="639"/>&lt;/a>
&lt;figcaption>Máquina de Docker Machine en VirtualBox&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Dado que los contenedores se ejecutan en una máquina virtual de VirtualBox y VirtualBox está disponible en Windows y Mac OS además del binario de Docker Machine para estas plataformas podemos usar docker en cualquiera de estos. Aunque no sea de forma nativa como en Linux para un entorno de desarrollo donde las personas trabajan con cualquiera de estos sistemas operativos puede sernos de utilidad.&lt;/p>
&lt;p>Como nota final diré que después de crear una máquina virtual las siguientes veces al crear una nueva Docker Machine se me quedaba indefinidamente en el mensaje &lt;em>Starting VM&amp;hellip;&lt;/em>, algún problema con Docker Machine o VirtualBox que en una futura versión podría solucionarse, la única forma de resolverlo que se es reiniciando el ordenador pero seguro que hay alguna mejor.&lt;/p>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="https://docs.docker.com/machine/">Docker Machine&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-codigo"/><category term="planeta-linux"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/</id><title>Crear y usar un repositorio en Docker Hub</title><updated>2015-07-11T01:00:00+02:00</updated><published>2015-07-10T20:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>¿Por qué se habla tanto de Docker y despierta tanto interes si la tecnología ya existía desde hace tiempo tanto en otros sistemas operativos como en Linux? Uno de los éxitos que ha contribuido a ellos es Docker Hub, un repositorio de imágenes en el que cualquiera puede contribuir con las suyas. Esto hace que pueda encontrarse cualquier herramienta de las populares y empezar a usarlas en muy pocos minutos.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>Probablemente uno de los éxitos de Docker más que la propia tecnología de contenedores sea &lt;a href="https://registry.hub.docker.com/">Docker Hub&lt;/a> que permite a los usuarios compartir las imágenes construidas, se podría decir que es el &lt;a href="https://github.com/">GitHub&lt;/a> de los contenedores docker y quizá por ello el paralelismo en el nombre entre ambos. Docker Hub permite subir imágenes o usar las imágenes oficiales de &lt;a href="https://www.postgresql.org/">postgresql&lt;/a>, &lt;a href="https://redis.io/">redis&lt;/a>, &lt;a href="https://www.mysql.com/">mysql&lt;/a>, &lt;a href="https://www.ubuntu.com/">ubuntu&lt;/a>, &lt;a href="https://www.rabbitmq.com/">rabbitmq&lt;/a>, &amp;hellip; y otra &lt;a href="https://registry.hub.docker.com/">multitud de proyectos&lt;/a>.&lt;/p>
&lt;p>El &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/">archivo Dockerfile con el que construimos una imagen&lt;/a> podemos hospedarlo en un repositorio de GitHub y que Docker Hub lo obtenga para construir la imagen. Docker Hub ofrece repositorios públicos en los que colocar las imágenes que cualquier otro usuario puede acceder y usar o repositorios privados con cierto coste según el número de repositorios privados, el primer repositorio privado es gratuito.&lt;/p>
&lt;h3 id="otros-artículos-sobre-docker">Otros artículos sobre Docker&lt;/h3>
&lt;p>Este artículo forma parte de otros artículos sobre Docker que ya he escrito si quieres empezar por el principio puedes leer primero la &lt;a href="https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/">Introducción y características sobre Docker&lt;/a>, el &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/">Inicio básico de Docker&lt;/a>, &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/">Como crear una imagen con un Dockerfile&lt;/a> o &lt;a href="https://picodotdev.github.io/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/">Como usar docker con Docker Compose&lt;/a>. En siguientes artículos hablaré de otras herramientas como Docker Machine y Docker Swarm.&lt;/p>
&lt;p>A continuación explicaré como crear un repositorio en Docker Hub que obtenga los Dockerfile de un repositorio de GitHub y construya las imágenes de los Dockerfile de forma automática cuando haya cambios en los archivos dockerfile de GitHub.&lt;/p>
&lt;h3 id="crear-una-cuenta-en-docker-hub">Crear una cuenta en Docker Hub&lt;/h3>
&lt;p>Primero necesitaremos crear una cuenta en Docker Hub. El nombre de usuario determinará el nombre de las imágenes, siendo mi nombre de usuario &lt;em>picodotdev&lt;/em> al usar las imágenes debería usar:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker run picodotdev/dockerhub-postgres:9.4
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/code/docker-run.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/code/docker-run.sh" target="_blank">docker-run.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/images/dockerhub.png" title="Docker Hub" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/images/dockerhub-thumb.png" width="604"/>&lt;/a>
&lt;figcaption>Docker Hub&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;h3 id="subir-el-archivo-dockerfile-a-un-repositorio-de-github">Subir el archivo Dockerfile a un repositorio de GitHub&lt;/h3>
&lt;p>Posteriormente deberemos crear un repositorio en GitHub para alojar los archivos Dockerfile que usará Docker Hub para construir las imágenes de Docker. En el ejemplo usaré el &lt;a href="https://github.com/picodotdev/blog-ejemplos/tree/master/DockerHub">repositorio blog-ejemplos&lt;/a> y dentro de este los dockerfiles los he &lt;a href="https://github.com/picodotdev/blog-ejemplos/tree/master/DockerHub/postgres/9.4">ubicado dentro de una carpeta&lt;/a>.&lt;/p>
&lt;p>Una vez que tenemos el repositorio de GitHub subimos un &lt;a href="https://github.com/picodotdev/blog-ejemplos/blob/master/DockerHub/postgres/9.4/Dockerfile">Dockerfile para el ejemplo&lt;/a>, usaré el proporcionado de forma &lt;a href="https://registry.hub.docker.com/_/postgres/">oficial de posgresql&lt;/a>, y creamos en Docker Hub una &lt;em>build&lt;/em> automatizada, se nos solicitará permisos en la cuenta de GitHub para que Docker Hub pueda acceder a nuestros repositorios.&lt;/p>
&lt;h3 id="crear-el-repositorio-en-dockerhub-y-la-build-automática">Crear el repositorio en DockerHub y la &lt;em>build&lt;/em> automática&lt;/h3>
&lt;p>En la creación del repositorio en Docker Hub con &lt;em>build&lt;/em> automatizada seleccionamos el repositorio de GitHub que contiene los repositorios y el archivo DockerFile para el que queremos hacer la build automatizada. Le asignamos un nombre al repositorio y un &lt;em>tag&lt;/em> a la &lt;em>build&lt;/em> que podremos usar al hacer el &lt;em>pull&lt;/em> de la imagen.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/images/dockerhub-automated-build.png" title="Docker Hub" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/images/dockerhub-automated-build-thumb.png" width="650"/>&lt;/a>
&lt;figcaption>Build automatizada de Docker Hub&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Docker Hub se encargará de obtener el archivo Dockerfile y construir la imagen, en el proceso podremos ver las trazas generadas.&lt;/p>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="https://docs.docker.com/userguide/dockerrepos/">Get started with Docker Hub&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://docs.docker.com/docker-hub/builds/#the-dockerfile-and-automated-builds">The Dockerfile and Automated Builds&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-codigo"/><category term="planeta-linux"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/</id><title>Aplicaciones multicontenedor con Docker Compose</title><updated>2015-07-18T21:00:00+02:00</updated><published>2015-07-03T16:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Continuando la serie de artículos sobre Docker, otra de las herramientas disponibles en el ecosistema y que nos facilitará enormemente el administrar aplicaciones compuestas por varios contenedores relacionados entre sí es Docker Compose. Definiendo en un archivo los contenedores que forman parte de una aplicación podemos iniciarlos, pararlos, eliminarlos o ver su estado como si de una unidad se tratara.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>Una vez que ya sabemos que nos puede proporcionar una de las herramientas de la que más se está hablando con la &lt;a href="https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/">introducción a docker&lt;/a>, conocemos &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/">como empezar a usar docker&lt;/a> y sabemos &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/">cómo crear nuestras propias imágenes de docker&lt;/a> para los propósitos específicos que necesitemos nos resultará interesante algunas de las nuevas herramientas que proporciona docker. El ecosistema de docker ya no solo se compone del entorno de ejecución de los contenedores, explicadas de forma básica son:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.docker.com/">Docker&lt;/a>: el sistema de contenedores (&lt;em>runtime&lt;/em>, imágenes, &amp;hellip;).&lt;/li>
&lt;li>&lt;a href="https://registry.hub.docker.com/">Docker Hub&lt;/a>: el repositorio de imágenes que las diferentes herramientas de forma oficial o a través de usuarios construyen y comparten imágenes que cualquiera puede usar.&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/compose/">Docker Compose&lt;/a>: permite describir un conjunto de contenedores que se relacionan entre ellos.&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/machine/">Docker Machine&lt;/a>: permite construir máquinas virtuales para alojar contenedores. Similar a lo que hace &lt;a href="https://www.vagrantup.com/">Vagrant&lt;/a>, al igual que el anterior también permite construir máquinas que ejecuten contenedores con &lt;a href="https://www.virtualbox.org/">VirtualBox&lt;/a> o diferentes sistemas de computación en en la nube como &lt;a href="http://aws.amazon.com/es/ec2/">Amazon EC2&lt;/a>, &lt;a href="https://www.digitalocean.com/">Digital Ocean&lt;/a> u otros. Docker Machine puede ser la forma de usar docker en Windows o Mac OS hasta que funcione de forma nativa como en GNU/Linux.&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/swarm/">Docker Swarm&lt;/a>: permite construir un &lt;em>cluster&lt;/em> de máquinas al que se puede enviar contenedores docker para su ejecución.&lt;/li>
&lt;/ul>
&lt;p>Continuando la &lt;a href="https://picodotdev.github.io/blog-bitix/series/docker/">serie de artículos sobre docker&lt;/a> que escribí hace unos meses escribiré sobre cada una de estas nuevas herramientas, empezando en este artículo con Docker Compose en el que explicaré de qué forma nos puede servir, como instalarlo y el descriptor de contenedores con un ejemplo.&lt;/p>
&lt;h3 id="introducción-a-docker-compose">Introducción a Docker Compose&lt;/h3>
&lt;p>Las aplicaciones basadas en microservicios se prestan a usar múltiples contenedores cada uno con un servicio, uno puede contener la base de datos &lt;a href="https://www.postgresql.org/">postgresql&lt;/a>, otro una base de datos clave/valor &lt;a href="https://redis.io/">redis&lt;/a> o de documentos como &lt;a href="https://www.elastic.co/products/elasticsearch/">elasticsearch&lt;/a> para hacer búsquedas, otro un sistema de mensajería como &lt;a href="https://www.rabbitmq.com/">rabbitmq&lt;/a>, otro &lt;a href="https://tomcat.apache.org/">tomcat&lt;/a> o &lt;a href="https://wildfly.org/">wildfly&lt;/a> que use los anteriores y un servidor web como &lt;a href="https://nginx.org/">Nginx&lt;/a>. Teniendo múltiples contenedores usar el comando &lt;code>docker run&lt;/code> para cada uno de ellos nos resultará incómodo. En este punto entra Docker Compose permitiéndonos definir nuestra aplicación multicontenedor en un archivo con las mismas propiedades que indicaríamos con el comando &lt;code>docker run&lt;/code> individualmente. Con un único comando podremos iniciar todos los contenedores y en el orden que los especifiquemos.&lt;/p>
&lt;p>El archivo descriptor nos puede servir no solo como forma de iniciar los contenedores en un entorno de desarrollo sino como de documentación de la aplicación en la que veremos qué contenedores, imágenes, volúmenes, enlaces y demás propiedades tienen.&lt;/p>
&lt;h3 id="instalar-docker-compose">Instalar Docker Compose&lt;/h3>
&lt;p>Tenemos varias formas de instalar Docker Compose. La que más me gusta y la que recomiendo por ser sencilla es &lt;a href="https://github.com/docker/compose/releases">descargar el binario de docker compose&lt;/a> según nuestra plataforma GNU/Linux o Mac. Descargando el binario de Docker Compose deberemos darle permisos de ejecución y si nos interesa colocarlo en la variable de entorno &lt;em>PATH&lt;/em> del sistema:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ chmod +x docker-compose&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/code/permisos.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/code/permisos.sh" target="_blank">permisos.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">PATH=$PATH:~/Software/scripts/docker-compose
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/code/bashrc" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/code/bashrc" target="_blank">bashrc&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Con el siguiente comando veremos que Docker Compose funciona correctamente y la versión del mismo.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker-compose --version
docker-compose version: 1.3.1
CPython version: 2.7.9
OpenSSL version: OpenSSL 1.0.1e &lt;span class="m">11&lt;/span> Feb &lt;span class="m">2013&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/code/docker-compose-version.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/code/docker-compose-version.sh" target="_blank">docker-compose-version.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;h3 id="el-descriptor-de-contenedores">El descriptor de contenedores&lt;/h3>
&lt;p>El descriptor de los contenedores a usar con Docker Compose es un archivo de texto con &lt;a href="https://www.yaml.org/">formato yaml&lt;/a> en la que especificamos los diferentes contenedores y sus propiedades, básicamente podemos indicar las mismas propiedades que indicamos arrancando los contenedores individualmente con el comando &lt;code>docker run&lt;/code>. En el siguiente ejemplo vemos varios contenedores, dos contenedores de datos para redis y postgresql, los contenedores de redis y postgresql y un contenedor para la aplicación usando tomcat enlazado con los contenedores de redis y postgresql definidos previamente.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-YAML" data-lang="YAML">redisdb&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>busybox&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>volumes&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>/var/lib/redis&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>postgresqldb&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>busybox&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>volumes&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>/var/lib/postgresql/data&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>redis&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>redis&lt;span class="p">:&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>volumes_from&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>redisdb&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>ports&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;6379:6379&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>postgresql&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>postgres&lt;span class="p">:&lt;/span>&lt;span class="m">9&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>volumes_from&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>postgresqldb&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>environment&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>POSTGRES_USER&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>posgresql&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>POSTGRES_PASSWORD&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>posgresql&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>ports&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;5432:5432&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>apps&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>library/tomcat&lt;span class="p">:&lt;/span>&lt;span class="m">8&lt;/span>-jre8&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>links&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>redis&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>postgresql&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>ports&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;8080:8080&amp;#34;&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/code/docker-compose.yml" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/code/docker-compose.yml" target="_blank">docker-compose.yml&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>La imagen de los contenedores se indica con la propiedad &lt;em>image&lt;/em>, los contenedores de datos, &lt;em>redisdb&lt;/em> y &lt;em>posgresqldb&lt;/em>, usan la propiedad &lt;em>volumes&lt;/em> con los datos que guardarán y la imagen de &lt;em>busybox&lt;/em> (se suele usar esta para los contenedores de datos porque es muy pequeña), con la propiedad &lt;em>hostname&lt;/em> podemos indicar el nombre de la máquina que al usar la propiedad &lt;em>link&lt;/em> docker hará visible al contenedor que los usen, con &lt;em>volumes_from&lt;/em> podemos usar volúmenes, con &lt;em>links&lt;/em> enlazar contenedores y con &lt;em>ports&lt;/em> asociar puertos entre los contenedores y la propia máquina anfitrión, en el ejemplo he usado los puertos por defecto de cada uno de los servicios.&lt;/p>
&lt;p>La &lt;a href="https://docs.docker.com/compose/yml/">descripción completa del formato del archivo de Docker Compose&lt;/a> nos da una idea de las opciones que podemos usar, está bastante bien explicado y con ejemplos que nos resultará sencillo entender conociendo los parámetros que usamos con &lt;em>docker run&lt;/em>.&lt;/p>
&lt;h3 id="iniciar-los-contenedores-con-docker-compose">Iniciar los contenedores con Docker Compose&lt;/h3>
&lt;p>Escrito el archivo de los contenedores y llamándolo &lt;em>docker-compose.yml&lt;/em> podemos iniciar los contenedores con el comando &lt;code>docker-compose up&lt;/code> estando en el mismo directorio de trabajo donde esté ubicado del archivo yml (y previamente habiendo iniciado el servicio de docker). Con &lt;em>docker-compose ps&lt;/em> podremos ver el estado de los contenedores y de cuales está compuesta la aplicación. Con la opción &lt;em>&amp;ndash;help&lt;/em> podemos ver la lista completa de comandos que podemos usar.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-YAML" data-lang="YAML">$&lt;span class="w"> &lt;/span>docker-compose&lt;span class="w"> &lt;/span>up&lt;span class="w"> &lt;/span>-d&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>$&lt;span class="w"> &lt;/span>docker-compose&lt;span class="w"> &lt;/span>ps&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>$&lt;span class="w"> &lt;/span>docker-compose&lt;span class="w"> &lt;/span>stop&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>$&lt;span class="w"> &lt;/span>docker-compose&lt;span class="w"> &lt;/span>restart&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>$&lt;span class="w"> &lt;/span>docker-compose&lt;span class="w"> &lt;/span>logs&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/code/docker-compose-up.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/code/docker-compose-up.sh" target="_blank">docker-compose-up.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/images/docker-compose.png" title="Docker Compose" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/images/docker-compose-thumb.png" width="650"/>&lt;/a>
&lt;figcaption>Docker Compose&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>docker-compose inicia los contenedores en el orden que hemos indicado en el archivo de definición, las trazas emitidas de los servicios de los contenedores aparecerán en la terminal si iniciamos los contenedores en primer plano y con &lt;em>Ctrl+C&lt;/em> se pararán los contenedores. Indicando la opción &lt;em>-d&lt;/em> los contenedores se iniciarán en segundo plano, con &lt;em>docker-compose stop&lt;/em> podremos pararlos, con &lt;em>docker-compose restart&lt;/em> reiniciarlos, &lt;em>docker-compose rm&lt;/em> para eliminar completamente los contenedores y con &lt;em>docker-compose logs&lt;/em> veremos las trazas emitidas por los servicios que nos serán de utilizar si iniciamos los contenedores en segundo plano.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;script type="text/javascript" src="https://asciinema.org/a/23602.js" id="asciicast-23602" async>&lt;/script>
&lt;noscript>&lt;a href="https://asciinema.org/a/23602" target="_blank">&lt;img src="https://asciinema.org/a/23602.png" width="734"/>&lt;/a>&lt;/noscript>
&lt;figcaption>Comandos básicos de Docker Compose&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;div class="media-amazon" style="text-align: center;">
&lt;iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=9d344246cd59cd65a952305379c2556a">&lt;/iframe>
&lt;/div>
&lt;p>En las siguientes semanas publicaré más artículos sobre esta serie de Docker comentando &lt;a href="https://registry.hub.docker.com/">Docker Hub&lt;/a>, &lt;a href="https://docs.docker.com/machine/">Docker Machine&lt;/a> y explicaré de qué forma nos pueden ser útiles estas otras herramientas.&lt;/p>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/04/introduccion-a-elasticsearch/">Introducción a elasticsearch&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-codigo"/><category term="planeta-linux"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2014/11/integracion-entre-ansible-y-docker/</id><title>Integración entre Ansible y Docker</title><updated>2014-12-29T19:00:00+01:00</updated><published>2014-11-22T10:28:52+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/11/integracion-entre-ansible-y-docker/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/ansible.svg" class="right " width="200" alt="Ansible" title="Ansible"/>
&lt;/div>
&lt;div class="logotypes" style="float: right; clear: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>En la &lt;a href="https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/">introducción de Docker&lt;/a> y &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/">inicio básico de docker&lt;/a> explicaba como usar Docker y en la &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-ansible/">introducción a Ansible&lt;/a> explicaba las características de Ansible y como usarlo. Podemos usar &lt;a href="https://www.docker.com/">Docker&lt;/a> y &lt;a href="https://www.ansible.com/">Ansible&lt;/a> de forma separada pero también podemos combinarlas para beneficiarnos de las propiedades de cada una. En Ansible disponemos de dos módulos que nos permite manejar las imágenes y los contenedores de Docker, estos son &lt;a href="http://docs.ansible.com/docker_module.html">docker&lt;/a> y &lt;a href="http://docs.ansible.com/docker_image_module.html">docker_image&lt;/a>.&lt;/p>
&lt;p>Usando tareas de ansible podemos automatizar el arranque del servicio de docker, la construcción de las imágenes con los Dokerfile y el inicio o parada de los contenedores de docker. En el ejemplo se construye una imagen base en la que se basarán el resto de imágenes, se crea una imagen con mysql, otra de redis y finalmente la imagen apps donde se ejecutarán las aplicaciones que usarán los servicios de mysql y redis.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-YAML" data-lang="YAML">---&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>-&lt;span class="w"> &lt;/span>hosts&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>devbox&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>start&lt;span class="w"> &lt;/span>docker&lt;span class="w"> &lt;/span>service&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>service&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>name=docker&lt;span class="w"> &lt;/span>state=started&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>sudo&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>build&lt;span class="w"> &lt;/span>docker&lt;span class="w"> &lt;/span>images&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>docker_image&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>name=&lt;span class="s2">&amp;#34;{{ item.name }}&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>tag=&lt;span class="s2">&amp;#34;{{ item.tag }}&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>state=&lt;span class="s2">&amp;#34;present&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>path={{&lt;span class="w"> &lt;/span>item.path&lt;span class="w"> &lt;/span>}}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>with_items&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>{&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;picodotdev/base&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>tag&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;1.0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>path&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;../docker/base&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>{&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;picodotdev/mysql&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>tag&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;1.0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>path&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;../docker/mysql&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>{&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;picodotdev/redis&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>tag&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;1.0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>path&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;../docker/redis&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>{&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;picodotdev/apps&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>tag&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;1.0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>path&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;../docker/apps&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>}&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/integracion-entre-ansible-y-docker/code/install.yml" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/integracion-entre-ansible-y-docker/code/install.yml" target="_blank">install.yml&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Una vez que disponemos de las imágenes de docker podemos arrancar contenedores con ellas automatizándolo con ansible. En este caso se inicia el servicio de docker, se inicializan los contenedores con los volúmenes donde se guardan los datos de forma persistente de mysql y redis, se inician los contenedores de mysql y redis usando los volúmenes anteriores y finalmente el contenedor de las aplicaciones. Al final, se muestra cierta información de las imágenes como sus direcciones IP.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-YAML" data-lang="YAML">-&lt;span class="w"> &lt;/span>hosts&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>devbox&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>tasks&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>start&lt;span class="w"> &lt;/span>docker&lt;span class="w"> &lt;/span>service&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>service&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>name=docker&lt;span class="w"> &lt;/span>state=started&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>sudo&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>start&lt;span class="w"> &lt;/span>mysql&lt;span class="w"> &lt;/span>data&lt;span class="w"> &lt;/span>docker&lt;span class="w"> &lt;/span>container&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>docker&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>image=busybox&lt;span class="p">:&lt;/span>latest&lt;span class="w"> &lt;/span>name=picodotdev-mysql-data&lt;span class="w"> &lt;/span>state=present&lt;span class="w"> &lt;/span>volumes=&lt;span class="s2">&amp;#34;/var/lib/mysql&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>register&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>mysql_data_container&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>start&lt;span class="w"> &lt;/span>redis&lt;span class="w"> &lt;/span>data&lt;span class="w"> &lt;/span>docker&lt;span class="w"> &lt;/span>container&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>docker&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>image=busybox&lt;span class="p">:&lt;/span>latest&lt;span class="w"> &lt;/span>name=picodotdev-redis-data&lt;span class="w"> &lt;/span>state=present&lt;span class="w"> &lt;/span>volumes=&lt;span class="s2">&amp;#34;/var/lib/redis&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>register&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>redis_data_container&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>start&lt;span class="w"> &lt;/span>mysql&lt;span class="w"> &lt;/span>docker&lt;span class="w"> &lt;/span>container&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>docker&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>image=picodotdev/mysql&lt;span class="p">:&lt;/span>&lt;span class="m">1.0&lt;/span>&lt;span class="w"> &lt;/span>name=picodotdev-mysql&lt;span class="w"> &lt;/span>state=running&lt;span class="w"> &lt;/span>volumes_from=picodotdev-mysql-data&lt;span class="w"> &lt;/span>hostname=mysql&lt;span class="w"> &lt;/span>ports=&lt;span class="m">3306&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">3306&lt;/span>&lt;span class="w"> &lt;/span>command=/sbin/my_init&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>register&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>mysql_container&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>start&lt;span class="w"> &lt;/span>redis&lt;span class="w"> &lt;/span>docker&lt;span class="w"> &lt;/span>container&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>docker&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>image=picodotdev/redis&lt;span class="p">:&lt;/span>&lt;span class="m">1.0&lt;/span>&lt;span class="w"> &lt;/span>name=picodotdev-redis&lt;span class="w"> &lt;/span>state=running&lt;span class="w"> &lt;/span>volumes_from=picodotdev-redis-data&lt;span class="w"> &lt;/span>volumes=&lt;span class="s2">&amp;#34;{{ keys_path }}:/mnt/keys&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>hostname=redis&lt;span class="w"> &lt;/span>ports=&lt;span class="m">6379&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">6379&lt;/span>&lt;span class="w"> &lt;/span>command=/sbin/my_init&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>register&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>redis_container&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>start&lt;span class="w"> &lt;/span>apps&lt;span class="w"> &lt;/span>docker&lt;span class="w"> &lt;/span>container&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>docker&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>image=picodotdev/apps&lt;span class="p">:&lt;/span>&lt;span class="m">1.0&lt;/span>&lt;span class="w"> &lt;/span>name=picodotdev-apps&lt;span class="w"> &lt;/span>state=running&lt;span class="w"> &lt;/span>volumes=&lt;span class="s2">&amp;#34;{{ projects_path }}:/mnt/projects,{{ grails_path }}:/root/.grails,{{ gradle_path }}:/root/.gradle,{{ keys_path }}:/mnt/keys&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>hostname=apps&lt;span class="w"> &lt;/span>ports=&lt;span class="m">8080&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="m">8443&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">8443&lt;/span>&lt;span class="w"> &lt;/span>links=picodotdev-mysql&lt;span class="p">:&lt;/span>mysql&lt;span class="p">,&lt;/span>picodotdev-redis&lt;span class="p">:&lt;/span>redis&lt;span class="w"> &lt;/span>command=/sbin/my_init&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>register&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>apps_container&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>update&lt;span class="w"> &lt;/span>hosts&lt;span class="w"> &lt;/span>with&lt;span class="w"> &lt;/span>containers&lt;span class="w"> &lt;/span>ip&lt;span class="w"> &lt;/span>address&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>replace&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>dest=/etc/hosts&lt;span class="w"> &lt;/span>regexp=&lt;span class="s2">&amp;#34;^(\d+\.\d+\.\d+\.\d+)(\s+{{ item.host }})$&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>replace=&lt;span class="s2">&amp;#34;{{ item.ip }}\2&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>sudo&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>with_items&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>{&lt;span class="w"> &lt;/span>host&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;mysql&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>ip&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ mysql_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;NetworkSettings&amp;#39;][&amp;#39;IPAddress&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>{&lt;span class="w"> &lt;/span>host&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;redis&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>ip&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ redis_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;NetworkSettings&amp;#39;][&amp;#39;IPAddress&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>{&lt;span class="w"> &lt;/span>host&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;apps&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>ip&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ apps_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;NetworkSettings&amp;#39;][&amp;#39;IPAddress&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>}&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>display&lt;span class="w"> &lt;/span>containers&lt;span class="w"> &lt;/span>info&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>debug&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>msg=&lt;span class="s2">&amp;#34;info&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>with_items&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>{&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ mysql_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;Name&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>ip&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ mysql_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;NetworkSettings&amp;#39;][&amp;#39;IPAddress&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>id&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ mysql_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;Id&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>{&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ redis_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;Name&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>ip&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ redis_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;NetworkSettings&amp;#39;][&amp;#39;IPAddress&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>id&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ redis_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;Id&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="w"> &lt;/span>{&lt;span class="w"> &lt;/span>name&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ apps_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;Name&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>ip&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ apps_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;NetworkSettings&amp;#39;][&amp;#39;IPAddress&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>id&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ apps_container[&amp;#39;ansible_facts&amp;#39;][&amp;#39;docker_containers&amp;#39;][0][&amp;#39;Id&amp;#39;] }}&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>}&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/integracion-entre-ansible-y-docker/code/start.yml" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/integracion-entre-ansible-y-docker/code/start.yml" target="_blank">start.yml&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Ansible &lt;a href="http://docs.ansible.com/list_of_all_modules.html">dispone muchos módulos&lt;/a> que nos permiten automatizar las tareas:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://docs.ansible.com/list_of_cloud_modules.html">Módulos para manejo de entornos cloud&lt;/a> (&lt;a href="http://aws.amazon.com/es/ec2/">Amazon EC2&lt;/a>, &lt;a href="https://azure.microsoft.com/es-es/">microsoft-azure&lt;/a>, &lt;a href="https://www.digitalocean.com/">Digital Ocean&lt;/a>, &lt;a href="https://www.openstack.org/">OpenStack&lt;/a>, &lt;a href="https://www.rackspace.com/es">Rackspace&lt;/a>)&lt;/li>
&lt;li>&lt;a href="http://docs.ansible.com/list_of_commands_modules.html">Módulos para ejecutar comandos&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://docs.ansible.com/list_of_database_modules.html">Módulos para administración de bases de datos&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://docs.ansible.com/modules_by_category.html">Módulos para manejo de archivos&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://docs.ansible.com/list_of_packaging_modules.html">Módulos para manejo de paquetes&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://docs.ansible.com/list_of_source_control_modules.html">Módulos para manejo de sistemas de control de versiones&lt;/a>&lt;/li>
&lt;li>Y algunos más&lt;/li>
&lt;/ul>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/">Introducción a Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/">Guía de inicio básico de Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/">Cómo crear una imagen para Docker usando un Dockerfile&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-ansible/">Introducción a Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-bitnami/">Introducción a Bitnami&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://docs.ansible.com/docker_module.html">http://docs.ansible.com/docker_module.html&lt;/a>&lt;br>&lt;/li>
&lt;li>&lt;a href="http://docs.ansible.com/docker_image_module.html">http://docs.ansible.com/docker_image_module.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-linux"/><category term="planeta-codigo"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/</id><title>Cómo crear una imagen para Docker usando un Dockerfile</title><updated>2015-05-26T20:00:00+01:00</updated><published>2014-11-07T19:50:17+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Podemos usar los contenedores disponibles en Docker Hub, donde están disponibles las aplicaciones de bases de datos, servidores de aplicaciones de mútiples lenguages, servidores web más populares y entre otras muchas. Pero también podemos definir nuestras propias imágenes personalizadas con las necesidades que tengamos. Lo que necesitamos es escribir un archivo que contenga la receta para construir la imagen del contenedor, este archivo es el Dockerfile.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>Las imágenes de &lt;a href="https://www.docker.com/">docker&lt;/a> son el sistema de archivos que usa el proceso o procesos que se arrancan en los contenedores. Si nos convencen las &lt;a href="https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/">características de docker&lt;/a> y estamos decididos a usarlo y ya sabemos &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/">como administrar de forma básica los contendores&lt;/a> si queremos disponer de una imagen adaptada a los servicios que necesitamos para iniciar contenedores tendremos que crearla, en este artículo explicaré cómo crear una imagen para docker personalizada.&lt;/p>
&lt;p>Antes de crear una imagen para docker podemos buscar en el &lt;a href="https://registry.hub.docker.com/">registro de imágenes de docker&lt;/a> que han creado otros usuarios y los han compartido por si hay alguna que ya se adapte a nuestras necesidades, si nos sirve alguna y es algo popular nos evitaremos tener que modificarla nosotros mismos según salgan nuevas versiones de los servicios que use. El registro de imágenes de docker es un servicio en el que los usuarios comparten y colaboran en la creación de las imágenes. Para los servicios más conocidos dispondremos ya de las imágenes como podrían ser: &lt;a href="https://registry.hub.docker.com/_/mysql/">mysql&lt;/a>, &lt;a href="https://registry.hub.docker.com/_/redis/">redis&lt;/a>, &lt;a href="https://registry.hub.docker.com/_/postgres/">postgresql&lt;/a>, &lt;a href="https://registry.hub.docker.com/_/ubuntu/">ubuntu&lt;/a>, &lt;a href="https://registry.hub.docker.com/_/wordpress/">wordpress&lt;/a>, &lt;a href="https://registry.hub.docker.com/_/nginx/">nginx&lt;/a>, &lt;a href="https://registry.hub.docker.com/_/mongo/">mongodb&lt;/a>, &amp;hellip;&lt;/p>
&lt;p>Si no hay ninguna que se adapte totalmente a nuestras necesidades, no nos gusta como están construidas las existes o no confiamos en el mantenimiento que puedan tener esas imágenes podemos crear las nuestras propias. Para crear una imagen de docker se necesita una receta en forma de &lt;a href="http://docs.docker.com/reference/builder/">archivo Dockerfile&lt;/a> que contiene la descripción e instrucciones para construir la imagen. Para crear un dockerfile podemos basarnos en los de las imágenes del registro de docker.&lt;/p>
&lt;p>Este podría ser el contenido y la receta de un dockerfile si quisiésemos crear una imagen de docker para mysql, lo paso a explicar después.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">FROM phusion/baseimage:0.9.15
MAINTAINER picodotdev &amp;lt;pico.dev@gmail.com&amp;gt;
ENV HOME /root
RUN apt-get update -q
RUN /etc/my_init.d/00_regen_ssh_host_keys.sh
RUN echo &amp;#39;root:$6$l/PahbyY$jFhqIAuvHeK/GwjfT71p4OBBkHQpnTe2FErcUWZ8GIN1ykdI7CgL05Jkk7MYW6l.0pijAlfoifkQnLpaldEJY0&amp;#39; | chpasswd -e
ADD bashrc /root/.bashrc
ADD timezone /etc/timezone
EXPOSE 22
CMD [&amp;#34;/sbin/my_init&amp;#34;]&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/code/Dockerfile-base" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/code/Dockerfile-base" target="_blank">Dockerfile-base&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">FROM picodotdev/base:1.0
MAINTAINER picodotdev &amp;lt;pico.dev@gmail.com&amp;gt;
ENV HOME /root
RUN apt-get install -y mysql-server mysql-client
ADD my.cnf /etc/mysql/my.cnf
RUN mkdir /etc/service/mysql
ADD mysql /etc/service/mysql/run
RUN chmod +x /etc/service/mysql/run
RUN rm -R /var/lib/mysql &amp;amp;&amp;amp; \
mkdir /var/lib/mysql &amp;amp;&amp;amp; \
mkdir /mnt/keys
VOLUME [&amp;#34;/var/lib/mysql&amp;#34;, &amp;#34;/mnt/keys&amp;#34;]
RUN apt-get clean &amp;amp;&amp;amp; \
rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
EXPOSE 22 3306
CMD [&amp;#34;/sbin/my_init&amp;#34;]&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/code/Dockerfile-mysql" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/code/Dockerfile-mysql" target="_blank">Dockerfile-mysql&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Los Dockerfile tienen algunas instrucciones:&lt;/p>
&lt;ul>
&lt;li>FROM: indica la imagen base a partir de la cual crearemos la imagen que construirá el Dockerfile.&lt;/li>
&lt;li>MAINTAINER: documenta el creador de la imagen.&lt;/li>
&lt;li>ENV HOME: establece el directorio HOME que usarán los comandos RUN.&lt;/li>
&lt;li>RUN: permite ejecutar una instrucción en el contenedor, por ejemplo, para instalar algún paquete mediante el gestor de paquetes (apt-get, yum, rpm, &amp;hellip;).&lt;/li>
&lt;li>ADD: permite añadir un archivo al contenedor, en muchas ocasiones se utiliza para proporcionar la configuración de los servicios (ssh, mysql, &amp;hellip;).&lt;/li>
&lt;li>VOLUME: establece puntos de montaje que al usar el contenedor se pueden proporcionar, los volúmenes son al forma de externalizar un determinado directorio y proporcionar persistencia (las imágenes de docker son de solo lectura y no almacenan datos entre diferentes ejecuciones).&lt;/li>
&lt;li>EXPOSE: indica los puertos TCP/IP por los que se pueden acceder a los servicios del contenedor, los típicos son 22 (SSH), 80 (HTTP) y en este caso el puerto por defecto de mysql 3306.&lt;/li>
&lt;li>CDM: establece el comando del proceso de inicio que se usará si no se indica uno al iniciar un contenedor con la imagen.&lt;/li>
&lt;/ul>
&lt;p>El Dockerfile-base crea una imagen base que usaremos posteriormente en la imagen de mysql, configura el color del prompt, la contraseña de root y expone el puerto 22 para poder hacer ssh.&lt;/p>
&lt;p>En este ejemplo en vez de usar una imagen propia de Ubuntu en la directiva FROM he usado una imagen especial, &lt;a href="https://registry.hub.docker.com/u/phusion/baseimage/">phusion/baseimage&lt;/a>:0.9.15. La imagen phusion/baseimage proporciona un sistema init adaptado al funcionamiento de los contenedores de docker al contrario de las imágenes de ubuntu que emplean upstart. Si usásemos alguna imagen de ubuntu y quisiésemos iniciar varios procesos en el contenedor deberíamos usar un servicio como punto de entrada como &lt;a href="http://supervisord.org/">supervisord&lt;/a>, con la imagen phusion/baseimage no sería necesario ya que ya ofrece esta funcionalidad de forma más sencilla.&lt;/p>
&lt;p>Con las instrucciones RUN y ADD instalamos el paquete de mysql y el cliente de mysql y añadimos la configuración de mysql en el archivo my.cnf. En /etc/service/mysql/run dejamos el comando del servicio que iniciará el proceso de mysql como espera el sistema init de la imagen phusion. Con VOLUME [&amp;ldquo;/var/lib/mysql&amp;rdquo;] establecemos un punto de montaje para poder externalizar y persistir los datos de las bases de datos de mysql.&lt;/p>
&lt;p>Una vez tenemos el Dockerfile y los archivos de configuración a incluir con los comandos ADD contruimos la imagen con:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker build -t &lt;span class="s2">&amp;#34;picodotdev/base:1.0&amp;#34;&lt;/span> docker/base
$ docker build -t &lt;span class="s2">&amp;#34;picodotdev/mysql:1.0&amp;#34;&lt;/span> docker/mysql&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/code/docker-build.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/code/docker-build.sh" target="_blank">docker-build.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/images/docker-mysql.png" title="docker-mysql" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/images/docker-mysql-thumb.png" width="650"/>&lt;/a>
&lt;/figure>
&lt;/div>
&lt;p>Para proporcionar la persistencia a la imagen de mysql podemos crear un contenedor específico que contenga los datos. Con el siguiente comando creamos un contenedor de datos, uso la imagen busybox ya que es una de las más pequeñas:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker run --name mysql-data -d -v /var/lib/mysql busybox
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/code/docker-run-1.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/code/docker-run-1.sh" target="_blank">docker-run-1.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Posteriormente podemos iniciar y parar el contenedor de msql con:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker run --name mysql -d -p 3306:3306 --volumes-from mysql-data picodotdev/mysql:1.0 /sbin/my_init
3f5774999a7850ff4c8c0512ff066daf67a6e19499113ee9f04dc2511972a163
$ docker stop 3f5774999&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/code/docker-run-2.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/code/docker-run-2.sh" target="_blank">docker-run-2.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>En los siguientes artículos comentaré la herramienta de automatización &lt;a href="https://www.ansible.com/">ansible&lt;/a> y como sacarle provecho para iniciar los contenedores en una máquina de desarrollo (devbox). También en algún otro artículo comentaré la opción de &lt;a href="https://bitnami.com/">bitnami&lt;/a> que dentro de poco ofrecerá soporte para docker y como con esta opción podemos usar un servicio «out-of-the-box» si tener que crear ni siquiera un Dockerfile o tener que documentarnos para instalar un servicio (que en algunos casos pueden tener cierta complejidad) aunque sea usando virtualización con &lt;a href="https://www.virtualbox.org/">virtualbox&lt;/a> o computación en la nube.&lt;/p>
&lt;div class="media-amazon" style="text-align: center;">
&lt;iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=9d344246cd59cd65a952305379c2556a">&lt;/iframe>
&lt;/div>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/">Introducción a Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/">Guía de inicio básico de Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.nkode.io/2014/08/24/valuable-docker-links.html">Lista de enlaces sobre Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-ansible/">Introducción a Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/integracion-entre-ansible-y-docker/">Integración entre Ansible y Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-bitnami/">Introducción a Bitnami&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-linux"/><category term="planeta-codigo"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/</id><title>Inicio básico de Docker</title><updated>2015-05-26T20:00:00+01:00</updated><published>2014-11-01T09:47:51+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>La tecnología de contenedores nos ofrece múltiples ventajas para nuestras aplicaciones. Docker es una de las más nombradas y que está creciendo muy rápidamente. Es muy sencillo empezarla a usar como mostraré en unos pocos comandos a continuación.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>En el &lt;a href="https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/">artículo anterior introductorio sobre Docker&lt;/a> comentaba cuales son sus principales características, que diferencias tiene con la virtualización y algunos casos y motivos por los que nos puede interesar usarlo. El objetivo de este artículo será a modo de guía rápida como empezar a usar &lt;a href="https://www.docker.com/">docker&lt;/a>. Comentaré cuales son los comandos básicos para manejar docker, las imágenes y los contenedores.&lt;/p>
&lt;p>Antes de empezar con la guía propiamente hay que tener en cuenta que otra de las características de docker es que únicamente se inicia un solo proceso, cuando este finaliza finaliza la instancia del contenedor. Aunque en principio un contenedor solo tiene un proceso, podemos usar como proceso inicial uno que arranque otros, la &lt;a href="https://registry.hub.docker.com/u/phusion/baseimage/">imagen pushion&lt;/a> tiene un sistema de inicio adaptado al funcionamiento de docker (no siendo así upstart de las imágenes de ubuntu o systemd usado por otras distribuciones) con el que podemos iniciar otros procesos, en cualquier caso es recomendable que un contenedor sino tiene un solo proceso tenga unos pocos procesos relacionados con el servicio que proporciona la imagen, la recomendación es no proporcionar una imagen con un montón de servicios/procesos sino varias pequeñas cuyos servicios colaboren. Una imagen de un contenedor es básicamente el sistema de archivos que usará el proceso que iniciamos en el contenedor, necesitamos obtener o construir una imagen para iniciar los contenedores y trabajar con docker.&lt;/p>
&lt;p>Primeramente deberemos instalar el paquete de docker, en el caso de &lt;a href="https://www.archlinux.org/">Arch Linux&lt;/a> con el siguiente comando:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ sudo pacman -S docker
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-1.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-1.sh" target="_blank">docker-1.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Para poder usar docker sin emplear el comando sudo deberemos crear y añadir nuestro usuario al grupo docker:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># groupadd docker&lt;/span>
&lt;span class="c1"># usermod -aG docker picodotdev&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-2.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-2.sh" target="_blank">docker-2.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Una vez instalado el paquete y añadido nuestro usuario al grupo docker podemos iniciar el servicio de docker, en Arch Linux con systemd:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ sudo systemctl start docker.service
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-3.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-3.sh" target="_blank">docker-3.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Con el comando «docker images», «docker ps», «docker ps -a» podemos respectivamente ver las imágenes de docker disponibles en nuestro sistema, las instancias de los contenedores iniciadas y las instancias de los contenedores incluyendo las no iniciadas.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker images
$ docker ps
$ docker ps -a&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-4.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-4.sh" target="_blank">docker-4.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/images/docker-images.png" title="docker-images" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/images/docker-images-thumb.png" width="650"/>&lt;/a>
&lt;/figure>
&lt;/div>
&lt;p>Con los comandos &lt;em>docker rm [contenedor]&lt;/em> y &lt;em>docker rmi [imagen]&lt;/em> podemos eliminar las instancias de contenedores y las imágenes que no estén siendo usadas por ningún contenedor, si están siendo usadas deberemos eliminar primero el contenedor.&lt;/p>
&lt;p>Una vez conocemos los comandos básicos para gestionar las imágenes y contenedores aún nos quedan conocer los comandos para obtener las imágenes y como iniciarlas. No hace falta que las imágenes las construyamos nosotros desde cero sino que podemos utilizar las que otras personas han construido. Docker dispone de un &lt;a href="https://registry.hub.docker.com/">registro o repositorio de imágenes&lt;/a> en el que la comunidad (otras personas) publica las que ellos han construido, en este registro podemos encontrar imágenes para cualquier servicio de los más utilizados ya sea &lt;a href="https://www.mysql.com/">MySQL&lt;/a>, &lt;a href="https://nginx.org/">Nginx&lt;/a>, &lt;a href="https://redis.io/">Redis&lt;/a>, &lt;a href="https://wordpress.org/">WordPress&lt;/a>, &lt;a href="https://www.postgresql.org/">PostgreSQL&lt;/a>, &lt;a href="https://www.ubuntu.com/">Ubuntu&lt;/a>, &lt;a href="https://www.centos.org/">CentOS&lt;/a>, &amp;hellip; Este repositorio de imágenes hace que podamos disponer de estos servicios muy fácilmente, sin embargo, hay que tener en cuenta que algunas imágenes no son construidas por alguien &amp;ldquo;oficial&amp;rdquo; de ese servicio, cualquier persona puede &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/">construir una imagen de un servicio&lt;/a> y hacerlo disponible en el repositorio esto hace que algunas imágenes puedan no ser de la máxima calidad o que estén apropiadamente mantenidas. Por ello, es recomendable utilizar las imágenes más descargadas y usadas, a pesar de todo con docker si una imagen no nos gusta podemos basarnos en ella para construir una que se adapte totalmente a nuestras necesidades y con la que nos sintamos cómodos.&lt;/p>
&lt;p>Para obtener una imagen usamos el comando «docker pull [imagen]» indicando el usuario que creó la imagen, el nombre de la imagen y el tag. En el siguiente enlace en la pestaña tags podemos ver las &lt;a href="https://registry.hub.docker.com/_/debian/">imágenes para docker de Debian y sus tag&lt;/a>:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker pull debian:7.7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-5.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-5.sh" target="_blank">docker-5.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/images/docker-pull.png" title="docker-pull" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/images/docker-pull-thumb.png" width="650"/>&lt;/a>
&lt;/figure>
&lt;/div>
&lt;p>Una vez descargada la imagen podemos iniciar un contenedor de la imagen con:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker run --rm -i -t --name debian debian:7.7 /bin/bash
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-6.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/code/docker-6.sh" target="_blank">docker-6.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>En la terminal que se inicia podemos usar cualquier comando que usaríamos en un sistema &lt;a href="https://www.debian.org/">debian&lt;/a> como apt-get.&lt;/p>
&lt;p>Este es el momento para explicar otra de las peculiaridades de los contenedores de docker y es que estos no conservan el estado de una ejecución a otra y cada vez que ejecutemos el comando se creará una nueva instancia del contenedor. Para conseguir la persistencia al crear las imágenes se pueden establecer puntos de montaje, esta persistencia está externalizada en otros contenedores con el solo propósito de servir como volúmenes de datos, también se puede montar un directorio del sistema anfitrión.&lt;/p>
&lt;p>Si usamos el comando «uname -a» puede verse que aunque el contenedor usa el sistema de archivos de una distribución debian el kernel empleado es el del sistema anfitrión, esto es así porque los contenedores docker en esencia no son más que procesos dentro del sistema.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/images/docker-run.png" title="docker-run" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/11/inicio-basico-de-docker/images/docker-run-thumb.png" width="650"/>&lt;/a>
&lt;/figure>
&lt;/div>
&lt;p>Continuando esta serie de artículos sobre docker explicaré como construir una imagen mediante los Dockerfiles con la que podamos usar una base de datos mysql y explicaré en más detalle como podemos conseguir la persistencia que necesitaremos para almacenar los datos de la base de datos usando otro contenedor con este propósito.&lt;/p>
&lt;div class="media-amazon" style="text-align: center;">
&lt;iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=9d344246cd59cd65a952305379c2556a">&lt;/iframe>
&lt;/div>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/">Introducción y características de Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/">Cómo crear una imagen para Docker usando un Dockerfile&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-ansible/">Introducción a Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/integracion-entre-ansible-y-docker/">Integración entre Ansible y Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-bitnami/">Introducción a Bitnami&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://registry.hub.docker.com/">Docker Hub Registry&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://phusion.github.io/baseimage-docker/">http://phusion.github.io/baseimage-docker/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-linux"/><category term="planeta-codigo"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/</id><title>Introducción y características de Docker</title><updated>2017-05-02T23:00:00+02:00</updated><published>2014-10-25T10:52:34+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Los contenedores no son una tecnología nueva pero Docker ha reunido las características necesarias para hacerla sencilla y popular en Linux. Suponen un cambio en la infraestructura de las aplicaciones con algunas ventajas sobre la virtualización y la instalación de los servicios directamente en el sistema.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/docker.svg" class="right " width="200" alt="Docker" title="Docker"/>
&lt;/div>
&lt;p>&lt;a href="https://www.docker.com/">Docker&lt;/a> es una de las herramientas de la que se está hablando mucho, esto es así ya que tiene varios aspectos interesantes que &lt;a href="https://www.javaworld.com/article/2685223/java-app-dev/four-ways-docker-fundamentally-changes-application-development.html">cambian la forma de desarrollar aplicaciones&lt;/a>. Docker es una forma de ejecutar procesos de forma aislada pero también se compone de herramientas para construir imágenes y un repositorio para compartirlas.&lt;/p>
&lt;p>Al contrario de la virtualización Docker no emula o virtualiza una máquina y su sistema operativo con lo que los procesos son mucho más ligeros y hace que el hardware pueda ser aprovechado más al poder aumentar la densidad de los servicios en una misma máquina. Los contenedores y servicios incluidos en ellos inician muy rápidamente, en pocos segundos. Además, no es necesario el sistema de archivos completo del sistema operativo invitado con lo que docker usa una fracción de espacio de almacenamiento necesario en la virtualización.&lt;/p>
&lt;p>La tecnología de contenedores no es nueva y también está disponible en otros sistemas operativos como &lt;a href="https://openvz.org/">OpenVZ&lt;/a> también en Linux, &lt;a href="http://www.freebsd.org/doc/handbook/jails.html">FreeBSD Jails&lt;/a> o los &lt;a href="https://www.oracle.com/technetwork/server-storage/solaris/containers-169727.html">contenedores de Solaris&lt;/a>.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/images/virtual-machines.png" title="Máquinas virtuales" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/images/virtual-machines.png" width="686"/>&lt;/a>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/images/docker.png" title="Docker" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/images/docker.png" width="686"/>&lt;/a>
&lt;/figure>
&lt;/div>
&lt;p>Docker tiene varias características interesantes. Es ligero ya que no hay virtualización aprovechándose mejor el hardware y únicamente necesitando el sistema de archivos mínimo para que funcionen los servicios. Los contenedores son autosuficientes (aunque pueden depender de otros contenedores, por ejemplo, un wordpress que necesita una base de datos mysql) no necesitando nada más que la imagen del contenedor para que funcionen los servicios que ofrece. Las imágenes de docker son portables entre diferentes plataformas el único requisito es que en el sistema huésped esté disponible docker. Es seguro, pudiendo hacer que los contenedores se comuniquen por un túnel solo disponible para ellos, los contenedores están aislados en el sistema mediante namespaces y control groups.&lt;/p>
&lt;p>Para los desarrolladores tiene las siguientes ventajas:&lt;/p>
&lt;ul>
&lt;li>Podemos disponer de un entorno de desarrollo (devbox) o servicio en varios minutos/horas en vez de algún día. Esto es así porque la configuración y los servicios necesarios están automatizados en la construcción de las imágenes de los contenedores mediante &lt;a href="https://docs.docker.com/reference/builder/">Dockerfiles&lt;/a>.&lt;/li>
&lt;li>Al estar los servicios en contenedores no hace falta instalarlos en la máquina en la que son alojados, de forma que podemos disponer de los servicios y después eliminarlos de forma sencilla sin &amp;ldquo;ensuciar&amp;rdquo; el sistema huésped.&lt;/li>
&lt;li>Nos permite tener versiones más parecidas o iguales a las usadas en producción. Por ejemplo, en Arch Linux nos permite tener un mysql de la distribución &lt;a href="https://www.ubuntu.com/">Ubuntu&lt;/a> usando la misma versión.&lt;/li>
&lt;/ul>
&lt;p>El &lt;a href="https://registry.hub.docker.com/">registro de contenedores de Docker&lt;/a> es una forma colaborativa de ofrecer imágenes. Hay disponibles multitud de contenedores con los servicios más populares: &lt;a href="https://www.mysql.com/">MySql&lt;/a>, &lt;a href="https://www.postgresql.org/">PostgreSQL&lt;/a>, &lt;a href="https://redis.io/">Redis&lt;/a>, &lt;a href="https://nginx.org/">Nginx&lt;/a>, &lt;a href="https://wordpress.org/">WordPress&lt;/a>, &amp;hellip;&lt;/p>
&lt;p>Para los administradores de sistemas tiene las siguientes ventajas:&lt;/p>
&lt;ul>
&lt;li>Pueden proporcionar entornos similares o iguales a los entornos de pruebas, QA o producción independientemente de la distribución que se use.&lt;/li>
&lt;li>Es posible desplegar un contenedor en cualquier infraestructura Linux.&lt;/li>
&lt;li>La creación de los contenedores puede ponerse bajo un sistema de control de versiones.&lt;/li>
&lt;/ul>
&lt;p>En la siguiente presentación muy completa están ampliados muchas de sus posibilidades y funcionalidades.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;script async class="speakerdeck-embed" data-id="c02e6030ee52013165c72a37516b560d" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js">&lt;/script>
&lt;/div>
&lt;p>Una vez conocidos los aspectos básicos y en que se diferencia docker de la virtualización así como el caso de uso de por ejemplo un devbox o disponer de entornos similares a los de producción de una aplicación, en el siguiente artículo comentaré &lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/">cómo instalar docker, cómo empezar a usarlo, cómo obtener imágenes de servicios y pararlos y administrarlos&lt;/a>. En la siguiente &lt;a href="http://www.nkode.io/2014/08/24/valuable-docker-links.html">lista de enlaces sobre Docker&lt;/a> se puede encontrar mucha información reunida dispersa en la red, desde introducciones, opiniones, como usarlo, como empaquetar las aplicaciones, como monitorizar o como usarlo en microservicios.&lt;/p>
&lt;div class="media-amazon" style="text-align: center;">
&lt;iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=9d344246cd59cd65a952305379c2556a">&lt;/iframe>
&lt;/div>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/">Inicio básico de Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/">Cómo crear una imagen para Docker usando un Dockerfile&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.docker.com/">Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-ansible/">Introducción a Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/integracion-entre-ansible-y-docker/">Integración entre Ansible y Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-bitnami/">Introducción a Bitnami&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/articles/security/">Seguridad Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.javaworld.com/article/2685223/java-app-dev/four-ways-docker-fundamentally-changes-application-development.html">Four ways Docker fundamentally changes application development&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openwebinars.net/docker-que-es-sus-principales-caracteristicas/">Docker, qué es y sus principales características&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-linux"/><category term="planeta-codigo"/></entry></feed>
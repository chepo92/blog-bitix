<?xml version="1.0" encoding="utf-8" standalone="yes"?><feed xmlns="http://www.w3.org/2005/Atom"><id>https://picodotdev.github.io/blog-bitix/tags/java/</id><title type="text">Blog Bitix</title><subtitle>Recent content on Blog Bitix</subtitle><updated>2018-12-14T20:00:00+01:00</updated><author><name>picodotdev</name></author><generator>Hugo</generator><icon>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</icon><logo>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</logo><rights>https://creativecommons.org/licenses/by-sa/4.0/</rights><entry><id>https://picodotdev.github.io/blog-bitix/2018/12/monitorizar-una-aplicacion-java-de-spring-boot-con-micrometer-prometheus-y-grafana/</id><title>Monitorizar una aplicación Java de Spring Boot con Micrometer, Prometheus y Grafana</title><updated>2018-12-14T20:00:00+01:00</updated><published>2018-12-14T20:00:00+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/12/monitorizar-una-aplicacion-java-de-spring-boot-con-micrometer-prometheus-y-grafana/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/prometheus.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Promehteus&#34; title=&#34;Promehteus&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/grafana.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Grafana&#34; title=&#34;Grafana&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Los &lt;a href=&#34;https://spring.io/projects&#34;&gt;proyectos de Spring&lt;/a&gt; no son tan conservadores como Java EE o ahora Jakata EE y se desarrollan a una velocidad mayor cubriendo de forma más temprana las necesidades de los programadores según evolucionan las tecnologías y se adoptan nuevos modelos de arquitectura.&lt;/p&gt;
&lt;p&gt;Con el advenimiento de los microservicios, contenedores, la nube y aplicaciones autocontenidas Spring se ha adaptado con proyectos como &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; y &lt;a href=&#34;https://projects.spring.io/spring-cloud/&#34;&gt;Spring Cloud&lt;/a&gt;. En el asunto que ocupa este artículo de métricas con la versión 2 de Spring Boot se ha adoptado &lt;a href=&#34;https://micrometer.io/&#34;&gt;Micrometer&lt;/a&gt; como librería para proporcionar las métricas.&lt;/p&gt;
&lt;p&gt;Micrometer permite exportar a cualquiera de los más populares sistemas de monitorización los datos de las métricas. Usando Micrometer la aplicación se abstrae del sistema de métricas empleado pudiendo cambiar en un futuro si se desea. Uno de los sistemas más populares de monitorización es &lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt; que se encarga de recoger y almacenar los datos de las métricas expuestas por las aplicaciones y ofrece un lenguaje de consulta de los datos con el que otras aplicaciones pueden visualizarlos en gráficas y paneles de control. &lt;a href=&#34;https://grafana.com/&#34;&gt;Grafana&lt;/a&gt; es una de estas herramientas que permite visualizar los datos proporcionados por Prometheus. Estos sistemas de monitorización ofrecen un sistema de alertas que se integran entre otros con &lt;a href=&#34;https://slack.com/&#34;&gt;Slack&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;En el artículo &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/12/informacion-y-metricas-de-la-aplicacion-con-spring-boot-actuator/&#34;&gt;Información y métricas de la aplicación con Spring Boot Actuator&lt;/a&gt; mostraba como configurar Spring Boot y &lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready&#34;&gt;Spring Boot Actuator&lt;/a&gt; para exponer métricas en el &lt;em&gt;endpoint&lt;/em&gt; &lt;em&gt;/actuator/metrics&lt;/em&gt;, con estas herramientas solo se exponen la clave y valor de cada métrica y solo en un momento dado. Pueden ser métricas del servicio como cantidad de CPU usada, memoria consumida y libre, espacio en almacenamiento, etc&amp;hellip; o métricas de aplicación como número de peticiones realizadas al servicio, tiempo de respuesta, etc&amp;hellip; Una de las funcionalidades de Prometheus es recolectar cada cierto tiempo los valores de estas métricas que da lugar a una colección de datos que varía en el tiempo y que Grafana puede visualizar en gráficas para una mucha mayor facilidad de comprensión que la enorme cantidad de datos en crudo.&lt;/p&gt;
&lt;p&gt;Usando Spring Boot 2 exportar los datos para Prometheus es realmente sencillo, basta con incluir la dependencia &lt;em&gt;io.micrometer:micrometer-registry-prometheus&lt;/em&gt; mediante la herramienta de construcción, por ejemplo &lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt;, y automáticamente se expone en el &lt;em&gt;endpoint&lt;/em&gt; &lt;em&gt;/actuator/prometheus&lt;/em&gt; con la información de las métricas en el formato que espera Prometheus para recolectarla.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4e15b5759f6a55f30681fafc449516b5.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;p&gt;Micrometer y Prometheus ofrecen varios tipos de métricas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Counter&lt;/em&gt;: representa un valor que se va incrementando a lo largo del tiempo. Puede ser el número de invocaciones recibidas por servicio.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Gauge&lt;/em&gt;: representa un valor que arbitrariamente puede subir o bajar. Puede ser la cantidad de memoria usada.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Timer&lt;/em&gt;: mide periodos de tiempo. Puede ser el tiempo de respuesta empleado para atender una petición de un servicio.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Distribution summaries&lt;/em&gt;: recolecta la distribución de una serie de datos con los que se pueden obtener percentiles.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Utilizando el ejemplo que hice para la &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/spring-cloud/&#34;&gt;serie de artículos sobre Spring Cloud&lt;/a&gt; he añadido al micro servicio &lt;em&gt;service&lt;/em&gt; un contador con el número de invocaciones que se le ha realizado. Este dato se expone en el &lt;em&gt;endpoint&lt;/em&gt; con la clave &lt;em&gt;service.invocations&lt;/em&gt; como se ha definido al registrar el contador en Micrometer con la clase &lt;em&gt;MeterRegistry&lt;/em&gt;. Además de esta métrica propia del servicio Spring Boot Actuator añade otras muchas más del uso de la CPU, memoria, &amp;hellip;&lt;/p&gt;
&lt;p&gt;Una clase de una aplicación de Spring Boot que utiliza un &lt;em&gt;Counter&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4e15b5759f6a55f30681fafc449516b5.js?file=DefaultController.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;Las claves de las métricas por defecto exportadas por Spring Boot Actuator.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4e15b5759f6a55f30681fafc449516b5.js?file=actuator-metrics.json&#34;&gt;&lt;/script&gt;
&lt;p&gt;Los datos de una métrica en el &lt;em&gt;enpoint&lt;/em&gt; &lt;em&gt;/actuator/metrics/service.invocations&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4e15b5759f6a55f30681fafc449516b5.js?file=actuator-metrics-service-invocations.json&#34;&gt;&lt;/script&gt;
&lt;p&gt;Y las mismas métricas en el formato que espera Prometheus.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4e15b5759f6a55f30681fafc449516b5.js?file=actuator-metrics-prometheus.txt&#34;&gt;&lt;/script&gt;
&lt;p&gt;Para iniciar el ejemplo de Spring Cloud que consta de un servicio de registro y descubrimiento, un servicio de configuración, un servicio del que se pueden iniciar varias instancias y un cliente que hace peticiones hay que utilizar la siguiente serie de comandos.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4e15b5759f6a55f30681fafc449516b5.js?file=gradlew-run.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Una vez expuestas las métricas en el formato que espera Prometheus este ya puede recolectarlas. Para usar Prometheus y posteriormente Grafana de forma fácil evitando tener que instalar y configurar nada se puede usar &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt;, en este caso con &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker Compose&lt;/a&gt;. En la &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/docker/&#34;&gt;serie de artículos sobre Docker&lt;/a&gt; explico que proporciona Docker y como usar las varias herramientas que ofrece.&lt;/p&gt;
&lt;p&gt;El archivo de Docker Compose contiene dos contenedores uno para Prometheus y otro para Grafana, con sus archivos de configuración. En la configuración de Prometheus se crean un &lt;em&gt;job&lt;/em&gt; que recolecta las métricas cada pocos segundos del servicio a través del &lt;em&gt;endpoint&lt;/em&gt; de métricas. En la configuración de Grafana se añade como una fuente de datos Prometheus, se puede añadir otras varias.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4e15b5759f6a55f30681fafc449516b5.js?file=docker-compose.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4e15b5759f6a55f30681fafc449516b5.js?file=docker-compose.yml&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4e15b5759f6a55f30681fafc449516b5.js?file=prometheus.yml&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4e15b5759f6a55f30681fafc449516b5.js?file=grafana-datasources.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;Prometheus posee la funcionalidad básica de crear gŕaficas con las métricas recogidas pero no tiene la habilidad de crear paneles que recogen una colección de gráficas relacionadas o un editor de consultas más avanzado como tiene Grafana.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/12/monitorizar-una-aplicacion-java-de-spring-boot-con-micrometer-prometheus-y-grafana/images/prometheus-graph_hudb4fb1b3b4c5fc9bfe9195d2743ad9f9_62771_2560x1440_fit_box_2.png&#34; title=&#34;Métrica de la aplicación en Prometheus&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/12/monitorizar-una-aplicacion-java-de-spring-boot-con-micrometer-prometheus-y-grafana/images/prometheus-graph_hudb4fb1b3b4c5fc9bfe9195d2743ad9f9_62771_300x200_fit_box_2.png&#34; width=&#34;179&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/12/monitorizar-una-aplicacion-java-de-spring-boot-con-micrometer-prometheus-y-grafana/images/grafana-graph_hu70e557534c16596229235e47193c737c_53439_2560x1440_fit_box_2.png&#34; title=&#34;Métrica de la aplicación en Grafana&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/12/monitorizar-una-aplicacion-java-de-spring-boot-con-micrometer-prometheus-y-grafana/images/grafana-graph_hu70e557534c16596229235e47193c737c_53439_300x200_fit_box_2.png&#34; width=&#34;300&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Métrica de la aplicación en Prometheus y Grafana&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Una vez que Prometheus recolecta los datos de las métricas al introducir las expresiones se proporciona asistencia de código. Por otro lado, en la sección &lt;em&gt;Status &amp;gt; Targets&lt;/em&gt; de
Prometheus se puede ver el estado de los servicios de los que recolecta métricas.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/12/monitorizar-una-aplicacion-java-de-spring-boot-con-micrometer-prometheus-y-grafana/images/prometheus-targets_hufff0caf060b535c26e9dd0ca59058429_51904_2560x1440_fit_box_2.png&#34; title=&#34;Estado de servicios en Prometheus&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/12/monitorizar-una-aplicacion-java-de-spring-boot-con-micrometer-prometheus-y-grafana/images/prometheus-targets_hufff0caf060b535c26e9dd0ca59058429_51904_300x200_fit_box_2.png&#34; width=&#34;283&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Estado de los servicios rastreados por Prometheus&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Como Spring Boot Actuator exporta muchas métricas del funcionamiento del servicio Grafana puede crear gráficas de todas ellas. No hace falta crear un &lt;em&gt;dashboard&lt;/em&gt; desde cero, se pueden descargar e importar &lt;em&gt;dashboards&lt;/em&gt;. Este &lt;a href=&#34;https://grafana.com/dashboards/4701&#34;&gt;ejemplo para Micrometer&lt;/a&gt; recoge la memoria de la JVM (&lt;em&gt;heap&lt;/em&gt; y no &lt;em&gt;heap&lt;/em&gt;), uso de CPU, carga, hilos, estado de hilos, descriptores de archivos, recolector de basura, &lt;em&gt;classloader&lt;/em&gt; y entrada/salida básica.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/12/monitorizar-una-aplicacion-java-de-spring-boot-con-micrometer-prometheus-y-grafana/images/grafana-spring-boot-micrometer-dashboard_hu1e421ff25cd5fbc7f190e3d824bd4790_201078_2560x1440_fit_box_2.png&#34; title=&#34;Estado de servicios en Prometheus&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/12/monitorizar-una-aplicacion-java-de-spring-boot-con-micrometer-prometheus-y-grafana/images/grafana-spring-boot-micrometer-dashboard_hu1e421ff25cd5fbc7f190e3d824bd4790_201078_600x450_fit_box_2.png&#34; width=&#34;600&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Dashboard de una aplicación Spring Boot en Grafana&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&#34;https://grafana.com/plugins&#34;&gt;Grafana tiene &lt;em&gt;plugins&lt;/em&gt;&lt;/a&gt; para añadir como fuentes de datos bases de datos relacionales para extraer mediante sentencias SQL y visualizar datos almacenados en &lt;a href=&#34;https://www.mysql.com/&#34;&gt;MySQL&lt;/a&gt;, &lt;a href=&#34;https://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt; u &lt;a href=&#34;https://www.oracle.com/&#34;&gt;Oracle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Con la información de las métricas se conoce más en detalle cual es el comportamiento normal de una aplicación y observar de forma rápida cuando se introducen cambios como afectan al comportamiento de la misma tanto de forma negativa como de forma positiva. En cualquier aplicación que ofrece un servicio es importante conocer su estado y actuar incluso antes de que ofrezca un mal comportamiento e incluso deje de prestar su servicio. La monitorización no sustituye sino que complementa un sistema de trazas que en una aplicación Java es común que se realice con &lt;a href=&#34;https://www.slf4j.org/&#34;&gt;SLF4J&lt;/a&gt; o &lt;a href=&#34;https://logging.apache.org/log4j/2.x/&#34;&gt;Log4j&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Aún quedan algunas preguntas por responder ¿como agregar los datos de múltiples instancias? ¿si se crean nuevas instancias del servicio como puede conocer Prometheus los nuevos &lt;em&gt;targets&lt;/em&gt; que se han creado? En el ejemplo solo hay una instancia del servicio y la configuración de Prometheus es proporcionada por un archivo estático. Aún desconozco las respuestas, no lo he investigado en detalle, hay alguna &lt;a href=&#34;https://stackoverflow.com/questions/46910839/is-it-possible-to-setup-prometheus-with-eureka-sd-without-file-sd-configs&#34;&gt;pregunta sobre este tema en StackOverflow&lt;/a&gt; y por la respuesta Prometheus no tiene un adaptador para Eureka entre los &lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/configuration/configuration/&#34;&gt;varios servicios de descubrimiento que sí soporta en su configuración&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew-run.sh, docker-compose up&lt;/code&gt;.
&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://njalnordmark.wordpress.com/2017/05/08/using-prometheus-with-spring-boot/&#34;&gt;Using Prometheus with Spring Boot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raymondhlee.wordpress.com/2016/09/24/monitoring-spring-boot-applications-with-prometheus/&#34;&gt;Monitoring Spring Boot Applications with Prometheus – Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raymondhlee.wordpress.com/2016/10/03/monitoring-spring-boot-applications-with-prometheus-part-2/&#34;&gt;Monitoring Spring Boot Applications with Prometheus – Part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.sebastian-daschner.com/entries/prometheus-java-ee&#34;&gt;Prometheus with Java EE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/prometheus/prometheus/pull/3369&#34;&gt;Add Eureka Service Discovery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/><category term="software"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/11/novedades-de-java-ee-8/</id><title>Novedades de Java EE 8</title><updated>2018-11-09T17:00:00+01:00</updated><published>2018-11-09T17:00:00+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/11/novedades-de-java-ee-8/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java-ee.png&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java EE&#34; title=&#34;Java EE&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;La &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/09/novedades-y-nuevas-caracteristicas-de-java-9-los-modulos/&#34;&gt;publicación de Java 9&lt;/a&gt; en agosto de 2017 con la importante novedad de los módulos ha hecho que la publicación de Java EE 8 haya pasado desapercibida. También ha contribuido el hecho de que &lt;a href=&#34;https://www.oracle.com/&#34;&gt;Oracle&lt;/a&gt; haya entregado el desarrollo de futuras nuevas especificaciones de Java EE a la &lt;a href=&#34;https://eclipse.org&#34;&gt;fundación Eclipse&lt;/a&gt; con el objetivo de que sea más abierto a otras empresas, Java EE a partir de ahora bajo la fundación Eclipse se denominará &lt;a href=&#34;https://jakarta.ee/&#34;&gt;Jakarta EE&lt;/a&gt;. Pasados algunos meses los servidores de aplicaciones ya están implementando las nuevas novedades de Java EE 8. Algunos de los servidores que ya soportan estas nuevas especificaciones y novedades son &lt;a href=&#34;http://wildfly.org/&#34;&gt;Wildfly&lt;/a&gt;, &lt;a href=&#34;https://www.payara.fish/&#34;&gt;Payara&lt;/a&gt; &lt;a href=&#34;https://ee.kumuluz.com/&#34;&gt;Kumuluz&lt;/a&gt; o &lt;a href=&#34;https://tomcat.apache.org/&#34;&gt;Tomcat&lt;/a&gt; 9.&lt;/p&gt;
&lt;p&gt;Hay algunas novedades de Java EE 8 entre ellas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java Servlet 4.0 API con soporte para el protocolo HTTP/2, incluido el soporte para enviar recursos desde el servidor sin que el cliente los haya pedido aún a través del método &lt;a href=&#34;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletRequest.html#newPushBuilder--&#34;&gt;newPushBuilder()&lt;/a&gt; de la clase &lt;a href=&#34;https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletRequest.html&#34;&gt;HttpServletRequest&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Soporte para JSON mejorado incluyendo una nueva API de &lt;em&gt;binding&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Eventos CDI asíncronos.&lt;/li&gt;
&lt;li&gt;Una nueva API de seguridad simple, estandarizada y modernizada.&lt;/li&gt;
&lt;li&gt;Soporte para las nuevas capacidades de Java 8 (pe. Date &amp;amp; Time API, Streams API, mejoras en las anotaciones).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El soporte para &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/introduccion-al-protocolo-http-2/&#34;&gt;HTTP/2 y sus importantes novedades&lt;/a&gt; hace que desde Java se puedan aprovechar las mejoras en la segunda versión del protocolo HTTP y se aprovechan las &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;novedades de Java 8&lt;/a&gt;. También en Java EE 8 se han actualizado de versión algunas de las especificaciones e incluido alguna nueva como la de la nueva API de seguridad que han de soportar los servidores de aplicaciones para ser compatibles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSR 366 – Java EE 8 Platform&lt;/li&gt;
&lt;li&gt;JSR 365 – Contexts and Dependency Injection (CDI) 2.0&lt;/li&gt;
&lt;li&gt;JSR 367 – The Java API for JSON Binding (JSON-B) 1.0&lt;/li&gt;
&lt;li&gt;JSR 369 – Java Servlet 4.0&lt;/li&gt;
&lt;li&gt;JSR 370 – Java API for RESTful Web Services (JAX-RS) 2.1&lt;/li&gt;
&lt;li&gt;JSR 372 – JavaServer Faces (JSF) 2.3&lt;/li&gt;
&lt;li&gt;JSR 374 – Java API for JSON Processing (JSON-P)1.1&lt;/li&gt;
&lt;li&gt;JSR 375 – Java EE Security API 1.0&lt;/li&gt;
&lt;li&gt;JSR 380 – Bean Validation 2.0&lt;/li&gt;
&lt;li&gt;JSR 250 – Common Annotations 1.3&lt;/li&gt;
&lt;li&gt;JSR 338 – Java Persistence 2.2&lt;/li&gt;
&lt;li&gt;JSR 356 – Java API for WebSocket 1.1&lt;/li&gt;
&lt;li&gt;JSR 919 – JavaMail 1.6&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hay un &lt;a href=&#34;https://javaee.github.io/tutorial/&#34;&gt;tutorial de Java EE 8&lt;/a&gt; y con el &lt;a href=&#34;https://javaee.github.io/firstcup/toc.html&#34;&gt;ejemplo FirstCup&lt;/a&gt; se puede adquirir un buen conocimiento para desarrollar aplicaciones con el lenguaje Java. En el artículo &lt;a href=&#34;https://www.ibm.com/developerworks/opensource/library/j-whats-new-in-javaee-8/index.html&#34;&gt;What&amp;rsquo;s new in Java EE 8&lt;/a&gt; hay unos pocos ejemplos de código con varias de estas novedades. Finalmente, con el traspaso de Java EE a la fundación Eclipse y por motivos de marca registrada el proyecto ha sido renombrado a Jakarta EE. Java EE o ahora Jakarta EE, &lt;a href=&#34;https://microprofile.io/&#34;&gt;Microprofile&lt;/a&gt; y &lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt; junto con algunos &lt;em&gt;frameworks&lt;/em&gt; especializados son las opciones más utilizadas para realizar aplicaciones en Java en el lado del servidor.&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oracle.com/technetwork/java/javaee/documentation/ee8-release-notes-3894362.html&#34;&gt;Java Platform, Enterprise Edition 8 SDK - Release Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/opensource/library/j-whats-new-in-javaee-8/index.html&#34;&gt;What&amp;rsquo;s new in Java EE 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.oracle.com/java/java-ee-8-overview&#34;&gt;Java EE 8 Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/java/javaee/overview/index.html&#34;&gt;Java™ EE at a Glance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://javaee.github.io/&#34;&gt;Java EE (GitHub)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://javaee.github.io/tutorial/&#34;&gt;Java EE Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://javaee.github.io/tutorial/toc.html&#34;&gt;Java EE Tutorial (Content)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://javaee.github.io/firstcup/toc.html&#34;&gt;Java EE Tutorial: Your First Cup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.com/news/2018/02/from-javaee-to-jakartaee&#34;&gt;From Java EE to Jakarta EE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/an-overview-of-cdi-events&#34;&gt;An Overview of CDI Events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#firing_events_asynchronously&#34;&gt;Firing CDI events asynchronously&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/11/formatear-con-color-sentencias-sql-o-codigo-fuente-en-la-terminal-con-java-y-jansi/</id><title>Formatear con color sentencias SQL o código fuente en la terminal con Java y Jansi</title><updated>2018-11-03T23:30:00+01:00</updated><published>2018-11-03T23:30:00+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/11/formatear-con-color-sentencias-sql-o-codigo-fuente-en-la-terminal-con-java-y-jansi/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Usando la librería &lt;a href=&#34;https://github.com/fusesource/jansi&#34;&gt;Jansi&lt;/a&gt; es posible &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2012/12/color-en-la-terminal-con-jansi.html&#34;&gt;hacer que un programa Java emita texto en color en la terminal&lt;/a&gt;. Emitir color en la terminal sirve para identificar más fácilmente y visualmente ciertas partes del texto, por ejemplo, emitiendo en rojo mensajes importantes o con color amarillo de fondo algún dato. Una utilidad práctica es formatear con color una sentencia SQL que se va a ejecutar en una aplicación a modo de traza o con colores el código fuente de un archivo Java u otro tipo de archivo de texto.&lt;/p&gt;
&lt;p&gt;Una forma sencilla para formatear con colores un archivo de código fuente Java o una sentencia SQL sin llegar a hacer un procesador de sintaxis de ese lenguaje o formato es &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/02/referencias-a-grupos-de-captura-en-expresiones-regulares-y-reemplazos/&#34;&gt;utilizar expresiones regulares y grupos de captura&lt;/a&gt;. En ambos casos hay partes que son palabras claves, números o cadenas en definitiva elementos que se deseen destacar. Con las clases &lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html&#34;&gt;Pattern&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Matcher.html&#34;&gt;Matcher&lt;/a&gt; de Java se van obteniendo los diferentes grupos de captura de forma secuencial. Según sea el grupo capturado del elemento actual se utiliza Jansi para formatearlo con el color que le corresponde.&lt;/p&gt;
&lt;p&gt;Una formateador simple para cada uno de estos casos serían los siguientes donde se utiliza una expresión regular con diferentes grupos de captura con nombre. El primer caso es para formatear con color una sentencia SQL sencilla en el método &lt;em&gt;printSql()&lt;/em&gt; y el segundo el programa &lt;em&gt;Hola mundo&lt;/em&gt; de Java en el metodo &lt;em&gt;printJava()&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8ae4fa95b210f181fe152536845793b0.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8ae4fa95b210f181fe152536845793b0.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;p&gt;El resultado en la terminal es el siguiente.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/11/formatear-con-color-sentencias-sql-o-codigo-fuente-en-la-terminal-con-java-y-jansi/images/JavaRegexFormatter_hu5342588446c87541df1bb78066482914_45391_2560x1440_fit_box_2.png&#34; title=&#34;Formateado de sentencia SQL y código Java&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/11/formatear-con-color-sentencias-sql-o-codigo-fuente-en-la-terminal-con-java-y-jansi/images/JavaRegexFormatter_hu5342588446c87541df1bb78066482914_45391_650x450_fit_box_2.png&#34; width=&#34;650&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Formateado de sentencia SQL y código Java&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Este ejemplo es una aplicación útil de las expresiones regulares. En este caso he usado Jansi para emitir en la terminal texto con color pero de forma similar esto se puede usar para formatear en una web el mismo texto transformándolo y generando el HTML con las clases CSS adecuadas.&lt;/p&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaRegexFormatter&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew installDist, ./build/install/JavaRegexFormatter/bin/JavaRegexFormatter&lt;/code&gt;.
&lt;/p&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/10/ejemplo-sencillo-de-como-leer-datos-de-un-archivo-excel-o-csv-en-java/</id><title>Ejemplo sencillo de cómo leer datos de un archivo Excel o CSV en Java</title><updated>2018-10-26T10:00:00+02:00</updated><published>2018-10-26T10:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/10/ejemplo-sencillo-de-como-leer-datos-de-un-archivo-excel-o-csv-en-java/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Los formatos de archivo de columnas separadas por comas o CSV y los documentos en formato de hojas de cálculo excel del paquete ofimático &lt;a href=&#34;https://products.office.com/es-es/home&#34;&gt;Microsoft Office&lt;/a&gt; son muy utilizados como formato de archivo para intercambiar datos entre aplicaciones o simplemente como contenedores de datos. Para leer los datos en estos formatos de archivos en Java hay que emplear alguna librería que facilite y entienda estos formatos de los archivos. Para leer los archivos CSV está la librería &lt;a href=&#34;http://opencsv.sourceforge.net/&#34;&gt;OpenCSV&lt;/a&gt; y para los archivos excel está la librería &lt;a href=&#34;https://poi.apache.org/&#34;&gt;Apache POI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Con Apache POI para acceder al archivo excel hay que usar unas pocas clases de su API como &lt;a href=&#34;https://poi.apache.org/apidocs/org/apache/poi/hssf/usermodel/HSSFWorkbook.html&#34;&gt;HSSFWorkbook&lt;/a&gt;, &lt;a href=&#34;https://poi.apache.org/apidocs/org/apache/poi/hssf/usermodel/HSSFSheet.html&#34;&gt;HSSFSheet&lt;/a&gt;, &lt;a href=&#34;https://poi.apache.org/apidocs/org/apache/poi/hssf/usermodel/HSSFRow.html&#34;&gt;HSSFRow&lt;/a&gt;, &lt;a href=&#34;https://poi.apache.org/apidocs/org/apache/poi/hssf/usermodel/HSSFCell.html&#34;&gt;HSSFCell&lt;/a&gt; y utilizar el método adecuado según el tipo de datos a obtener.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/d5beebdcaeecaf7a3750bdebb97ea628.js?file=Main-excel.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;Para el caso de los CSV hay que utilizar la clase &lt;a href=&#34;http://opencsv.sourceforge.net/apidocs/com/opencsv/CSVReader.html&#34;&gt;CSVReader&lt;/a&gt; que permite iterar sobre las líneas del archivo teniendo en cuenta el caracter separador de las columnas y las comillas de los datos. Para acceder a los valores de cada una de las columnas hay que convertir al tipo de datos deseado ya que siempre se devuelve un &lt;em&gt;String&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/d5beebdcaeecaf7a3750bdebb97ea628.js?file=Main-csv.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;En ambos casos la salida en la consola al leer los datos de los documentos es la misma.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/d5beebdcaeecaf7a3750bdebb97ea628.js?file=System.out&#34;&gt;&lt;/script&gt;
&lt;p&gt;Las dependencias a incluir en el proyecto son las siguientes.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/d5beebdcaeecaf7a3750bdebb97ea628.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;p&gt;También se puede &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/05/ejemplo-sencillo-de-como-crear-un-excel-o-csv-en-java-con-apache-poi-y-opencsv/&#34;&gt;utilizar Apache POI para crear hojas excel y OpenCSV para crear archivos CSV&lt;/a&gt; con las columnas correctamente separadas por comas. Otra alternativa para leer o escribir archivos en formato CSV es &lt;a href=&#34;https://commons.apache.org/proper/commons-csv/&#34;&gt;Apache Commons CSV&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/HolaMundoApachePOI&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/10/proxy-para-microservicios-con-spring-cloud-netflix-y-zuul/</id><title>Proxy para microservicios con Spring Cloud Netflix y Zuul</title><updated>2018-10-13T23:00:00+02:00</updated><published>2018-10-13T23:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/10/proxy-para-microservicios-con-spring-cloud-netflix-y-zuul/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Teniendo una buen número de microservicios con múltiples instancias ofreciendo cada uno una API y en una ubicación diferente para simplificar la visión de los que actúen clientes de los microservicios se puede utilizar un &lt;em&gt;proxy&lt;/em&gt;. Con un &lt;em&gt;proxy&lt;/em&gt; es posible centralizar todas las peticiones, que sea éste el encargado de conocer la ubicación de todas las instancias de los microservicios y de hacer la llamada allí donde se encuentre cada una de ellas.&lt;/p&gt;
&lt;p&gt;Entre las varias funcionalidades que proporcionar el proyecto &lt;a href=&#34;https://cloud.spring.io/spring-cloud-netflix/&#34;&gt;Spring Cloud Netflix&lt;/a&gt; es esta de &lt;em&gt;proxy&lt;/em&gt; mediante &lt;a href=&#34;https://github.com/Netflix/zuul&#34;&gt;Zuul&lt;/a&gt;. Para hacer de &lt;em&gt;proxy&lt;/em&gt; Zuul necesita tener una correspondencia entre URLs y servicios que realmente proporcionan la funcionalidad, una forma que tiene Zuul de conocer la ubicación de las instancias es utilizando el servicio de registro y descubrimiento &lt;a href=&#34;https://github.com/Netflix/eureka&#34;&gt;Eureka&lt;/a&gt;. Además, Zuul como cliente de los microservicios posee la funcionalidad de &lt;a href=&#34;https://github.com/Netflix/Hystrix&#34;&gt;Hystrix&lt;/a&gt; que implementa el patrón &lt;em&gt;circuit breaker&lt;/em&gt; para tolerancia a fallos, &lt;a href=&#34;https://github.com/Netflix/ribbon&#34;&gt;Ribbon&lt;/a&gt; para hacer balanceo de carga entre varias instancias de los microservicios a nivel de servidor además de reintentos cuando una instancia falla.&lt;/p&gt;
&lt;p&gt;En el ejemplo que he utilizado para esta &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/spring-cloud/&#34;&gt;serie de artículos sobre Spring Cloud&lt;/a&gt; hay un servicio que por defecto se inicia en el puerto &lt;em&gt;8080&lt;/em&gt; y ofrece un &lt;em&gt;endpoint&lt;/em&gt; &lt;em&gt;/&lt;/em&gt; que devuelve un mensaje. Para crear un microservicio &lt;em&gt;proxy&lt;/em&gt; con Zuul hay que crear una aplicación &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; anotar la clase principal con la anotación &lt;em&gt;@EnableZuulProxy&lt;/em&gt; y proporcionar la configuración para la correspondencia de rutas y microservicios, además de las propiedades para hacer reintentos en caso de que un microservicio falle y de &lt;em&gt;timeouts&lt;/em&gt; en caso de que se comporte no como se espera en cuanto tiempos de respuesta.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/9d29335938851c0bc8c16ed3daa02d97.js?file=Main%20%28zuul%29.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/9d29335938851c0bc8c16ed3daa02d97.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;p&gt;Se puede establecer un tiempo máximo para establecer la conexión, de tiempo de petición, el número de reintentos en la misma instancia si falla o en otro número de instancias, el número máximo de conexiones y el número máximo de conexiones al mismo &lt;em&gt;host&lt;/em&gt;. Todas ellas definibles en cada servicio de forma individual bajo las propiedades &lt;em&gt;hystrix.command.service&lt;/em&gt; y &lt;em&gt;service.ribbon&lt;/em&gt; donde &lt;em&gt;service&lt;/em&gt; es el identificativo del servicio. Las rutas se indican bajo la propiedad &lt;em&gt;zuul.routes&lt;/em&gt; con la relación identificativo del servicio y &lt;em&gt;path&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/9d29335938851c0bc8c16ed3daa02d97.js?file=proxy.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;Dado que Zuul es un &lt;em&gt;proxy&lt;/em&gt; para múltiples instancias de microservicios a cada microservicio hay que darle una ruta, cuando Zuul realiza la llamada a una instancia del microservicio se encarga de omitirla. En el ejemplo, la ruta en Zuul &lt;em&gt;/service/**&lt;/em&gt; está asociada al microservicio &lt;em&gt;service&lt;/em&gt; pero el servicio &lt;em&gt;service&lt;/em&gt; ofrece su &lt;em&gt;endpoint&lt;/em&gt; en &lt;em&gt;/&lt;/em&gt;, Zuul se encarga de omitir la parte de la ruta para el &lt;em&gt;proxy&lt;/em&gt; y hace la llamada a la ruta &lt;em&gt;/&lt;/em&gt; como espera el microservicio.&lt;/p&gt;
&lt;p&gt;Lógicamente los clientes deben contactar con el &lt;em&gt;proxy&lt;/em&gt; en vez de con el microservicio directamente. Arrancado el servicio de descubrimiento y registro Eureka, el servidor de configuración de Spring Cloud, dos instancias del servicio y el &lt;em&gt;proxy&lt;/em&gt; con Zuul haciendo las llamadas al &lt;em&gt;proxy&lt;/em&gt; se observa que se obtiene el resultado del microservicio. Como en el ejemplo hay varias instancias del servicio Zuul realiza balanceo de carga entre ellas con Ribbon utilizando la política &lt;em&gt;round-robin&lt;/em&gt; y el mensaje es diferente en cada una de las respuestas según la instancia invocada. Con Zuul además se consigue balanceo de carga a nivel de servidor que Ribbon solo ofrece a nivel de cliente.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/9d29335938851c0bc8c16ed3daa02d97.js?file=Main%20%28client%29.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/9d29335938851c0bc8c16ed3daa02d97.js?file=ProxyService.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/9d29335938851c0bc8c16ed3daa02d97.js?file=gradle-run.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Las URLs del servicio en el microservicio y en el &lt;em&gt;proxy&lt;/em&gt; son.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/9d29335938851c0bc8c16ed3daa02d97.js?file=curl.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;El cliente de ejemplo realiza peticiones al &lt;em&gt;proxy&lt;/em&gt;, en la salida se muestra el resultado del balanceo de carga cuando hay varias instancias, cuando se añade una nueva instancia entra a formar parte del balanceo de carga. Otro beneficio de Zuul es que ofrece la funcionalidad de reintentos de modo que si una instancia de un servicio falla la petición se reintenta en otra. En el artículo &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/10/balanceo-de-carga-y-resilencia-en-un-microservicio-con-spring-cloud-netflix-y-ribbon/&#34;&gt;Balanceo de carga y resilencia en un microservicio con Spring Cloud Netflix y Ribbon&lt;/a&gt; usando solo Ribbon se observaba que cuando una instancia falla se le siguen haciendo peticiones hasta que la lista de instancias del servicio en Eureka se actualiza quitando la fallida, con Hystrix se obtiene la respuesta &lt;em&gt;fallback&lt;/em&gt; pero no se evita completamente el error. Zuul puede ocultar el error provocado por una instancia que falla reintentado la petición en la misma nuevamente, en otra u otras instancias según se configure. El comportamiento con Zuul cuando una instancia falla se puede comparar con el comportamiento incluido en el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/10/balanceo-de-carga-y-resilencia-en-un-microservicio-con-spring-cloud-netflix-y-ribbon/&#34;&gt;artículo anterior usando en el cliente los microservicios directamente&lt;/a&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/9d29335938851c0bc8c16ed3daa02d97.js?file=System.out&#34;&gt;&lt;/script&gt;
&lt;p&gt;Zuul además es capaz de proporciona otras muchas funcionalidades como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Autenticación&lt;/li&gt;
&lt;li&gt;Seguridad&lt;/li&gt;
&lt;li&gt;Recolección de métricas y monitorización&lt;/li&gt;
&lt;li&gt;Pruebas de carga&lt;/li&gt;
&lt;li&gt;Pruebas de verificación o &lt;em&gt;canary testing&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Enrutado dinámico&lt;/li&gt;
&lt;li&gt;Migración de servicio&lt;/li&gt;
&lt;li&gt;Abandono de carga o &lt;em&gt;load shedding&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Manejo de respuesta estática&lt;/li&gt;
&lt;li&gt;Gestión de tráfico active/active&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew-run.sh&lt;/code&gt;.
&lt;/p&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/10/balanceo-de-carga-y-resilencia-en-un-microservicio-con-spring-cloud-netflix-y-ribbon/</id><title>Balanceo de carga y resilencia en un microservicio con Spring Cloud Netflix y Ribbon</title><updated>2018-10-12T20:46:00+02:00</updated><published>2018-10-12T11:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/10/balanceo-de-carga-y-resilencia-en-un-microservicio-con-spring-cloud-netflix-y-ribbon/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Un servicio que recibe numerosas peticiones o es crítico para el funcionamiento de una aplicación es necesario escalarlo o crear múltiples instancias de él para atender toda la carga que se demanda o para que en caso de que una instancia falle haya otras disponibles que funcionen correctamente para atender las peticiones.&lt;/p&gt;
&lt;p&gt;En este entorno de múltiples instancias se hace necesario un servicio de registro y descubrimiento que usando &lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt;, &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; y &lt;a href=&#34;https://cloud.spring.io/spring-cloud-netflix/&#34;&gt;Spring Cloud Netflix&lt;/a&gt; una implementación es &lt;a href=&#34;https://github.com/Netflix/eureka&#34;&gt;Eureka&lt;/a&gt;. Una vez descubiertas las instancias que hay del servicio es necesario hacer balanceo de carga para conseguir escalabilidad y tolerancia a fallos, en el mismo proyecto de Spring Cloud Netflix para realizar balanceo de carga en el cliente se ofrece &lt;a href=&#34;https://github.com/Netflix/ribbon&#34;&gt;Ribbon&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Hay varias formas de usar Ribbon una de ellas es con lo que denominan &lt;em&gt;feign client&lt;/em&gt;, con &lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html&#34;&gt;Spring RestTemplate&lt;/a&gt; o directamente con &lt;em&gt;LoadBalancerClient&lt;/em&gt; que es la que muestro en este artículo. Este cliente con Ribbon obtiene del servicio de registro y descubrimiento la lista inicial de instancias de un servicios registrado con sus ubicaciones siendo el &lt;em&gt;host&lt;/em&gt; en el que se encuentran y el puerto en el que ofrecen su servicio. Con esta lista y el estado de los servicios se realiza el balanceo de carga. Sin embargo, dada la naturaleza de los microservicios se pueden añadir con posterioridad más instancias de un servicio o algunas pueden empezar fallar, Ribbon se encarga de mantener actualizada la lista de instancias de un servicio.&lt;/p&gt;
&lt;p&gt;Combinado con &lt;a href=&#34;https://github.com/Netflix/Hystrix&#34;&gt;Hystrix&lt;/a&gt; un ejemplo de cliente que hace peticiones a un servicio es el siguiente. Para demostrar su funcionamiento el cliente realiza varias llamadas a un servicio cada unos pocos milisegundos balanceando la carga entre las instancias que existan. Si con posterioridad se añade una nueva instancia del servicio Ribbon al cabo de un tiempo de que haya sido iniciada lo añadirá a la lista y empieza a seleccionarla para enviarle peticiones. Si una instancia falla hasta que Eureka no marca la instancia como fuera de servicio y el cliente no actualiza su lista de instancias en el ejemplo de cliente seguirá enviando peticiones a la instancia fuera de servicio y con Hystrix utilizando el método de &lt;em&gt;fallback&lt;/em&gt; como respuesta.&lt;/p&gt;
&lt;p&gt;Ante el fallo de una instancia para evitar que temporalmente el cliente empiece a fallar cuando le redirige una petición este puede reintentar las peticiones en otra instancia, esta funcionalidad se proporciona con &lt;a href=&#34;https://github.com/spring-projects/spring-retry&#34;&gt;Spring Retry&lt;/a&gt; o utilizando &lt;a href=&#34;https://github.com/Netflix/zuul&#34;&gt;Zuul&lt;/a&gt; como &lt;em&gt;proxy&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;El cliente usa la clase &lt;em&gt;LoadBalancerClient&lt;/em&gt; que en cada invocación del método &lt;em&gt;choose()&lt;/em&gt; devuelve una instancia diferente de servicio realizando balanceo de carga utilizando el método &lt;em&gt;round-robin&lt;/em&gt;. La clase &lt;em&gt;ServiceInstance&lt;/em&gt; proporciona la URL de la instancia del servicio.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/25fdce50a2a025a9c189c36af60dfc7d.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/25fdce50a2a025a9c189c36af60dfc7d.js?file=ClientService.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/25fdce50a2a025a9c189c36af60dfc7d.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;p&gt;La clase del servicio y los comandos para iniciar el servicio de registro y descubrimiento, el servicio de configuración, las instancias del servicio en diferentes puertos y el cliente.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/25fdce50a2a025a9c189c36af60dfc7d.js?file=DefaultController.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/25fdce50a2a025a9c189c36af60dfc7d.js?file=gradle-run.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Esta es la salida y funcionamiento del cliente realizando balanceado la carga entre las mútiples instancias y que ocurre cuando se añade una nueva o una empieza a fallar y se elimina de la lista.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/25fdce50a2a025a9c189c36af60dfc7d.js?file=System.out&#34;&gt;&lt;/script&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java&#34;&gt;Ribbon posee numerosas propiedades de configuración&lt;/a&gt; a nivel global para todos los clientes de servicios o de forma específica para cada servicio ya sea con la anotación &lt;em&gt;@RibbonClient&lt;/em&gt; o mediante la configuración en archivos externos de Spring Boot. Algunas propiedades de configuración interesantes son las de &lt;em&gt;timeout&lt;/em&gt; que permiten que un cliente no agote sus recursos esperando a que a los servicios que llama si tardan en responder y a su vez el cliente actuando de servidor recibe muchas llamadas de sus clientes. En un comando de Hystrix también se puede especificar un &lt;em&gt;timeout&lt;/em&gt; de modo que si se realizan reintentos el tiempo total para Hystrix deberá ser superior que el tiempo total de todos los posibles reintentos teniendo en cuenta el &lt;em&gt;timeout&lt;/em&gt; del cliente con Ribbon. Unsando el cliente HTTP &lt;a href=&#34;https://jersey.java.net/&#34;&gt;Jersey&lt;/a&gt; como en este caso también pueden establecerse &lt;a href=&#34;https://jersey.github.io/apidocs/1.19.1/jersey/com/sun/jersey/api/client/Client.html&#34;&gt;&lt;em&gt;timeouts&lt;/em&gt; para una petición&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;El balanceo de carga que con Ribbon se realiza en el cliente es más sencillo que realizar el balanceo de carga en el servidor ya que no requiere una pieza más en la infraestructura pero requiere que el cliente tenga algo de lógica para hacer el balanceo de carga.&lt;/p&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradle-run.sh&lt;/code&gt;.
&lt;/p&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/</id><title>Tolerancia a fallos en un cliente de microservicio con Spring Cloud Netflix y Hystrix</title><updated>2018-10-06T21:30:00+02:00</updated><published>2018-10-05T20:30:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Los microservicios son independientes unos de otros y se comunican mediante operaciones de red. Dado que las operaciones se realizan a través de un medio no confiable como la red, dada su naturaleza efímera y a que pueden fallar en los microservicios es importante que los clientes estén preparados ante posibles fallos.&lt;/p&gt;
&lt;p&gt;Un patrón o técnica que se suele emplear es el de &lt;a href=&#34;https://www.martinfowler.com/bliki/CircuitBreaker.html&#34;&gt;Circuit Breaker&lt;/a&gt;, en Java y con &lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt; se ofrece en el proyecto &lt;a href=&#34;https://cloud.spring.io/spring-cloud-netflix/&#34;&gt;Spring Cloud Netflix&lt;/a&gt; mediante &lt;a href=&#34;https://github.com/Netflix/Hystrix&#34;&gt;Hystrix&lt;/a&gt; y &lt;a href=&#34;https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica&#34;&gt;Javanica&lt;/a&gt;. Este patrón soluciona dos problemas cuando un microservicio del que se depende falla y hace al microservicio que lo usa tolerante a fallos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uno es que cuando un microservicio empieza a fallar es necesario dejar de hacerle peticiones para permitirle recuperarse si está saturado que provoca esos fallos. Cuando ocurre un fallo es posible realizar una acción en sustitución de la llamada al microservicio y devolver un valor alternativo como medida paliativa y hacer que el microsevicio afectado tenga la posibilidad de seguir ofreciendo su servicio aunque sea de forma degradada.&lt;/li&gt;
&lt;li&gt;Otro problema es que el microservicio aunque no falle tarde demasiado en responder, se puede establecer un &lt;em&gt;timeout&lt;/em&gt; que si se supera se deja de esperar e igualmente se realiza la acción de sustitución lo que evita que los microservicios que usan uno que tarda demasiado en responder agoten sus recursos y empiecen a fallar o tardar demasiado también.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En ambos casos se evita que la cadena de microservicios empiece a fallar y con ello sistema completo.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/hystrix_hub9140d7d7b18b1dc3937691a78958e9a_86330_650x450_fit_box_2.png&#34; width=&#34;640&#34; class=&#34;&#34; alt=&#34;Hystrix&#34; title=&#34;Hystrix&#34;/&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;El patrón &lt;em&gt;circuit breaker&lt;/em&gt; se denomina así ya que implementa una lógica similar a un circuito eléctrico. El circuito en su estado normal está cerrado y se realizan las llamadas al microservicio servidor. Si el microservicio servidor empieza a fallar se llama a la acción alternativa con su valor, si se supera un umbral de errores el circuito pasa a estado abierto y se dejan de hacer llamadas al microservicio servidor. Cada cierto tiempo definido se realiza una llamada al servicio servidor para comprobar su estado de forma que si responde correctamente el circuito pasa a estado cerrado nuevamente y las siguientes llamadas se realizan al microservicio servidor dejándose de utilizar la acción alternativa.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/circuit-breaker-diagram_hu4845d342695fc4ba4f8fa8d72c767f7b_90482_2560x1440_fit_box_2.png&#34; title=&#34;Diagrama del patrón circuit breaker&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/circuit-breaker-diagram_hu4845d342695fc4ba4f8fa8d72c767f7b_90482_300x200_fit_box_2.png&#34; width=&#34;126&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/circuit-breaker-states_hu56e2a01b6636c9453b9193ae50db8c8e_29040_2560x1440_fit_box_2.png&#34; title=&#34;Diagrama de estados&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/circuit-breaker-states_hu56e2a01b6636c9453b9193ae50db8c8e_29040_300x200_fit_box_2.png&#34; width=&#34;221&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/hystrix-fallback_hu341ff0d18f5e14bb81f44a2d6d1769ba_44880_2560x1440_fit_box_2.png&#34; title=&#34;Fallback del patrón circuit breaker&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/hystrix-fallback_hu341ff0d18f5e14bb81f44a2d6d1769ba_44880_300x200_fit_box_2.png&#34; width=&#34;300&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Diagrama del patrón circuit breaker, de estados y método fallback&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Para utilizar Hystrix como implementación del patrón &lt;em&gt;circuit breaker&lt;/em&gt; en una aplicación Java con &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; el método que realiza la llamada al microservicio servidor ha de encapsularse en un método anotado con la anotación &lt;a href=&#34;https://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/HystrixCommand.html&#34;&gt;@HystrixCommand&lt;/a&gt;, como parámetro se indica un método con la acción alternativa o &lt;em&gt;fallback&lt;/em&gt; que obtiene un valor en los fallos. También se puede indicar el &lt;em&gt;tiemout&lt;/em&gt; de espera antes de considerar que la llamada ha fallado con la propiedad &lt;em&gt;execution.isolation.thread.timeoutInMilliseconds&lt;/em&gt;. Igualmente se pueden indicar los valores para abrir el circuito con &lt;em&gt;circuitBreaker.requestVolumeThreshold&lt;/em&gt; y &lt;em&gt;circuitBreaker.errorThresholdPercentage&lt;/em&gt;. Esos son los básicos para utilizar este patrón de tolerancia a fallos. Tiene &lt;a href=&#34;https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration&#34;&gt;algunos valores adicionales más que se pueden configurar&lt;/a&gt; para adaptar el patrón a los valores óptimos de la aplicación.&lt;/p&gt;
&lt;p&gt;En el ejemplo el cliente en un bucle realiza las llamadas al servicio con un método &lt;em&gt;get()&lt;/em&gt; anotado con &lt;em&gt;@HystrixCommand&lt;/em&gt;. En este método se encapsula la petición HTTP que puede fallar, utilizando la librería &lt;a href=&#34;https://jersey.java.net/&#34;&gt;Jersey&lt;/a&gt; y obtenida la ubicación de una instancia del servicio a su vez del servicio de registro y descubrimiento &lt;a href=&#34;https://github.com/Netflix/eureka&#34;&gt;Eureka&lt;/a&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/7d1de9a669612dce06d3a5a35e4831d7.js?file=ClientService.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/7d1de9a669612dce06d3a5a35e4831d7.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/7d1de9a669612dce06d3a5a35e4831d7.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;p&gt;El circuito se abre cuando el número de llamadas supera un umbral y un porcentaje de fallos, se han de cumplir las dos condiciones. Si el número de llamadas que se realizan no superan el umbral aunque todas fallen el circuito permanece cerrado. Ambos valores son personalizables con las propiedades &lt;em&gt;circuitBreaker.requestVolumeThreshold&lt;/em&gt; y &lt;em&gt;circuitBreaker.errorThresholdPercentage&lt;/em&gt;. El circuito permanece abierto al menos durante el tiempo indicado por &lt;em&gt;metrics.rollingStats.timeInMilliseconds&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/7d1de9a669612dce06d3a5a35e4831d7.js?file=DefaultController.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;En la aplicación ejemplo hay un microservicio servidor y un microservicio cliente, iniciada una instancia de microservicio servidor y una instancia del microservicio cliente que implementa el patrón &lt;em&gt;circuit breaker&lt;/em&gt; inicialmente las peticiones se realizarán correctamente si no ocurre un &lt;em&gt;timeout&lt;/em&gt;. Si se finaliza el proceso del microservicio servidor las peticiones del cliente al servidor empezarán a fallar y este obtiene el valor alternativo del método &lt;em&gt;fallback&lt;/em&gt;, si se supera el umbral de llamadas y de fallos el circuito pasa a estado abierto. Mientras el circuito permanezca abierto el cliente sondea con una petición cada cierto tiempo el estado del servidor, si el servicio servidor se inicia unos instantes después de que esté disponible el cliente con la petición de sondeo comprobará que el servidor funciona, se cerrará el circuito y el cliente empezará a obtener los valores devueltos por el microservicio servidor.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/7d1de9a669612dce06d3a5a35e4831d7.js?file=System.out&#34;&gt;&lt;/script&gt;
&lt;p&gt;Para monitorizar en tiempo real el estado del sistema y de los circuitos se ofrece un &lt;em&gt;dashboard&lt;/em&gt; en el que visualizan el número de peticiones que se están realizando, las fallidas, el estado de los circuitos, las que fallan por &lt;em&gt;timeout&lt;/em&gt; o las que fallan con error. Para tener acceso a esta página hay que incluir la dependencia &lt;em&gt;org.springframework.cloud:spring-cloud-starter-netflix-hystrix-dashboard&lt;/em&gt;. La página &lt;em&gt;dashboard&lt;/em&gt; está disponible en la dirección &lt;em&gt;http://localhost:8085/hystrix&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/circuit-breaker-closed_huce59696db4bb781bd0e709b415bf52e8_382684_2560x1440_fit_box_2.png&#34; title=&#34;Circuit breaker cerrado&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/circuit-breaker-closed_huce59696db4bb781bd0e709b415bf52e8_382684_300x200_fit_box_2.png&#34; width=&#34;300&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/circuit-breaker-open_huce59696db4bb781bd0e709b415bf52e8_384418_2560x1440_fit_box_2.png&#34; title=&#34;Circuit breaker abierto&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/10/tolerancia-a-fallos-en-un-cliente-de-microservicio-con-spring-cloud-netflix-y-hystrix/images/circuit-breaker-open_huce59696db4bb781bd0e709b415bf52e8_384418_300x200_fit_box_2.png&#34; width=&#34;300&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Estados del circuit breaker&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;El proyecto &lt;a href=&#34;https://dzone.com/articles/resilience4j-and-sentinel-two-open-source-alternat&#34;&gt;Hystrix ha dejado de desarrollarse de forma activa&lt;/a&gt; tal como aparece en el propcio &lt;a href=&#34;https://github.com/Netflix/Hystrix/blob/master/README.md&#34;&gt;README.md&lt;/a&gt; y como alternativa se recomienda usar &lt;a href=&#34;https://github.com/resilience4j/resilience4j&#34;&gt;Resilience4j&lt;/a&gt; que además está diseñado para Java 8 y la programacion funcional.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/7d1de9a669612dce06d3a5a35e4831d7.js?file=gradle-run.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradle-run.sh&lt;/code&gt;.
&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.martinfowler.com/bliki/CircuitBreaker.html&#34;&gt;CircuitBreaker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.0.1.RELEASE/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients&#34;&gt;Circuit Breaker: Hystrix Clients&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration&#34;&gt;Hyxtrix Configuration (1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/Hystrix/wiki/Configuration&#34;&gt;Hyxtrix Configuration (2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javamagazine.mozaicreader.com/SeptemberOctober2018/Twitter&#34;&gt;Java Magazine Sep/Oct 2018&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/09/almacenar-cifrados-los-valores-de-configuracion-sensibles-en-spring-cloud-config/</id><title>Almacenar cifrados los valores de configuración sensibles en Spring Cloud Config</title><updated>2018-09-30T01:40:00+02:00</updated><published>2018-09-30T01:30:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/09/almacenar-cifrados-los-valores-de-configuracion-sensibles-en-spring-cloud-config/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Para no tener que hacer cambios en el código que implica recompilar la aplicación y generar de nuevos los artefactos al cambiar algunos valores de la aplicación se utilizan los archivos de configuración. Los archivos de configuración son archivos de texto plano que pueden seguir algún formato como &lt;em&gt;properties&lt;/em&gt;, &lt;em&gt;xml&lt;/em&gt; o &lt;em&gt;yaml&lt;/em&gt;, externos a la aplicación pero que lee sus propiedades al iniciarse. Algunas propiedades de configuración de ejemplo pueden ser la cadena de conexión a una base de datos, el usuario y contraseña.&lt;/p&gt;
&lt;p&gt;Dado que algunos valores de configuración son sensibles como en el ejemplo anterior la cadena de conexión, usuario y contraseña es recomendable por mayor seguridad almacenar estos valores cifrados y que la aplicación los descifre con la clave correspondiente al necesitar su valor original.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.spring.io/spring-cloud-config/&#34;&gt;Spring Cloud Config&lt;/a&gt; permite guardar los archivos de configuración con algunos valores cifrados. Hay varias posibilidades de configuración para guardar los datos cifrados: mediante clave simétrica, clave privada-pública, guardarlos en el servicio externo &lt;a href=&#34;https://www.vaultproject.io/&#34;&gt;Vault&lt;/a&gt; de [Hasicorp][hasicorp], mantenerlos cifrados solo en el almacenamiento persistente o transmitirlos cifrados y que sea el cliente el que los descifre.&lt;/p&gt;
&lt;p&gt;Utilizando la forma más simple para mantener los datos cifrados con una clave simétrica en el servicio de configuración hay que mantener en una propiedad de configuración la clave simétrica para cifrar y descifrar los datos, &lt;em&gt;encrypt.key&lt;/em&gt;. En este ejemplo la clave simétrica y las propiedades cifradas están en archivos de configuración diferentes pero incluidos en el mismo servidor de configuración. Esto no parece que aporte mucha seguridad ya que si se tiene acceso al archivo de configuración de un servicio con una propiedad cifrada probablemente se tenga acceso al archivo con la clave cifrada y la medida de seguridad no es útil. Sin embargo, esto permite al estar separados los archivos de configuración añadir el archivo con la propiedad cifrada a un repositorio público sin peligro siempre y cuando la clave de cifrado se mantenga en secreto. Los archivos de configuración de los servicios en el servidor de configuración se podrían añadir a un repositorio de Git.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/caccab2d4558ec75babab6ef71808f37.js?file=bootstrap.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;Definida la clave simétrica e iniciado el servidor de configuración este ofrece dos &lt;em&gt;endpoints&lt;/em&gt; para cifrar y descifrar datos. Utilizando el de cifrado se obtiene el valor cifrado del dato sensible que se quiere proteger. Con el &lt;em&gt;endpoint&lt;/em&gt; de descifrado se puede descifrar. Se observa que utilizando varias veces el &lt;em&gt;endpoint&lt;/em&gt; de cifrado se devuelve en cada una un valor distinto, sin embargo, descifrando cada uno de estos valores con el &lt;em&gt;endpoint&lt;/em&gt; de descifrado siempre se obtiene el valor original. Esto es debido seguramente a que en la operación de cifrado se utiliza la técnica del &lt;em&gt;salt&lt;/em&gt; para que a los valores cifrados se les pueda aplicar un ataque de diccionario, el &lt;em&gt;salt&lt;/em&gt; es incluido en el valor devuelto para que la operación de descifrado devuelva el valor original.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/caccab2d4558ec75babab6ef71808f37.js?file=curl-1.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;El valor cifrado obtenido por este &lt;em&gt;endpoint&lt;/em&gt; se puede guardar en los archivos de configuración entrecomillándolo y precediéndolo con la cadena &lt;em&gt;{cipher}&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/caccab2d4558ec75babab6ef71808f37.js?file=client.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;En este caso el servicio al iniciarse obtiene su configuración del servicio de configuración, los datos se transmiten en forma plana sin cifrar y el cifrado utilizando en el servidor de configuración es transparente para el cliente. Accediendo al &lt;em&gt;endpoint&lt;/em&gt; del servidor de configuración que devuelve la configuración de un servicio con una propiedad cifrada se observa que al obtener el valor se devuelve en texto plano al cliente, esta petición es la misma que hace el servicio para obtener su configuración, de modo que aunque la información está cifrada en el servidor de configuración se transmite al servicio sin cifrar en texto plano. En este ejemplo se utiliza el protocolo inseguro HTTP, lo recomendable es utilizar el protocolo HTTPS para cifrar el tráfico entre el servidor de configuración y el cliente de modo que los valores sensibles queden protegidos también en la transmisión.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/caccab2d4558ec75babab6ef71808f37.js?file=curl-2.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Iniciado el servicio de descubrimiento, el de configuración y un servicio que tiene un dato cifrado de configuración el valor que obtiene está ya descifrado. En este caso el servicio &lt;em&gt;client&lt;/em&gt; obtiene el valor de la propiedad &lt;em&gt;config.password&lt;/em&gt; descifrado con el valor &lt;em&gt;secret&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/caccab2d4558ec75babab6ef71808f37.js?file=gradlew-run.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/caccab2d4558ec75babab6ef71808f37.js?file=System.out&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/caccab2d4558ec75babab6ef71808f37.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/caccab2d4558ec75babab6ef71808f37.js?file=DefaultConfiguration.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradle-run.sh, ./curl-1.sh&lt;/code&gt;.
&lt;/p&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/09/novedades-y-nuevas-caracteristicas-de-java-11/</id><title>Novedades y nuevas características de Java 11</title><updated>2018-09-29T14:00:00+02:00</updated><published>2018-09-28T21:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/09/novedades-y-nuevas-caracteristicas-de-java-11/"/><author><name>picodotdev</name></author><content type="html">
&lt;p&gt;&lt;strong&gt;Java 11 es la primera versión de soporte extendido publicada o LTS bajo el nuevo ciclo de publicaciones que adoptó Java en la versión 9. Añade varias novedades importantes en cuanto a seguridad y elimina otras que en versiones anteriores ya fueron marcadas como desaconsejadas.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;En la plataforma Java era habitual que entre versión y versión mayor pasasen varios años normalmente 3 o más. Este ciclo de publicaciones no se adapta a las necesidades de todas las empresas, organizaciones y usuarios. Algunas empresas y usuarios desean ciclos de publicaciones más cortos quizá con no tantas novedades en cada uno de ellos pero sí de forma más constante incorporando mejoras. Otras organizaciones necesitan confiar en una versión que tenga un ciclo de soporte largo para sus aplicaciones.&lt;/p&gt;
&lt;p&gt;Para adaptarse a ambos requerimientos Java a partir de Java 9 adoptó un nuevo ciclo de publicaciones siendo cada seis meses para los que desean mejoras de forma regular y cada tres años para los que necesitan soporte extendido. &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/09/novedades-de-java-9-mas-alla-de-la-modularidad/&#34;&gt;Java 9 incorporó la esperada modularización&lt;/a&gt; que cambia la forma de desarrollo de las aplicaciones con numerosas mejoras. &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/03/novedades-de-java-10/&#34;&gt;Java 10 añadío la inferencia de tipos para variables locales&lt;/a&gt; con la palabra reservada &lt;em&gt;var&lt;/em&gt;. Ahora Java 11 siendo una versión de soporte extendido o LTS, el soporte de Java 11 está planificado que dure hasta 2023 y hasta 2026 de forma extendida lo que son 8 años de soporte.&lt;/p&gt;
&lt;p&gt;En esta nueva versión de Java 11 publicada el 25 de septiembre de 2018 las novedades no son tan relevantes como lo fuero Java 8 con las &lt;em&gt;lambadas&lt;/em&gt; y Java 9 con los módulos pero continúa con las mejoras incrementales y proporciona una versión LTS en la que empresas grandes confiarán como base para sus desarrollos.&lt;/p&gt;
&lt;p&gt;La lista más relevante de &lt;a href=&#34;http://openjdk.java.net/projects/jdk/11/&#34;&gt;novedades de Java 11&lt;/a&gt; es la siguiente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;181: &lt;a href=&#34;http://openjdk.java.net/jeps/181&#34;&gt;Nest-Based Access Control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;309: &lt;a href=&#34;http://openjdk.java.net/jeps/309&#34;&gt;Dynamic Class-File Constants&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;315: &lt;a href=&#34;http://openjdk.java.net/jeps/315&#34;&gt;Improve Aarch64 Intrinsics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;318: &lt;a href=&#34;http://openjdk.java.net/jeps/318&#34;&gt;Epsilon: A No-Op Garbage Collector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;320: &lt;a href=&#34;http://openjdk.java.net/jeps/320&#34;&gt;Remove the Java EE and CORBA Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;321: &lt;a href=&#34;http://openjdk.java.net/jeps/321&#34;&gt;HTTP Client (Standard)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;323: &lt;a href=&#34;http://openjdk.java.net/jeps/323&#34;&gt;Local-Variable Syntax for Lambda Parameters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;324: &lt;a href=&#34;http://openjdk.java.net/jeps/324&#34;&gt;Key Agreement with Curve25519 and Curve448&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;327: &lt;a href=&#34;http://openjdk.java.net/jeps/327&#34;&gt;Unicode 10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;328: &lt;a href=&#34;http://openjdk.java.net/jeps/328&#34;&gt;Flight Recorder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;329: &lt;a href=&#34;http://openjdk.java.net/jeps/329&#34;&gt;ChaCha20 and Poly1305 Cryptographic Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;330: &lt;a href=&#34;http://openjdk.java.net/jeps/330&#34;&gt;Launch Single-File Source-Code Programs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;331: &lt;a href=&#34;http://openjdk.java.net/jeps/331&#34;&gt;Low-Overhead Heap Profiling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;332: &lt;a href=&#34;http://openjdk.java.net/jeps/332&#34;&gt;Transport Layer Security (TLS) 1.3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;333: &lt;a href=&#34;http://openjdk.java.net/jeps/333&#34;&gt;ZGC: A Scalable Low-Latency Garbage Collector (Experimental)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;335: &lt;a href=&#34;http://openjdk.java.net/jeps/335&#34;&gt;Deprecate the Nashorn JavaScript Engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;336: &lt;a href=&#34;http://openjdk.java.net/jeps/336&#34;&gt;Deprecate the Pack200 Tools and API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;eliminación-de-módulos-java-ee-y-corba&#34;&gt;Eliminación de módulos Java EE y CORBA&lt;/h3&gt;
&lt;p&gt;Se eliminan del JDK paquetes ya desaconsejados hace varias versiones anteriores y que no eran muy usados en cualquier caso. Estos paquetes son los de CORBA una forma de llamada a procedimientos remotos que se utilizó como alternativa a RMI pero que nunca tuvo un uso extendido prefiriéndose SOAP o más recientemente interfaces REST.&lt;/p&gt;
&lt;p&gt;La lista de paquetes eliminados son los siguientes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;java.xml.ws&lt;/em&gt; (JAX-WS, plus the related technologies SAAJ and Web Services Metadata)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;java.xml.bind&lt;/em&gt; (JAXB)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;java.activation&lt;/em&gt; (JAF)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;java.xml.ws.annotation&lt;/em&gt; (Common Annotations)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;java.corba&lt;/em&gt; (CORBA)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;java.transaction&lt;/em&gt; (JTA)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;java.se.ee&lt;/em&gt; (Aggregator module for the six modules above)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;jdk.xml.ws&lt;/em&gt; (Tools for JAX-WS)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;jdk.xml.bind&lt;/em&gt; (Tools for JAXB)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sintaxis-de-variables-locales-para-parámetros-en-lambdas&#34;&gt;Sintaxis de variables locales para parámetros en lambdas&lt;/h3&gt;
&lt;p&gt;Ahora los parámetros de una lambda pueden declararse con &lt;em&gt;var&lt;/em&gt; con inferencia de tipos. Esto proporciona uniformidad en el lenguaje al declarar los parámetros permite usar anotaciones en los parámetros de la función lambda como &lt;em&gt;@NotNull&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Esta funcionalidad tiene algunas restricciones. No se puede mezclar el uso y no uso de &lt;em&gt;var&lt;/em&gt; y no se puede mezclar el uso de &lt;em&gt;var&lt;/em&gt; y tipos en &lt;em&gt;lambdas&lt;/em&gt; explícitas. Son consideradas ilegales por el compilador y producirá un error en tiempo de compilación.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4ffa2721e4d7a3487ff8ff048a7f98fd.js?file=Lambda.java&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/0eWgRyanQI0?rel=0&#34; frameborder=&#34;0&#34; allow=&#34;autoplay; encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;h3 id=&#34;cliente-http&#34;&gt;Cliente HTTP&lt;/h3&gt;
&lt;p&gt;En Java 9 se incorporó de forma experimental un cliente HTTP con soporte para HTTP/2 en el propio JDK. En Java 11 alcanza la categoría de estable. Este cliente HTTP es una forma sencilla de hacer llamadas a servicios web ya sean REST o &lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt;. Las clases del nuevo cliente se encuentran en el paquete &lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/package-summary.html&#34;&gt;java.net.http&lt;/a&gt;. Al estar este cliente HTTP incorporado en el JDK no será necesario depender de librerías de terceros.&lt;/p&gt;
&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/sZSdWq490Vw?rel=0&#34; frameborder=&#34;0&#34; allow=&#34;autoplay; encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;h3 id=&#34;ejecución-desde-archivo-de-código-fuente-único&#34;&gt;Ejecución desde archivo de código fuente único&lt;/h3&gt;
&lt;p&gt;Para ejecutar un programa Java es necesario compilarlo a &lt;em&gt;bytecode&lt;/em&gt; y posteriormente ejecutarlos. Se necesitan dos pasos. Para facilitar la ejecución de los programas que se componen de un único archivo de código fuente se añade la posibilidad de lanzar un programa desde el archivo de código fuente. Esto es útil par programas pequeños o para los casos de estar aprendiendo el lenguaje.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4ffa2721e4d7a3487ff8ff048a7f98fd.js?file=HelloWorld.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4ffa2721e4d7a3487ff8ff048a7f98fd.js?file=java-helloworld.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Esta funcionalidad es compatible con los &lt;em&gt;shebang&lt;/em&gt; de los sistemas Unix.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4ffa2721e4d7a3487ff8ff048a7f98fd.js?file=helloworld.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/4ffa2721e4d7a3487ff8ff048a7f98fd.js?file=hello.sh&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/09/novedades-y-nuevas-caracteristicas-de-java-11/images/java-helloworld_huaa51cd775853ec98b86099eb2028f7dc_95828_2560x1440_fit_box_2.png&#34; title=&#34;Java 11 HelloWorld!&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/09/novedades-y-nuevas-caracteristicas-de-java-11/images/java-helloworld_huaa51cd775853ec98b86099eb2028f7dc_95828_6500x450_fit_box_2.png&#34; width=&#34;700&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Java 11 HelloWorld!&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;h3 id=&#34;unicode-10&#34;&gt;Unicode 10&lt;/h3&gt;
&lt;p&gt;Tratar texto es una parte importante casi de cualquier aplicación, este soporte de Unicode 10 añade 16018 nuevos caracteres soportados, 128 nuevos emojis y 19 símbolos nuevos para el estándar en televisiones 4K.&lt;/p&gt;
&lt;h3 id=&#34;tls-1-3&#34;&gt;TLS 1.3&lt;/h3&gt;
&lt;p&gt;Algunas de las versiones anteriores de TLS ya no se consideran seguras añadir soporte para la versión más reciente TLS 1.3 permite a las aplicaciones Java ser más compatibles y más seguras. El protocolo TLS 1.3 proporciona dos beneficios principalmente, es más seguro y más rápido que sus versiones anteriores.&lt;/p&gt;
&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/HxDb5nwvN_Y?rel=0&#34; frameborder=&#34;0&#34; allow=&#34;autoplay; encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;h3 id=&#34;otras-mejoras&#34;&gt;Otras mejoras&lt;/h3&gt;
&lt;p&gt;Se añaden implementaciones específicas para la arquitectura Aarch64 para un mejor rendimiento en la plataforma &lt;a href=&#34;https://www.arm.com/&#34;&gt;ARM&lt;/a&gt; en algunas funciones. Se añade de forma experimental un nuevo recolector de basura ZGC con pausas para recolectar basura menores capaz de manejar cantidades de memoria pequeñas de megabytes y grandes de terabytes. Al mismo tiempo se añade un recolector de basura Epsilon que no reclama la memoria. Se añade soporte para los algoritmos criptográficos &lt;em&gt;ChaCha20&lt;/em&gt; y &lt;em&gt;Poly1305&lt;/em&gt; junto con otras funcionalidades criptográficas &lt;em&gt;RSASSA-PSS&lt;/em&gt;, &lt;em&gt;AES Encryption with HMAC-SHA2 for Kerberos 5&lt;/em&gt;, &amp;hellip;&lt;/p&gt;
&lt;p&gt;Se añaden varios métodos a la clase &lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html&#34;&gt;String&lt;/a&gt; muy utilizados con los que no será necesario recurrie a librerías de terceros. Estos métodos son &lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#repeat(int)&#34;&gt;repeat&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isBlank()&#34;&gt;isBlank&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#strip()&#34;&gt;strip&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#stripLeading()&#34;&gt;stripLeading&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#stripTrailing()&#34;&gt;stripTrailing&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#lines()&#34;&gt;lines&lt;/a&gt;. En otras clases de la API también se han añadido nuevos métodos.&lt;/p&gt;
&lt;p&gt;Java que tradicionalmente marcaba como &lt;em&gt;deprecarted&lt;/em&gt; características pero que las seguía manteniendo por compatibilidad hacia atrás parece que ha empezado a eliminar varias de esas características desaconsejadas de forma más agresiva. No solo se añaden nuevas características, también se eliminan algunas y se desaconseja el uso de otras entre ellas el visor de &lt;em&gt;applets&lt;/em&gt;, eliminación de &lt;em&gt;Unsafe.defineClass&lt;/em&gt;, &lt;em&gt;Thread.destroy()&lt;/em&gt; y &lt;em&gt;Thread.stop(Throwable)&lt;/em&gt;, eliminación de las funcionalidades de despliegue de &lt;em&gt;Java Plugin&lt;/em&gt; y &lt;em&gt;Java Web Start&lt;/em&gt; que se marcaron como desaconsejadas en Java 9 y para eliminación en Java 10 finalmente en Java 11 se han eliminado sin reemplazo.&lt;/p&gt;
&lt;p&gt;Oracle ya no ofrece el entorno de ejecución JRE ni versiones de 32 bits para Windows. JavaFX ya no está incluído en el JDK pero seguirá siendo utilizable como librería independiente.&lt;/p&gt;
&lt;p&gt;Las anteriores son las funcionalidades que he considerado más destacables para todos los usuarios., También hay otras funcionalidades añadidas, soporte eliminado para funciones específicas o de funcionamiento interno.&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.oracle.com/java/java11&#34;&gt;Introducing Java SE 11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oracle.com/technetwork/java/javase/11-relnote-issues-5012449.html&#34;&gt;JDK 11 Release Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/&#34;&gt;Java 11 Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/docs/api/index.html&#34;&gt;Java 11 Javadoc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.oracle.com/java-platform-group/introducing-java-se-11&#34;&gt;Introducing Java SE 11 (blog)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.oracle.com/java-platform-group/oracle-jdk-releases-for-java-11-and-later&#34;&gt;Oracle JDK Releases for Java 11 and Later&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.takipi.com/java-11-will-include-more-than-just-features/&#34;&gt;Java 11 Will Include More Than Just Features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.azul.com/90-new-features-and-apis-in-jdk-11/&#34;&gt;90 New Features (and APIs) in JDK 11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://4comprehension.com/java-11-string-api-updates/&#34;&gt;Java 11 String API Updates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/eclipse/jetty.project/issues/2487&#34;&gt;Java 11 removes EE and Corba packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/java/status/1044609723012665344&#34;&gt;Java Mission Control - Now serving OpenJDK binaries too!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/en/java/javase/11/migrate/index.html&#34;&gt;Oracle JDK 11 Migration Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.java-countdown.xyz/&#34;&gt;Countdown to Java Release Date&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="blog"/><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/09/recargar-sin-reiniciar-la-configuracion-de-una-aplicacion-spring-boot-con-spring-cloud-config/</id><title>Recargar sin reiniciar la configuración de una aplicación Spring Boot con Spring Cloud Config</title><updated>2018-09-23T00:50:00+02:00</updated><published>2018-09-23T00:15:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/09/recargar-sin-reiniciar-la-configuracion-de-una-aplicacion-spring-boot-con-spring-cloud-config/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;No es raro la necesidad de querer cambiar algunos valores de la configuración de una aplicación sin ningún cambio adicional en el código. Normalmente la configuración se externaliza en un archivo de texto en un determinado formato como &lt;em&gt;properties&lt;/em&gt; o &lt;em&gt;yaml&lt;/em&gt; que se lee al iniciarse la aplicación pero que al querer hacer cambios y hacerlos efectivos requiere reiniciar la aplicación.&lt;/p&gt;
&lt;p&gt;Para evitar la caída de servicio en un reinicio de aplicación requiere tener varias instancias de la aplicación, ir sacando del balanceador las instancias para que no le soliciten nuevas peticiones, reiniciarlas y añadirlas de nuevo al balanceador si se hace balanceo de carga en el servidor o reiniciar las aplicaciones progresivamente si se hace en el cliente. Y esto con todas las instancias del servicio. &lt;a href=&#34;https://cloud.spring.io/spring-cloud-config/&#34;&gt;Spring Cloud Config&lt;/a&gt; y &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; entre sus funcionalidades de configuración posee una que consiste en recargar la configuración o ciertas partes de la misma. Para ello &lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready&#34;&gt;Spring Boot Actuator&lt;/a&gt; ofrece un &lt;em&gt;endpoint&lt;/em&gt; con el que disparar la recarga.&lt;/p&gt;
&lt;p&gt;En el siguiente ejemplo de microservicio que posee una clase de configuración con algunas propiedades. El valor de estas propiedades se utilizan para el resultado de una acción en un &lt;em&gt;endpoint&lt;/em&gt; del servicio.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/c8304298f6f6a0aa64b69b25ad2f886e.js?file=DefaultConfiguration.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/c8304298f6f6a0aa64b69b25ad2f886e.js?file=DefaultController.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/c8304298f6f6a0aa64b69b25ad2f886e.js?file=service.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;Iniciada la aplicación que requiere iniciar previamente el servicio de registro y descubrimiento y el servidor de configuración, la aplicación al iniciarse obtiene su configuración del servidor de configuración. Si se cambia la configuración de la variable &lt;em&gt;config.key&lt;/em&gt; la aplicación no obtendrá el valor actualizado hasta que se invoque el &lt;em&gt;endpoint&lt;/em&gt; &lt;em&gt;http://localhost:8080/actuator/refresh&lt;/em&gt;. Para que Spring Boot recargue la configuración es necesario anotar con &lt;em&gt;@RefreshScope&lt;/em&gt; la clase de configuración. Invocado el &lt;em&gt;endpoint&lt;/em&gt; de recarga de configuración la aplicación toma de nuevo los nuevos valores del servicio de configuración.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/c8304298f6f6a0aa64b69b25ad2f886e.js?file=gradle-run-1.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/c8304298f6f6a0aa64b69b25ad2f886e.js?file=curl-1.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;En una aplicación orientada microservicios es muy posible que haya múltiples instancias del mismo servicio y para recargar la configuración de cada uno de ellos hay que hacerlo de forma individual con su &lt;em&gt;endpoint&lt;/em&gt; de recarga de configuración. Dado el número de microservicios y su ubicación distribuida hacerlo de forma individual es un inconveniente.&lt;/p&gt;
&lt;p&gt;Para resolver este inconveniente integrando &lt;a href=&#34;https://cloud.spring.io/spring-cloud-bus/&#34;&gt;Spring Cloud Bus&lt;/a&gt; en las aplicaciones es posible recargar la configuración de todos los microservicios haciendo una única llamada al &lt;em&gt;endpoint&lt;/em&gt; &lt;em&gt;http://localhost:8090/monitor&lt;/em&gt; indicando el servicio a actualizar su configuración lo que es independiente del número de instancias y de su ubicación. Integrar Spring Clud Bus requiere disponer de una instancia de mensajes como &lt;a href=&#34;https://www.rabbitmq.com/&#34;&gt;RabbitMQ&lt;/a&gt; e incluir como dependencia tanto en el servidor de configuración como en el servicio la dependencia &lt;em&gt;spring-cloud-starter-bus-amqp&lt;/em&gt;. Para esta comunicación de mensajes Spring Cloud Config crea en RabbitMQ una cola de mensajes que empieza por &lt;em&gt;springCloudBus&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/c8304298f6f6a0aa64b69b25ad2f886e.js?file=configserver.gradle&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/c8304298f6f6a0aa64b69b25ad2f886e.js?file=service.gradle&#34;&gt;&lt;/script&gt;
&lt;p&gt;Los pasos para probar estas funcionalidades con Spring Cloud Bus en una o varias varias instancias son iniciar una instancia o más del servidor de registro y descubrimiento, iniciar una o más instancias del servidor de configuración, iniciar una o varias instancias del servicio todas las instancias en un puerto y terminal diferente, invocar el servicio cuyo valor de respuesta depende de una propiedad de configuración, modificar el valor de la propiedad de configuración, recargar la configuración e invocar de nuevo el servicio para comprobar que el nuevo valor se ha hecho efectivo.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/c8304298f6f6a0aa64b69b25ad2f886e.js?file=gradle-run-2.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/c8304298f6f6a0aa64b69b25ad2f886e.js?file=curl-2.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradle-run-1.sh, ./curl-1.sh&lt;/code&gt;.
&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cloud.spring.io/spring-cloud-static/spring-cloud-bus/2.0.0.RELEASE/single/spring-cloud-bus.html#_quick_start&#34;&gt;Spring Cloud Bus - Quick Start&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.0.1.RELEASE/single/spring-cloud-config.html#_push_notifications_and_spring_cloud_bus&#34;&gt;Spring CloudBus - Push Notifications and Spring Cloud Bus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-configuration-classes.html&#34;&gt;Spring Boot - Configuration Classes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/09/servicio-de-configuracion-para-microservicios-con-spring-cloud-config/</id><title>Servicio de configuración para microservicios con Spring Cloud Config</title><updated>2018-09-15T19:30:00+02:00</updated><published>2018-09-15T16:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/09/servicio-de-configuracion-para-microservicios-con-spring-cloud-config/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Al igual que un servicio de registro y descubrimiento es esencial para los microservicios un servicio de obtención de configuración de donde puedan obtener su configuración es también básico. Dado el gran número de microservicios de los que puede estar compuesta una aplicación, su carácter efímero, los varios entornos de ejecución (desarrollo, pruebas, producción, &amp;hellip;) mantener centralizada la configuración en un único sitio hace las cosas mucho más sencillas cuando hay que cambiar el valor de alguna propiedad, en vez de la alternativa aún externalizada del artefacto del microservicio en el sistema de archivos del entorno de ejecución.&lt;/p&gt;
&lt;p&gt;Dado que este servicio de configuración es esencial para que los microservicios puedan obtener su configuración sin la cual no podrían proporcionar su funcionalidad hay que configurarlo de tal manera que sea tolerante a fallos. Una de las medidas para hacerlo tolerante a fallos es iniciar varias instancias de servidores de configuración, estas instancias se autoregistran en el servicio de descubrimiento para que los microservicios puedan descubrirlos y obtener su configuración al iniciarse.&lt;/p&gt;
&lt;p&gt;Con el comando &lt;code&gt;./gradlew configserver:run &amp;ndash;args=&amp;ldquo;&amp;ndash;port=8090&amp;rdquo;&lt;/code&gt; se inicia una instancia de servicio de configuración en el puerto &lt;em&gt;8090&lt;/em&gt;, cambiando el número de puerto se puede iniciar otra instancia en el puerto especificado. Una vez iniciadas varias instancias en el &lt;em&gt;dashboard&lt;/em&gt; del servicio de descubrimiento se observa como se autoregistran y su estado.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=gradlew-run.sh&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/09/servicio-de-configuracion-para-microservicios-con-spring-cloud-config/images/spring-eureka-2_hub1cbfdfec6fa7e0b16e220ff391ac48f_114116_2560x1440_fit_box_2.png&#34; title=&#34;Servicios registrados en el servicio de registro y descubrimiento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/09/servicio-de-configuracion-para-microservicios-con-spring-cloud-config/images/spring-eureka-2_hub1cbfdfec6fa7e0b16e220ff391ac48f_114116_300x200_fit_box_2.png&#34; width=&#34;244&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Servicios y su estado registrados en el servicio de registro y descubrimiento&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Dado que los servicios de configuración no pueden confiar en obtener su configuración de una instancia de su servicio de configuración ha de establecerse en el propio microservicio los nombres de &lt;em&gt;host&lt;/em&gt; de las instancias de registro y descubrimiento en las que registrarse, en la propiedad &lt;em&gt;eureka.client.serviceUrl.defaultZone&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=bootstrap.yml&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=application.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;Los archivos de configuración para los microservicios en este ejemplo están en el directorio &lt;em&gt;misc/config&lt;/em&gt; donde siguiendo algunas convenciones para asignar el nombre a los archivos se pueden personalizar las configuraciones de los microservicios según el entorno y perfil con el que se active. En este caso se utiliza lo que &lt;a href=&#34;https://cloud.spring.io/spring-cloud-config/&#34;&gt;Spring Cloud Config&lt;/a&gt; denomina un &lt;em&gt;filesystem backend&lt;/em&gt;, sin embargo, hay otras disponibles como un repositorio de &lt;a href=&#34;https://git-scm.com/&#34;&gt;git&lt;/a&gt; el cual ofrece varias ventajas propias de un repositorio de código como historial, ramas de trabajo y hacer cambios con un &lt;em&gt;commit&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Un microservicio o aplicación de &lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt; que use un servidor de Spring Cloud Config una de las primeras acciones que realiza al iniciarse es obtener su configuración en función del nombre del microservicio y perfil con el que se inicie. Dado que la configuración se obtiene en el inicio en base a su nombre y perfil tanto el nombre del microservicio y su perfil de configuración se ha de configurar en el archivo &lt;em&gt;bootstrap.yml&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;El proceso de configuración de un microservicio está formado por dos pasos, en el primero el servicio se conecta al servicio de registro y descubrimiento obtiene los servicios registrados de configuración y en el segundo paso solicita a uno de ellos su configuración.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=bootstrap-service.yml&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=service.yml&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=client.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;El servicio de configuración es accesible mediante una interfaz REST. Para obtener la configuración del servicio &lt;em&gt;service&lt;/em&gt; y del servicio &lt;em&gt;client&lt;/em&gt; de este ejemplo las URLs para obtenerlas son las siguientes. Estos &lt;em&gt;endpoints&lt;/em&gt; devuelven en formato &lt;em&gt;json&lt;/em&gt; un documento con los valores de las propiedades principalmente están en el mapa &lt;em&gt;source&lt;/em&gt; entre otros datos que Spring al iniciar la aplicación con ellos configura la aplicación.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=curl.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=service-config.json&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=client-config.json&#34;&gt;&lt;/script&gt;
&lt;p&gt;En otro artículo relacionado con la configuración de los microservicios comentaré &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/09/recargar-la-configuracion-sin-reiniciar-una-aplicacion-spring-boot-con-spring-cloud-config/&#34;&gt;como recargar la configuración de los microservicios sin necesidad de reiniciarlos&lt;/a&gt; y &lt;em&gt;como almacenar datos sensibles de forma cifrada&lt;/em&gt; para mayor seguridad.&lt;/p&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run:configserver --args=&amp;#34;port=8090&amp;#34;&lt;/code&gt;.
&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.0.1.RELEASE/single/spring-cloud-config.html#_git_backend&#34;&gt;Spring Cloud Config, Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.0.1.RELEASE/single/spring-cloud-config.html#vault-backend&#34;&gt;Spring Cloud Config, Vault&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.0.1.RELEASE/single/spring-cloud-config.html#_jdbc_backend&#34;&gt;Spring Cloud Config, JDBC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#boot-features-external-config&#34;&gt;Spring Cloud Config, Externalized Configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/</id><title>Registro y descubrimiento de servicios con Spring Cloud Netflix</title><updated>2018-09-07T19:00:00+02:00</updated><published>2018-09-07T19:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Los microservicios en una aplicación con una arquitectura de microservicios son efímeros, se crean, se escalan para atender picos de mayor demanda, pueden desaparecer por problemas de la red de comunicaciones que no es fiable y volverse a crear en una ubicación diferente. Por esta naturaleza efímera es necesario un servicio con el cual los clientes de los microservicios puedan encontrarlos y que los microservicios utilizan para registrarse cuando se inician.&lt;/p&gt;
&lt;p&gt;Este servicio de registro y descubrimiento es esencial y crítico en una aplicación orientada a microservicios ya que sin él los clientes no pueden encontrar los servicios que necesitan. Dado que es un servicio esencial es necesario que esté siempre disponible y para ello es recomendable crear un cluster de servicios de registro y descubrimiento para que en caso de que una instancia de este servicio falle estén disponibles otras instancias para los clientes.&lt;/p&gt;
&lt;p&gt;Una &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/01/registro-y-descubrimiento-de-servicios-con-spring-cloud-y-consul/&#34;&gt;implementación de registro y descubrimiento es Consul&lt;/a&gt;, &lt;a href=&#34;https://www.consul.io/&#34;&gt;Consul&lt;/a&gt; es un servicio externo creado por &lt;a href=&#34;https://www.hashicorp.com/&#34;&gt;Hashicorp&lt;/a&gt;. &lt;a href=&#34;https://projects.spring.io/spring-cloud/&#34;&gt;Spring Cloud&lt;/a&gt; entre sus proyectos, &lt;a href=&#34;https://cloud.spring.io/spring-cloud-netflix/&#34;&gt;Spring Cloud Netflix&lt;/a&gt;, proporciona una implementación con &lt;a href=&#34;https://github.com/Netflix/eureka&#34;&gt;Eureka&lt;/a&gt; de servicio de registro y descubrimiento que se pueden embeber en una aplicación de &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para crear un servidor Eureka con Spring y Spring Boot hay que crear una aplicación con las dependencias adecuadas y la anotación &lt;em&gt;@EnableEurekaServer&lt;/em&gt; para habilitar el inicio del servidor de registro y descubrimiento. Además, establecer las propiedades de configuración adecuadas para que el cluster de servidores Eureka se forme. Este microservicio es el primero que ha de iniciarse en una aplicación orientada a microservicios.&lt;/p&gt;
&lt;p&gt;Utilizando &lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt; las dependencias y la anotación &lt;em&gt;@EnableEurekaServer&lt;/em&gt; a añadir a la clase principal de la aplicación son las siguientes.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;La propiedad de configuración principal para formar el cluster es &lt;em&gt;eureka.client.serviceURL.defaultZone&lt;/em&gt; donde se especifica una lista &lt;em&gt;hostnames&lt;/em&gt; donde están los servidores de registro y descubrimiento. Para dar a cada servidor en local un nombre de dominio distinto he usado el servicio de DNS &lt;a href=&#34;http://xip.io/&#34;&gt;xip.io&lt;/a&gt; que resuleve el nombre de dominio a la dirección IP indicada en el propio nombre de dominio, así &lt;em&gt;ds1.127.0.0.1.xip.io&lt;/em&gt; se resuelve a &lt;em&gt;127.0.0.1&lt;/em&gt; que es la dirección para la propia máquina local al igual que &lt;em&gt;ds2.127.0.0.1.xip.io&lt;/em&gt; y &lt;em&gt;ds3.127.0.0.1.xip.io&lt;/em&gt;. El servicio de xip.io evita tener que crear en el archivo de &lt;em&gt;hosts&lt;/em&gt; local una correspondencia entre nombre de &lt;em&gt;hostname&lt;/em&gt; y la dirección IP de &lt;em&gt;loopback&lt;/em&gt; de la propia máquina local.&lt;/p&gt;
&lt;p&gt;En el archivo de configuración hay tres perfiles distintos que varían algunas propiedades según sea el perfil que se active al iniciar la instancia del servicio. En el perfil &lt;em&gt;ds1&lt;/em&gt; el puerto donde se inicia el servicio es &lt;em&gt;8761&lt;/em&gt;, con el perfil &lt;em&gt;ds2&lt;/em&gt; el servicio se inicia en el puerto &lt;em&gt;8762&lt;/em&gt; y con &lt;em&gt;ds3&lt;/em&gt; en el &lt;em&gt;8763&lt;/em&gt;, además se cambia el &lt;em&gt;hostname&lt;/em&gt; para que la instancia sepa cual es.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=application.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;Los comandos para arrancar tres instancias de servidor de registro y descubrimiento utilizando varios perfiles de configuración de Spring son los siguientes.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=run-discoveryserver.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Estando disponible el servicio de registro y descubrimiento ya se puede iniciar el servicio de configuración. Con estos dos servicios de infraestructura iniciados los que sería un servicio de la aplicación ya puede iniciarse que consiste en este caso en obtener una referencia de una instancia del servicio de configuración registada en el servicio de registro y descubrimiento, con esta referencia obtiene su configuración y se inicia.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=run-configserver.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=run-service.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Una vez iniciados los servidores de descubrimiento en la página &lt;em&gt;dashboard&lt;/em&gt; de cualquiera de ellos cambiando el puerto de la dirección &lt;em&gt;http://ds1.127.0.0.1.xip.io:8761/&lt;/em&gt; se observan varias propiedades como la lista de servidores del cluster, las réplicas registradas y disponibles y los servicios registrados con su ubicación y puerto. En este caso hay tres instancias del servicio de registro y descubrimiento, una de servidor de configuración y dos instancias de un servicio.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/images/spring-eureka-1_hucbae4859ed8e1c01a78ce54eb118f2fc_101099_2560x1440_fit_box_2.png&#34; title=&#34;Cluster del servicio de registro y descubrimiento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/images/spring-eureka-1_hucbae4859ed8e1c01a78ce54eb118f2fc_101099_300x200_fit_box_2.png&#34; width=&#34;258&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/images/spring-eureka-2_hub1cbfdfec6fa7e0b16e220ff391ac48f_114116_2560x1440_fit_box_2.png&#34; title=&#34;Servicios registrados en el servicio de registro y descubrimiento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/images/spring-eureka-2_hub1cbfdfec6fa7e0b16e220ff391ac48f_114116_300x200_fit_box_2.png&#34; width=&#34;244&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Servicios y su estado registrados en el servicio de registro y descubrimiento&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew discoveryserver:run --args=&amp;#34;--spring.profiles.active=ds1&amp;#34;&lt;/code&gt;.
&lt;/p&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/08/los-fragmentos-en-graphql/</id><title>Los fragmentos en GraphQL</title><updated>2018-08-25T19:00:00+02:00</updated><published>2018-08-25T19:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/08/los-fragmentos-en-graphql/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/graphql.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;GraphQL&#34; title=&#34;GraphQL&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Los fragmentos en el contexto de &lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt; pueden ser de dos tipos, definidos previamente o definidos en linea. Los primeros permiten simplificar las consultas definiendo en un bloque una colección de datos a recuperar si tener que indicarlos explícitamente individualmente, lo que resulta útil para no repetir el mimo grupo de datos si se utiliza en varias consultas diferentes. Los fragmentos en línea permiten recuperar unos datos u otros en función del tipo de la instancia de la cual se quieren recuperar.&lt;/p&gt;
&lt;p&gt;Teniendo dos consultas que recuperan los datos de una colección de libros sin los fragmentos habría que definir los mismos datos a recuperar dos veces en ambas consultas. En estas consultas de ejemplo se recupera una lista de libros y un libro determinado. Si en ambas se recuperan los datos &lt;em&gt;id&lt;/em&gt;, &lt;em&gt;title&lt;/em&gt; y &lt;em&gt;date&lt;/em&gt; hay que indicar los campos a recuperar dos veces.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=query-1.graphql&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=query-1.json&#34;&gt;&lt;/script&gt;
&lt;p&gt;Con un fragmento se definen esos campos comunes a recuperar en las consultas una sola vez. Si posteriormente cambian los datos a recuperar solo es necesario cambiarlo en un único punto. Los fragmentos definidos son una forma de simplificar las consultas y evitar tener que cambiar varias consultas si el grupo de datos cambia en todas ellas. Los datos obtenidos son los mismos que en el caso sin utilizar el fragmento.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=query-1-fragment.graphql&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/los-fragmentos-en-graphql/images/query-1_huf7f7d97dfa0480aa0b5d479924a9ddad_449281_2560x1440_fit_box_2.png&#34; title=&#34;Consultas sin utilizar un fragmento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/los-fragmentos-en-graphql/images/query-1_huf7f7d97dfa0480aa0b5d479924a9ddad_449281_300x200_fit_box_2.png&#34; width=&#34;255&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/los-fragmentos-en-graphql/images/query-1-fragment_huf7f7d97dfa0480aa0b5d479924a9ddad_461346_2560x1440_fit_box_2.png&#34; title=&#34;Consultas con un fragmento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/los-fragmentos-en-graphql/images/query-1-fragment_huf7f7d97dfa0480aa0b5d479924a9ddad_461346_300x200_fit_box_2.png&#34; width=&#34;255&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Consultas sin y con un fragmento&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Los fragmentos en línea o &lt;em&gt;inline&lt;/em&gt; permiten por otra parte una funcionalidad adicional y es recuperar diferentes datos según el tipo de la entidad. En el ejemplo he añadido una nueva entidad &lt;em&gt;Magazine&lt;/em&gt; además de la ya existente &lt;em&gt;Book&lt;/em&gt;, en el código Java ambas heredan de &lt;em&gt;Publication&lt;/em&gt;. Las entidades &lt;em&gt;Book&lt;/em&gt; y &lt;em&gt;Magazine&lt;/em&gt; no comparten las mismas propiedades dado que son entidades diferentes por lo que en la consulta es necesario tener un mecanismo con el cual poder recuperar los datos en función del tipo.&lt;/p&gt;
&lt;p&gt;Estas son las definiciones de las entidades resumidas y la consulta &lt;em&gt;publications&lt;/em&gt; que devuelve las publicaciones que incluye libros y revistas. Con la definición de una &lt;em&gt;union&lt;/em&gt; se establece que una &lt;em&gt;Publication&lt;/em&gt; puede ser un &lt;em&gt;Book&lt;/em&gt; o &lt;em&gt;Magazine&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=library.graphqls&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=fragment-inline.graphql&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=fragment-inline.json&#34;&gt;&lt;/script&gt;
&lt;p&gt;Para las publicaciones del tipo &lt;em&gt;Book&lt;/em&gt; en este ejemplo se recuperan los campos &lt;em&gt;id&lt;/em&gt;, &lt;em&gt;title&lt;/em&gt; y &lt;em&gt;date&lt;/em&gt;. Para las publicaciones de tipo &lt;em&gt;Magazine&lt;/em&gt; se recuperan los campos &lt;em&gt;id&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt; y &lt;em&gt;pages&lt;/em&gt;. Las publicaciones &lt;em&gt;Muy interesante&lt;/em&gt; y &lt;em&gt;PC Actual&lt;/em&gt; son dos &lt;em&gt;Magazine&lt;/em&gt; y el resto de publicaciones son del tipo &lt;em&gt;Book&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/los-fragmentos-en-graphql/images/fragment-inline_hu65f3c18cd22adde4c0d76d2c15b7c917_498202_2560x1440_fit_box_2.png&#34; title=&#34;Consulta con fragmentos en linea&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/los-fragmentos-en-graphql/images/fragment-inline_hu65f3c18cd22adde4c0d76d2c15b7c917_498202_300x200_fit_box_2.png&#34; width=&#34;240&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Consulta con fragmentos en linea&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Si es necesario hay que añadir la clases Java que representan a los tipos de GraphQL a la lista de clases del diccionario en la definición del esquema.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;Para cada entidad hay una clase Java que la representa y un repositorio que contiene la consulta para obtener las publicaciones que no hace más que añadir en una lista el conjunto de libros y revistas en la librería.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=Book.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=Magazine.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=Publication.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/fe3ba84b227100bb23b87fbd9af76a95.js?file=LibraryRepository.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/GraphQL&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;. Requiere Java 9&amp;#43; o Docker.
&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://graphql.org/learn/queries/#fragments&#34;&gt;Fragments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://graphql.org/learn/queries/#inline-fragments&#34;&gt;Inline Fragments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.howtographql.com/advanced/2-more-graphql-concepts/&#34;&gt;More GraphQL Concepts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/08/usando-directivas-en-graphql/</id><title>Usando directivas en GraphQL</title><updated>2018-08-24T08:00:00+02:00</updated><published>2018-08-24T08:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/08/usando-directivas-en-graphql/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/graphql.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;GraphQL&#34; title=&#34;GraphQL&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;En &lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt; construyendo la consulta adecuada se recuperan exclusivamente los datos solicitados.&lt;/p&gt;
&lt;p&gt;Por ejemplo, si de un libro solo se requieren las propiedades el &lt;em&gt;id&lt;/em&gt;, &lt;em&gt;title&lt;/em&gt; y &lt;em&gt;date&lt;/em&gt; de entre todas las que tienen la consulta sería en este caso la siguiente para una consulta que devuelve los datos de un conjunto de libros.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/5a60d7e3d64c62e04fb850e824469257.js?file=query-1.graphql&#34;&gt;&lt;/script&gt;
&lt;p&gt;Si se desea recuperar solo el &lt;em&gt;id&lt;/em&gt; y &lt;em&gt;title&lt;/em&gt; sin el &lt;em&gt;date&lt;/em&gt; la consulta debe ser diferente.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/5a60d7e3d64c62e04fb850e824469257.js?file=query-2.graphql&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/5a60d7e3d64c62e04fb850e824469257.js?file=library.graphqls&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/usando-directivas-en-graphql/images/image-1_hu3c329f116d7853227603ad333a0604de_396651_2560x1440_fit_box_2.png&#34; title=&#34;Consulta id, title y date&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/usando-directivas-en-graphql/images/image-1_hu3c329f116d7853227603ad333a0604de_396651_300x200_fit_box_2.png&#34; width=&#34;276&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/usando-directivas-en-graphql/images/image-2_hu3c329f116d7853227603ad333a0604de_358582_2560x1440_fit_box_2.png&#34; title=&#34;Consulta id y title&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/usando-directivas-en-graphql/images/image-2_hu3c329f116d7853227603ad333a0604de_358582_300x200_fit_box_2.png&#34; width=&#34;276&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Consultas diferentes que devuelven diferentes datos&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Esto obliga en principio a tener dos consultas diferentes según los datos recuperar. En principio, ya que las &lt;a href=&#34;https://graphql.org/learn/queries/#directives&#34;&gt;directivas &lt;em&gt;skip&lt;/em&gt; e &lt;em&gt;include&lt;/em&gt;&lt;/a&gt; definidas en la especificación de GraphQL permiten tener la misma consulta y parametrizar si un determinado dato ha de incluirse o no en el resultado.&lt;/p&gt;
&lt;p&gt;Las directivas se definen en el lenguaje de consulta de GraphQL con el caracter &lt;em&gt;@&lt;/em&gt; y pueden recibir parámetros. La directiva &lt;em&gt;skip&lt;/em&gt; permite omitir un dato según el valor de un booleano, si es &lt;em&gt;true&lt;/em&gt; se omite y si es &lt;em&gt;false&lt;/em&gt; se incluye, el comportamiento de &lt;em&gt;include&lt;/em&gt; es el mismo pero con el valor contrario del booleano, si es &lt;em&gt;true&lt;/em&gt; se incluye y si es &lt;em&gt;false&lt;/em&gt; se omite.&lt;/p&gt;
&lt;p&gt;Esta sería la consulta parametrizada para obtener los datos de los libros omitiendo o incluyendo su fecha en función de una variable utilizando la directiva &lt;em&gt;include&lt;/em&gt;. Cuando el valor de la variable es &lt;em&gt;true&lt;/em&gt; se incluye el dato fecha, cuando el valor de la variable es &lt;em&gt;false&lt;/em&gt; no se incluye.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/5a60d7e3d64c62e04fb850e824469257.js?file=query-3.graphql&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/5a60d7e3d64c62e04fb850e824469257.js?file=variables-1.graphql&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/5a60d7e3d64c62e04fb850e824469257.js?file=variables-2.graphql&#34;&gt;&lt;/script&gt;
&lt;p&gt;Utilizando &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/el-editor-explorador-e-ide-graphiql-para-una-api-con-graphql/&#34;&gt;el editor GraphiQL&lt;/a&gt; para construir y ejecutar consultas de una API de GraphQL se obtienen los resultados.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/usando-directivas-en-graphql/images/image-3_hu3c329f116d7853227603ad333a0604de_421199_2560x1440_fit_box_2.png&#34; title=&#34;Consulta con directiva include&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/usando-directivas-en-graphql/images/image-3_hu3c329f116d7853227603ad333a0604de_421199_300x200_fit_box_2.png&#34; width=&#34;276&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/usando-directivas-en-graphql/images/image-4_hu3c329f116d7853227603ad333a0604de_386576_2560x1440_fit_box_2.png&#34; title=&#34;Consulta con directiva include&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/usando-directivas-en-graphql/images/image-4_hu3c329f116d7853227603ad333a0604de_386576_300x200_fit_box_2.png&#34; width=&#34;276&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Misma consulta con directiva include que devuelve diferentes datos&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Con un comando &lt;em&gt;curl&lt;/em&gt; se realizan las mismas consultas.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/5a60d7e3d64c62e04fb850e824469257.js?file=curl-1.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/5a60d7e3d64c62e04fb850e824469257.js?file=data-1.json&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/5a60d7e3d64c62e04fb850e824469257.js?file=curl-2.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/5a60d7e3d64c62e04fb850e824469257.js?file=data-2.json&#34;&gt;&lt;/script&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/GraphQL&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;. Requiere Java 9&amp;#43; o Docker.
&lt;/p&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/08/el-editor-explorador-e-ide-graphiql-para-una-api-con-graphql/</id><title>El editor, explorador e IDE GraphiQL para una API con GraphQL</title><updated>2018-08-19T11:00:00+02:00</updated><published>2018-08-19T11:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/08/el-editor-explorador-e-ide-graphiql-para-una-api-con-graphql/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/graphql.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;GraphQL&#34; title=&#34;GraphQL&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Hace ya un tiempo escribí una &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/graphql/&#34;&gt;serie de artículos sobre GraphQL&lt;/a&gt; para desarrollar una API en una aplicación como alternativa a desarrollarla basada en REST. En esa serie de artículos explicaba varios conceptos básicos e introductorios pero suficientes para desarrollar una API completamente funcional con &lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt; usando el lenguaje de programación Java. Sin embargo, sobre algunos otros conceptos y posibilidades de GraphQL no había escrito.&lt;/p&gt;
&lt;p&gt;Uno de esas posibilidades de GraphQL es la herramienta &lt;a href=&#34;https://github.com/graphql/graphiql&#34;&gt;GraphiQL&lt;/a&gt; que es un editor interactivo para construir consultas y explorar la API. Una de sus mayores ventajas es que ofrece asistencia contextual y proporciona mensajes de error en caso de que la sintaxis de la consulta sea errónea. En los artículos que escribí con anterioridad los ejemplos los hice usando el comando &lt;em&gt;curl&lt;/em&gt;. Ahora que he visto y aprendido algunas pocas cosas más de GraphQL en este artículo explico como usar la herramienta GraphiQL como alternativa a &lt;em&gt;curl&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;GraphiQL en casi un IDE para crear consultas de GraphQL, está basado en JavaScript, se ejecutan en el navegador y para su funcionamiento solo hay que proporcionarle el &lt;em&gt;endpoint&lt;/em&gt; de la API a probar.&lt;/p&gt;
&lt;p&gt;En la página de este tutorial se explica cual es el &lt;a href=&#34;https://www.howtographql.com/graphql-java/2-queries/&#34;&gt;código HTML necesario para el editor GraphiQL&lt;/a&gt;. Básicamente es un HTML que hay colocar en el caso de una aplicación Java en el directorio web de la aplicación, utilizando la página por defecto &lt;em&gt;index.html&lt;/em&gt; se carga al acceder a la dirección &lt;em&gt;http://localhost:8080/&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;En el código del archivo &lt;em&gt;index.html&lt;/em&gt; del ejemplo he tenido que cambiar estas dos cosas, una de ellas es utilizar un CDN para los recursos de GraphiQL y la otra en la función &lt;em&gt;graphQLFetcher&lt;/em&gt; es que en este ejemplo el &lt;em&gt;endpoint&lt;/em&gt; es &lt;em&gt;/library&lt;/em&gt; en vez de &lt;em&gt;/graphql&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/04cc7e8f50db18023c8938d0fa0f1182.js?file=index-1.html&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/04cc7e8f50db18023c8938d0fa0f1182.js?file=index-2.html&#34;&gt;&lt;/script&gt;
&lt;p&gt;Varias de las mismas consultas que hacía con &lt;em&gt;curl&lt;/em&gt; en otros artículos es posible lanzarlas con GraphiQL. Es posible formatear correctamente una consulta con el botón &lt;em&gt;prettify&lt;/em&gt;. Con en el enlace de documentación se puede explorar los tipos definidos en la API. Con funciones similares a un IDE ofrece errores de sintaxis, asistencia contextual e historial de consultas, en definitiva es una gran mejora sobre &lt;em&gt;curl&lt;/em&gt; y su incorporación a la aplicación es muy sencilla.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/el-editor-explorador-e-ide-graphiql-para-una-api-con-graphql/images/graphiql-1_hucac16e54b2bfb255dd15191d618a8dae_290445_2560x1440_fit_box_2.png&#34; title=&#34;Consulta&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/el-editor-explorador-e-ide-graphiql-para-una-api-con-graphql/images/graphiql-1_hucac16e54b2bfb255dd15191d618a8dae_290445_300x200_fit_box_2.png&#34; width=&#34;300&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/el-editor-explorador-e-ide-graphiql-para-una-api-con-graphql/images/graphiql-2_hu8bfa70ed84f47638ca2afb95500f4f95_206206_2560x1440_fit_box_2.png&#34; title=&#34;Asistencia contextual&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/el-editor-explorador-e-ide-graphiql-para-una-api-con-graphql/images/graphiql-2_hu8bfa70ed84f47638ca2afb95500f4f95_206206_300x200_fit_box_2.png&#34; width=&#34;300&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/el-editor-explorador-e-ide-graphiql-para-una-api-con-graphql/images/graphiql-3_hu5452a9f36f12efd7105147445eb4ed33_372372_2560x1440_fit_box_2.png&#34; title=&#34;Explorador del esquema&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/el-editor-explorador-e-ide-graphiql-para-una-api-con-graphql/images/graphiql-3_hu5452a9f36f12efd7105147445eb4ed33_372372_300x200_fit_box_2.png&#34; width=&#34;300&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;El editor GraphiQL para una API con GraphQL&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/GraphQL&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;. Requiere Java 9&amp;#43; o Docker.
&lt;/p&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry></feed>
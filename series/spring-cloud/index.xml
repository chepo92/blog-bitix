<?xml version="1.0" encoding="utf-8" standalone="yes"?><feed xmlns="http://www.w3.org/2005/Atom"><id>https://picodotdev.github.io/blog-bitix/series/spring-cloud/</id><title type="text">Blog Bitix</title><subtitle>Recent content on Blog Bitix</subtitle><updated>2018-09-15T16:00:00+02:00</updated><author><name>picodotdev</name></author><generator>Hugo</generator><icon>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</icon><logo>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</logo><rights>https://creativecommons.org/licenses/by-sa/4.0/</rights><entry><id>https://picodotdev.github.io/blog-bitix/2018/09/servicio-de-configuracion-para-microservicios-con-spring-cloud-config/</id><title>Servicio de configuración para microservicios con Spring Cloud Config</title><updated>2018-09-15T16:00:00+02:00</updated><published>2018-09-15T16:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/09/servicio-de-configuracion-para-microservicios-con-spring-cloud-config/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Al igual que un servicio de registro y descubrimiento es esencial para los microservicios un servicio de obtención de configuración de donde puedan obtener su configuración es también básico. Dado el gran número de microservicios de los que puede estar compuesta una aplicación, su carácter efímero, los varios entornos de ejecución (desarrollo, pruebas, producción, &amp;hellip;) mantener centralizada la configuración en un único sitio hace las cosas mucho más sencillas cuando hay que cambiar el valor de alguna propiedad, en vez de la alternativa aún externalizada del artefacto del microservicio en el sistema de archivos del entorno de ejecución.&lt;/p&gt;
&lt;p&gt;Dado que este servicio de configuración es esencial para que los microservicios puedan obtener su configuración sin la cual no podrían proporcionar su funcionalidad hay que configurarlo de tal manera que sea tolerante a fallos. Una de las medidas para hacerlo tolerante a fallos es iniciar varias instancias de servidores de configuración, estas instancias se autoregistran en el servicio de descubrimiento para que los microservicios puedan descubrirlos y obtener su configuración al iniciarse.&lt;/p&gt;
&lt;p&gt;Con el comando &lt;code&gt;./gradlew configserver:run &amp;ndash;args=&amp;ldquo;&amp;ndash;port=8090&amp;rdquo;&lt;/code&gt; se inicia una instancia de servicio de configuración en el puerto &lt;em&gt;8090&lt;/em&gt;, cambiando el número de puerto se puede iniciar otra instancia en el puerto especificado. Una vez iniciadas varias instancias en el &lt;em&gt;dashboard&lt;/em&gt; del servicio de descubrimiento se observa como se autoregistran y su estado.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=gradlew-run.sh&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/09/servicio-de-configuracion-para-microservicios-con-spring-cloud-config/images/spring-eureka-2_hub1cbfdfec6fa7e0b16e220ff391ac48f_114116_2560x1440_fit_box_2.png&#34; title=&#34;Servicios registrados en el servicio de registro y descubrimiento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/09/servicio-de-configuracion-para-microservicios-con-spring-cloud-config/images/spring-eureka-2_hub1cbfdfec6fa7e0b16e220ff391ac48f_114116_300x200_fit_box_2.png&#34; width=&#34;244&#34; height=&#34;200&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Servicios y su estado registrados en el servicio de registro y descubrimiento&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Dado que los servicios de configuración no pueden confiar en obtener su configuración de una instancia de su servicio de configuración ha de establecerse en el propio microservicio los nombres de &lt;em&gt;host&lt;/em&gt; de las instancias de registro y descubrimiento en las que registrarse, en la propiedad &lt;em&gt;eureka.client.serviceUrl.defaultZone&lt;/em&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=bootstrap.yml&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=application.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;Los archivos de configuración para los microservicios en este ejemplo están en el directorio &lt;em&gt;misc/config&lt;/em&gt; donde siguiendo algunas convenciones para asignar el nombre a los archivos se pueden personalizar las configuraciones de los microservicios según el entorno y perfil con el que se active. En este caso se utiliza lo que &lt;a href=&#34;https://cloud.spring.io/spring-cloud-config/&#34;&gt;Spring Cloud Config&lt;/a&gt; denomina un &lt;em&gt;filesystem backend&lt;/em&gt;, sin embargo, hay otras disponibles como un repositorio de &lt;a href=&#34;https://git-scm.com/&#34;&gt;git&lt;/a&gt; el cual ofrece varias ventajas propias de un repositorio de código como historial, ramas de trabajo y hacer cambios con un &lt;em&gt;commit&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Un microservicio o aplicación de &lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt; que use un servidor de Spring Cloud Config una de las primeras acciones que realiza al iniciarse es obtener su configuración en función del nombre del microservicio y perfil con el que se inicie. Dado que la configuración se obtiene en el inicio en base a su nombre y perfil tanto el nombre del microservicio y su perfil de configuración se ha de configurar en el archivo &lt;em&gt;bootstrap.yml&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;El proceso de configuración de un microservicio está formado por dos pasos, en el primero el servicio se conecta al servicio de registro y descubrimiento obtiene los servicios registrados de configuración y en el segundo paso solicita a uno de ellos su configuración.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=bootstrap-service.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;El servicio de configuración es accesible mediante una interfaz REST. Para obtener la configuración del servicio &lt;em&gt;service&lt;/em&gt; y del servicio &lt;em&gt;client&lt;/em&gt; de este ejemplo las URLs para obtenerlas son las siguientes. Estos &lt;em&gt;endpoints&lt;/em&gt; devuelven en formato &lt;em&gt;json&lt;/em&gt; un documento con los valores de las propiedades principalmente están en el mapa &lt;em&gt;source&lt;/em&gt; entre otros datos que Spring al iniciar la aplicación con ellos configura la aplicación.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=curl.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=service-config.json&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/b7583293e05ad6f1fcf7bb959da3cad1.js?file=client-config.json&#34;&gt;&lt;/script&gt;
&lt;p&gt;En otro artículo relacionado con la configuración de los microservicios comentaré &lt;em&gt;como recargar la configuración de los microservicios sin necesidad de reiniciarlos&lt;/em&gt; y &lt;em&gt;como almacenar datos sensibles de forma cifrada&lt;/em&gt; para mayor seguridad.&lt;/p&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run:configserver --args=&amp;#34;port=8090&amp;#34;&lt;/code&gt;.
&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.0.1.RELEASE/single/spring-cloud-config.html#_git_backend&#34;&gt;http://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.0.1.RELEASE/single/spring-cloud-config.html#_git_backend&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.0.1.RELEASE/single/spring-cloud-config.html#vault-backend&#34;&gt;http://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.0.1.RELEASE/single/spring-cloud-config.html#vault-backend&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.0.1.RELEASE/single/spring-cloud-config.html#_jdbc_backend&#34;&gt;http://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.0.1.RELEASE/single/spring-cloud-config.html#_jdbc_backend&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#boot-features-external-config&#34;&gt;https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#boot-features-external-config&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/</id><title>Registro y descubrimiento de servicios con Spring Cloud Netflix</title><updated>2018-09-07T19:00:00+02:00</updated><published>2018-09-07T19:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Los microservicios en una aplicación con una arquitectura de microservicios son efímeros, se crean, se escalan para atender picos de mayor demanda, pueden desaparecer por problemas de la red de comunicaciones que no es fiable y volverse a crear en una ubicación diferente. Por esta naturaleza efímera es necesario un servicio con el cual los clientes de los microservicios puedan encontrarlos y que los microservicios utilizan para registrarse cuando se inician.&lt;/p&gt;
&lt;p&gt;Este servicio de registro y descubrimiento es esencial y crítico en una aplicación orientada a microservicios ya que sin él los clientes no pueden encontrar los servicios que necesitan. Dado que es un servicio esencial es necesario que esté siempre disponible y para ello es recomendable crear un cluster de servicios de registro y descubrimiento para que en caso de que una instancia de este servicio falle estén disponibles otras instancias para los clientes.&lt;/p&gt;
&lt;p&gt;Una &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/01/registro-y-descubrimiento-de-servicios-con-spring-cloud-y-consul/&#34;&gt;implementación de registro y descubrimiento es Consul&lt;/a&gt;, &lt;a href=&#34;https://www.consul.io/&#34;&gt;Consul&lt;/a&gt; es un servicio externo creado por &lt;a href=&#34;https://www.hashicorp.com/&#34;&gt;Hashicorp&lt;/a&gt;. &lt;a href=&#34;https://projects.spring.io/spring-cloud/&#34;&gt;Spring Cloud&lt;/a&gt; entre sus proyectos, &lt;a href=&#34;https://cloud.spring.io/spring-cloud-netflix/&#34;&gt;Spring Cloud Netflix&lt;/a&gt;, proporciona una implementación con &lt;a href=&#34;https://github.com/Netflix/eureka&#34;&gt;Eureka&lt;/a&gt; de servicio de registro y descubrimiento que se pueden embeber en una aplicación de &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para crear un servidor Eureka con Spring y Spring Boot hay que crear una aplicación con las dependencias adecuadas y la anotación &lt;em&gt;@EnableEurekaServer&lt;/em&gt; para habilitar el inicio del servidor de registro y descubrimiento. Además, establecer las propiedades de configuración adecuadas para que el cluster de servidores Eureka se forme. Este microservicio es el primero que ha de iniciarse en una aplicación orientada a microservicios.&lt;/p&gt;
&lt;p&gt;Utilizando &lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt; las dependencias y la anotación &lt;em&gt;@EnableEurekaServer&lt;/em&gt; a añadir a la clase principal de la aplicación son las siguientes.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;La propiedad de configuración principal para formar el cluster es &lt;em&gt;eureka.client.serviceURL.defaultZone&lt;/em&gt; donde se especifica una lista &lt;em&gt;hostnames&lt;/em&gt; donde están los servidores de registro y descubrimiento. Para dar a cada servidor en local un nombre de dominio distinto he usado el servicio de DNS &lt;a href=&#34;http://xip.io/&#34;&gt;xip.io&lt;/a&gt; que resuleve el nombre de dominio a la dirección IP indicada en el propio nombre de dominio, así &lt;em&gt;ds1.127.0.0.1.xip.io&lt;/em&gt; se resuelve a &lt;em&gt;127.0.0.1&lt;/em&gt; que es la dirección para la propia máquina local al igual que &lt;em&gt;ds2.127.0.0.1.xip.io&lt;/em&gt; y &lt;em&gt;ds3.127.0.0.1.xip.io&lt;/em&gt;. El servicio de xip.io evita tener que crear en el archivo de &lt;em&gt;hosts&lt;/em&gt; local una correspondencia entre nombre de &lt;em&gt;hostname&lt;/em&gt; y la dirección IP de &lt;em&gt;loopback&lt;/em&gt; de la propia máquina local.&lt;/p&gt;
&lt;p&gt;En el archivo de configuración hay tres perfiles distintos que varían algunas propiedades según sea el perfil que se active al iniciar la instancia del servicio. En el perfil &lt;em&gt;ds1&lt;/em&gt; el puerto donde se inicia el servicio es &lt;em&gt;8761&lt;/em&gt;, con el perfil &lt;em&gt;ds2&lt;/em&gt; el servicio se inicia en el puerto &lt;em&gt;8762&lt;/em&gt; y con &lt;em&gt;ds3&lt;/em&gt; en el &lt;em&gt;8763&lt;/em&gt;, además se cambia el &lt;em&gt;hostname&lt;/em&gt; para que la instancia sepa cual es.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=application.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;Los comandos para arrancar tres instancias de servidor de registro y descubrimiento utilizando varios perfiles de configuración de Spring son los siguientes.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=run-discoveryserver.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Estando disponible el servicio de registro y descubrimiento ya se puede iniciar el servicio de configuración. Con estos dos servicios de infraestructura iniciados los que sería un servicio de la aplicación ya puede iniciarse que consiste en este caso en obtener una referencia de una instancia del servicio de configuración registada en el servicio de registro y descubrimiento, con esta referencia obtiene su configuración y se inicia.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=run-configserver.sh&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/12a3a40bdec8c3c36a0ec0eddfe81d58.js?file=run-service.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Una vez iniciados los servidores de descubrimiento en la página &lt;em&gt;dashboard&lt;/em&gt; de cualquiera de ellos cambiando el puerto de la dirección &lt;em&gt;http://ds1.127.0.0.1.xip.io:8761/&lt;/em&gt; se observan varias propiedades como la lista de servidores del cluster, las réplicas registradas y disponibles y los servicios registrados con su ubicación y puerto. En este caso hay tres instancias del servicio de registro y descubrimiento, una de servidor de configuración y dos instancias de un servicio.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/images/spring-eureka-1_hucbae4859ed8e1c01a78ce54eb118f2fc_101099_2560x1440_fit_box_2.png&#34; title=&#34;Cluster del servicio de registro y descubrimiento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/images/spring-eureka-1_hucbae4859ed8e1c01a78ce54eb118f2fc_101099_300x200_fit_box_2.png&#34; width=&#34;258&#34; height=&#34;200&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/images/spring-eureka-2_hub1cbfdfec6fa7e0b16e220ff391ac48f_114116_2560x1440_fit_box_2.png&#34; title=&#34;Servicios registrados en el servicio de registro y descubrimiento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/images/spring-eureka-2_hub1cbfdfec6fa7e0b16e220ff391ac48f_114116_300x200_fit_box_2.png&#34; width=&#34;244&#34; height=&#34;200&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Servicios y su estado registrados en el servicio de registro y descubrimiento&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew discoveryserver:run --args=&amp;#34;--spring.profiles.active=ds1&amp;#34;&lt;/code&gt;.
&lt;/p&gt;</content><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2018/08/aplicaciones-basadas-en-microservicios/</id><title>Aplicaciones basadas en microservicios</title><updated>2018-09-02T12:00:00+02:00</updated><published>2018-08-31T18:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/08/aplicaciones-basadas-en-microservicios/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;La arquitectura de las aplicaciones está cambiando en lo que era lo habitual hace no tanto. Con el desarrollo de las redes de comunicación entre computadoras tanto en una red local con ethernet como en internet con el protocolo TCP/IP se desarrollaron las primeras aplicaciones cliente/servidor como es un servidor web y un navegador o una base de datos y una aplicación.&lt;/p&gt;
&lt;p&gt;A las páginas HTML de los servidores web, estáticas hasta entonces, se les añadió lógica de servidor para procesar datos y generar el contenido dinámicamente, se crearon las aplicaciones web ejecutadas en el servidor en un principio en lo que ahora denominamos monolitos en forma de &lt;a href=&#34;https://es.wikipedia.org/wiki/C%C3%B3digo_espagueti&#34;&gt;código espagueti&lt;/a&gt; o más estructurado con los denominados &lt;em&gt;frameworks&lt;/em&gt; del lenguaje de programación de turno empleando el &lt;a href=&#34;https://es.wikipedia.org/wiki/Programaci%C3%B3n_por_capas&#34;&gt;modelo de tres capas&lt;/a&gt; formadas por la presentación, lógica y base de datos.&lt;/p&gt;
&lt;p&gt;Más recientemente con las nuevas posibilidades de la virtualización, los contenedores, la computación en nube con la flexibilidad que aporta de reservar recursos de computación bajo demanda en minutos y para evitar varios problemas que presentan los monolitos se evoluciona hacia microservicios. Esto no quiere decir que los monolitos con este nombre con cierto matiz peyorativo que ha adquirido no sigan siendo perfectamente válidos en algunos contextos en los que ahora se usan sin embargo en el contexto de la computación en la nube y servicio para un gran número de peticiones, usuarios o aplicación funcionalmente grande los microservicios son una mejor adaptación.&lt;/p&gt;
&lt;p&gt;Los problemas que presentan las aplicaciones monolíticas donde toda la lógica está en una aplicación en un servidor son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Son grandes y difíciles de modificar.&lt;/li&gt;
&lt;li&gt;Realizan múltiples funcionalidades.&lt;/li&gt;
&lt;li&gt;Hay un único punto de fallo, un error puede afectar al sistema entero.&lt;/li&gt;
&lt;li&gt;Requieren escalar el monolito entero lo que es poco eficiente.&lt;/li&gt;
&lt;li&gt;Hacen muy difícil emplear la tecnología más adecuada para cada problema de la aplicación o adoptar nuevas.&lt;/li&gt;
&lt;li&gt;Los despliegues de nuevas versiones pueden ser problemáticos por el tamaño de la aplicación.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/aplicaciones-basadas-en-microservicios/images/monolith_hub198199ec8a492668d0853105928e4f9_159372_2560x1440_fit_box_2.png&#34; title=&#34;Arquitectura basada en 3 capas&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/aplicaciones-basadas-en-microservicios/images/monolith_hub198199ec8a492668d0853105928e4f9_159372_600x450_fit_box_2.png&#34; width=&#34;600&#34; height=&#34;219&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Arquitectura basada en 3 capas&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Los microservicios surgen como alternativa tratando de resolver los problemas de las aplicaciones monolíticas aunque planteando nuevos retos pero también varios beneficios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Las aplicaciones basadas en microservicios se componen de múltiples aplicaciones cada una con un contexto delimitado pequeño que se comunican mediante la red.&lt;/li&gt;
&lt;li&gt;Son más pequeños con una base de código menor y por tanto más fáciles de modificar o en su caso reemplazar siempre se implemente la misma interfaz o contrato.&lt;/li&gt;
&lt;li&gt;No son tan dependientes de la tecnología pudiendo elegir la más adecuada en cada uno de ellos.&lt;/li&gt;
&lt;li&gt;Al ser más pequeños se pueden escalar más fácilmente horizontalmente si no mantienen estado, basta con escalar el servicio que lo requiera.&lt;/li&gt;
&lt;li&gt;Arrancan más rápido y son más fáciles de desplegar.&lt;/li&gt;
&lt;li&gt;Cada microservicio puede estar desarrollado por un equipo diferente centrado en ese servicio.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pueden ser una aplicación que ofrezca una API en forma de REST, &lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt; o RPC para una determinada funcionalidad o una aplicación que consuma otros microservicios y proporcione la interfaz para un navegador web.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/08/aplicaciones-basadas-en-microservicios/images/microservices_huec52a617b10c65603c9de79792885935_24996_2560x1440_fit_box_2.png&#34; title=&#34;Arquitectura basada en microservicios&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/08/aplicaciones-basadas-en-microservicios/images/microservices_huec52a617b10c65603c9de79792885935_24996_600x450_fit_box_2.png&#34; width=&#34;600&#34; height=&#34;290&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Arquitectura basada en microservicios&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Algunos nuevos retos de los microservicios son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Añaden complejidad. Son más numerosos y requieren más procesos para su ejecución. Esto obliga a automatizar su gestión para que sea manejable con el menor número de tareas manuales posibles. Forman un sistema distribuido.&lt;/li&gt;
&lt;li&gt;Difícil integrar cambios si afectan a varios servicios.&lt;/li&gt;
&lt;li&gt;Cada microservicio al ser responsable de sus propios datos y formar un sistema de información distribuido plantea problemas en como compartirlos y dificultando la transaccionalidad y consistencia del sistema, se suele optar por una eventual consistencia. Al estar los datos distribuidos se plantea la dificultad de elaborar informes, una posibilidad es consolidar los datos en un única base de datos para la tarea mediante exportaciones de las bases de datos origen.&lt;/li&gt;
&lt;li&gt;Como centralizar los registros de trazas.&lt;/li&gt;
&lt;li&gt;Como centralizar los accesos.&lt;/li&gt;
&lt;li&gt;Obtener métricas y monitorización, a nivel de microservicio (cpu, memoria, espacio disco, red, &amp;hellip;) y de negocio (eventos, operaciones, transacciones, &amp;hellip;).&lt;/li&gt;
&lt;li&gt;Como hacer que los microservicios se descubran entre ellos.&lt;/li&gt;
&lt;li&gt;Si un microservicios falla los que dependan de él fallarán, al comunicarse por un medio no totalmente fiable como la red se pueden producir errores. El sistema se ha de hacer tolerante a fallos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para modelar los microservicios y definir que funcionalidad contiene cada uno de los que forman el sistema se opta por utilizar &lt;em&gt;bounded contex&lt;/em&gt; y &lt;em&gt;domain driven design&lt;/em&gt;. Cada microservicio debe ser altamente cohesivo donde toda su funcionalidad esté relacionada y realizar una o muy pocas tareas siendo propietario de los datos de su contexto delimitado.&lt;/p&gt;
&lt;p&gt;En el ámbito Java el proyecto &lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt; se compone de varios adaptados a la nueva realidad de los microservicios y &lt;a href=&#34;http://www.oracle.com/technetwork/java/javaee/overview/index.html&#34;&gt;Java EE&lt;/a&gt; a partir de la versión 8 ahora denominada &lt;a href=&#34;https://jakarta.ee/&#34;&gt;Jakarta EE&lt;/a&gt; y &lt;a href=&#34;https://microprofile.io/&#34;&gt;Microprofile&lt;/a&gt; proporcionan funcionalidades más adaptadas a las necesidades de las arquitecturas basadas en microservicios.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; como una forma de embeber en una aplicación Java con un servidor web de forma que la aplicación sea autocontenida y no requiera un servidor web preinstalado.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.spring.io/spring-cloud-config/&#34;&gt;Spring Cloud Config&lt;/a&gt; para gestionar la configuración.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://projects.spring.io/spring-session/&#34;&gt;Spring Session&lt;/a&gt; para hacer que los microservicios web no mantengan estado y sean escalables.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready&#34;&gt;Spring Boot Actautor&lt;/a&gt; para monitorización y métricas.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/eureka&#34;&gt;Eureka&lt;/a&gt; para registro y descubrimiento de servicios.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/Hystrix&#34;&gt;Hystrix&lt;/a&gt; con una implementación del patrón &lt;em&gt;circuit breaker&lt;/em&gt; para proporcionar resilencia.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;De varios de estos proyectos ya he escrito varios artículos pero escribiré algunos más para completar varias áreas que aún no he comentado. Algunos de ellos serán:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Como hacer el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/09/registro-y-descubrimiento-de-servicios-con-spring-cloud-netflix/&#34;&gt;descubrimiento de servicios con Spring Cloud utilizando el servidor Eureka&lt;/a&gt; mostrando incluso como crear un &lt;em&gt;cluster&lt;/em&gt; de servicios de descubrimiento para mayor disponibilidad y tolerancia a fallos, esto útil al mismo tiempo que de gran importancia ya que este servicio es crítico para el correcto funcionamiento de los microservicios.&lt;/li&gt;
&lt;li&gt;Como crear un &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/09/servicio-de-configuracion-para-microservicios-con-spring-cloud-config/&#34;&gt;servicio de configuración del cual los microservicios obtengan su configuración&lt;/a&gt; por ejemplo según el entorno o para mantenerla centralizada, este servicio también es crítico y requiere de varias instancias de este servicio.&lt;/li&gt;
&lt;li&gt;Como mantener cifrada partes sensibles de la configuración como son las contraseñas, &lt;em&gt;bearers&lt;/em&gt; de autenticación, URLs de conexión u otra información especialmente sensible para la seguridad.&lt;/li&gt;
&lt;li&gt;Como cambiar la configuración de los microservicios sin necesidad de reiniciarlos.&lt;/li&gt;
&lt;li&gt;Un cliente que realiza balanceo de carga entre múltiples instancias de los servicios utilizando Ribbon.&lt;/li&gt;
&lt;li&gt;Un cliente de microservicio que implementa el patrón &lt;em&gt;circuit breaker&lt;/em&gt; con la librería Hystrix y &lt;em&gt;timeouts&lt;/em&gt; para ser tolerante a fallos al llamar a otros microservicios.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Según vaya escribiendo y publicando los artículos aparecerán en la lista de la serie de artículos. El ejemplo en el que me basaré para estos lo añado a continuación.&lt;/p&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt;.
&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://articles.microservices.com/monolithic-vs-microservices-architecture-5c4848858f59&#34;&gt;Monolithic vs. Microservices Architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2017/01/registro-y-descubrimiento-de-servicios-con-spring-cloud-y-consul/</id><title>Registro y descubrimiento de servicios con Spring Cloud y Consul</title><updated>2017-01-28T11:00:00+01:00</updated><published>2017-01-28T11:00:00+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/01/registro-y-descubrimiento-de-servicios-con-spring-cloud-y-consul/"/><author><name>picodotdev</name></author><content type="html">
&lt;p&gt;&lt;strong&gt;Tradicionalmente el conectar un servicio con sus servicios dependientes se ha realizado por configuración, normalmente mediante un nombre de dominio y su puerto. Esta configuración estática es suficiente para unos pocos servicios y que no varían durante su funcionamiento. Con el advenimiento de los microservicios con su estado y número cambiantes en el tiempo han surgido varias herramientas para en vez de usar configuración usar descubrimiento. Una de estas herramientas Consul para la que Spring Cloud proporciona integración.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;En una aplicación con una arquitectura de microservicios esta se compone de múltiples partes cambiantes. Los microservicios pueden aparecer, desaparecer, variar en número o cambiar de ubicación, la aplicación debe ser tolerante a esos cambios y seguir proporcionando su servicio. Por tanto, la configuración de red de los servicios no se puede realizar usando direcciones &lt;abbr title=&#34;Internet Protocol&#34;&gt;IP&lt;/abbr&gt; ya que no se conocen las que utilizarán los microservicios y usar nombres de dominio de &lt;abbr title=&#34;Domain Name System&#34;&gt;DNS&lt;/abbr&gt; puede no ser viable ya que los cambios tardan en propagarse. Conocer el nombre de &lt;em&gt;host&lt;/em&gt; y puerto reales de los microservicios es proporcionado por la funcionalidad de descubrimiento de servicios o &lt;em&gt;service discovery&lt;/em&gt; que proporcionan algunos servicios como &lt;a href=&#34;https://github.com/Netflix/eureka&#34;&gt;Eureka&lt;/a&gt;, &lt;a href=&#34;https://www.consul.io/&#34;&gt;Consul&lt;/a&gt; o &lt;a href=&#34;https://zookeeper.apache.org/&#34;&gt;Apache Zookeper&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;En este artículo explicaré como usar la parte de descubrimiento de servicios de Consul usando una aplicación con &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; y con &lt;a href=&#34;https://projects.spring.io/spring-cloud/&#34;&gt;Spring Cloud&lt;/a&gt;. Spring Cloud proporciona varias cosas comunes para aplicaciones basadas en microservicios. Si aún no conoces las herramientas en las que se basará el ejemplo puedes consultar los siguientes artículos específicos como introducción:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2012/03/herramienta-de-construccion-gradle.html&#34;&gt;Herramienta de construcción Gradle &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-de-multiproyecto-con-gradle/&#34;&gt;Ejemplo de multiproyecto con Gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/10/aplicacion-java-autocontenida-con-spring-boot/&#34;&gt;Aplicación Java autocontenida con Spring Boot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/11/configuracion-de-una-aplicacion-en-diferentes-entornos-con-spring-cloud-config/&#34;&gt;Configuración de una aplicación en diferentes entornos con Spring Cloud Config&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Consul además de descubrimiento de servicios proporciona otras funcionalidades como detección de fallos o caídas para prevenir enviar peticiones a máquinas fuera de servicio y almacenamiento básico clave/valor para configuración dinámica o activación de características. Dispone de una aplicación web en la que podemos ver el estado de los servicios, una &lt;a href=&#34;https://www.consul.io/docs/agent/http.html&#34;&gt;API REST&lt;/a&gt; con la que comunicarse con Consul en una aplicación o en cada microservicio y un servidor de nombres &lt;abbr&gt;DNS&lt;/abbr&gt;, podemos usar cualquiera de las dos interfaces de consulta, la basada en la &lt;abbr&gt;API&lt;/abbr&gt; &lt;abbr&gt;REST&lt;/abbr&gt; o la basada en DNS para obtener las direcciones IP con la ubicación de los servicios.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/206/consul.png&#34; alt=&#34;Consul&#34; title=&#34;Consul&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Instalar Consul es muy sencillo basta con &lt;a href=&#34;https://www.consul.io/downloads.html&#34;&gt;descargar un binario&lt;/a&gt; y descargar la interfaz web si queremos tener el &lt;em&gt;dashboard&lt;/em&gt; con la información del servicio. Descargados y descomprimidos Consul se inicia con el siguiente comando. Podemos acceder al panel &lt;em&gt;dashboard&lt;/em&gt; con la dirección &lt;em&gt;http://localhost:8500&lt;/em&gt; con un navegador web. Inicialmente en el panel de servicios solo se encuentra el propio de Consul cuando aún no se ha registrado ningún servicio, aplicación o microservicio.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/69ebe9c83419447cdcfc4692988938a2.js?file=consul.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Una aplicación que use Spring Boot y que quiera hacer pública su disponibilidad en Consul basta con que use la anotación &lt;code&gt;@EnableDiscoveryClient&lt;/code&gt; en la clase de inicio de la aplicación junto con las dependencias adecuadas. Con la declaración de esta anotación y la dependencia &lt;em&gt;spring-cloud-starter-consul-all&lt;/em&gt; Spring se comunicará con Consul a través de la API REST para registrar cuando se inicie la aplicación, su nombre, nombre de máquina y puerto en el que estará disponible.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/69ebe9c83419447cdcfc4692988938a2.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;Spring Cloud proporciona además un servicio que podemos usar para conocer los servicios registrados en Consul, con la clase &lt;em&gt;DiscoveryClient&lt;/em&gt; podemos conocer los nombres de los servicios, su nombre de máquina y puerto desde una aplicación Java. En el método &lt;em&gt;run&lt;/em&gt; de la clase &lt;em&gt;Main&lt;/em&gt; se usa en este ejemplo para imprimir en la salida el listado de servicios registrados en Consul. Uno de esos servicios esta aplicación de ejemplo, ya que se registra en Consul cuando se inicia.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/206/consul-services.png&#34; title=&#34;Servicios registrados en Consul&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/206/consul-services-thumb.png&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Servicios registrados en Consul&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Consul para conocer que los servicios siguen en funcionamiento hace una petición &lt;abbr&gt;HTTP&lt;/abbr&gt; cada ciertos segundos a una ruta de la aplicación, Spring Boot proporciona una dependencia, &lt;em&gt;spring-boot-starter-actuator&lt;/em&gt;, que usada provee del &lt;em&gt;endpoint /health&lt;/em&gt; para que Consul monitorice el estado del servicio.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/69ebe9c83419447cdcfc4692988938a2.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/206/service-health.png&#34; title=&#34;Endpoint de estado de servicio&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/206/service-health-thumb.png&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Endpoint de estado de servicio&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Esta es la salida en la consola listando los servicios disponibles, siendo uno de ellos esta aplicación.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/69ebe9c83419447cdcfc4692988938a2.js?file=System.out&#34;&gt;&lt;/script&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloudConsul&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./consul/consul.sh y ./gradlew run&lt;/code&gt;.
&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://projects.spring.io/spring-cloud/&#34;&gt;Spring Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.spring.io/spring-cloud-consul/&#34;&gt;Spring Cloud Consul&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="blog-stack"/><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2015/12/informacion-y-metricas-de-la-aplicacion-con-spring-boot-actuator/</id><title>Información y métricas de la aplicación con Spring Boot Actuator</title><updated>2015-12-11T23:25:00+01:00</updated><published>2015-12-04T17:30:00+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/12/informacion-y-metricas-de-la-aplicacion-con-spring-boot-actuator/"/><author><name>picodotdev</name></author><content type="html">
&lt;p&gt;&lt;strong&gt;Desarrollar una aplicación no solo implica implementar su funcionalidad, esa aplicación ha de mantenerse funcionando en su entorno de producción. Monitorizar y disponer de información sobre el estado ayuda a mantenerla funcionando sin ninguna caída de servicio u obtener métricas para mejorar su funcionamiento. Entre las numerosas funcionalidades ofrecidas por Spring para las aplicaciones Java está Spring Boot Actuator que precisamente nos proporcionará métricas e información interesantes de serie pudiendo implementar nueva según la necesidades.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Es conveniente tener monitorizado el estado de una aplicación para conocer si el servicio que ofrece está funcionando o en caso de que no conocerlo cuanto antes para restaurarlo además de conocer otra serie de métricas básicas como la cantidad de &lt;abbr title=&#34;Central Processing Unit&#34;&gt;CPU&lt;/abbr&gt; que se está usando, la cantidad de memoria usada y libre, número de &lt;em&gt;threads&lt;/em&gt; instanciados, espacio ocupado y libre en disco, actividad de entrada y salida ya sea de red o de disco, tiempo de inicio del sistema y de la aplicación. Otras métricas a nivel de aplicación que puede interesarnos conocer es número de usuarios conectados, número de sesiones, páginas vistas, sentencias SQL o transacciones ejecutadas, &amp;hellip; que podemos obtener directamente desde la aplicación o combinándolo con otras herramientas como &lt;a href=&#34;https://www.google.es/intl/es/analytics/&#34;&gt;Google Analytics&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Monitorizar el estado de la aplicación nos permitirá conocer en poco tiempo si hay algo que va mal con la intención de restaurar el servicio con el menor tiempo de caída, también nos permitirá conociendo las métricas normales del servicio si hay algún parámetro fuera de los valores típicos como un consumo excesivo de CPU, memoria o disco, conociendo la normalidad podremos descubrir la anormalidad y después corregirla, cuanto antes sea descubierta más sencillo será determinar el cambio que la ha provocado.&lt;/p&gt;
&lt;p&gt;Continuando la serie de artículos sobre &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; y &lt;a href=&#34;https://projects.spring.io/spring-cloud/&#34;&gt;Spring Cloud&lt;/a&gt; comentaré la utilidad &lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready&#34;&gt;Spring Boot Actuator&lt;/a&gt; que precisamente proporciona métricas y permite monitorizar una aplicación. En un aplicación que use Spring Boot simplemente incluyendo la dependencia &lt;em&gt;org.springframework.boot:spring-boot-starter-actuator&lt;/em&gt; se añadirán a la aplicación varios &lt;em&gt;endpoints&lt;/em&gt; para consultar información. Hay varios, estos son solo algunos de la &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints&#34;&gt;lista completa&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;beans&lt;/em&gt;: permite conocer los &lt;em&gt;beans&lt;/em&gt; de la aplicación.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;configprops&lt;/em&gt;: muestra las propiedades de configuración.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;env&lt;/em&gt;: muestra información de la clase &lt;a href=&#34;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/env/ConfigurableEnvironment.html&#34;&gt;ConfigurableEnvironment&lt;/a&gt; que incluye propiedades del sistema.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;health&lt;/em&gt;: permite conocer si la aplicación está en funcionamiento.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;info&lt;/em&gt;: muestra información arbitraria sobre la aplicacion.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;metrics&lt;/em&gt;: permite obtener los valores de las métricas.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;trace&lt;/em&gt;: información de las últimas peticiones a la aplicación.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Salvo &lt;em&gt;health&lt;/em&gt; e &lt;em&gt;info&lt;/em&gt; los demás &lt;em&gt;endpoints&lt;/em&gt; contienen información sensible y no son accesibles pudiendo requerir un usuario/contraseña según como se configure el permiso para su acceso. Con las propiedades de configuración booleanas &lt;code&gt;endpoints.[endpoint].sensitive&lt;/code&gt; y &lt;code&gt;endpoints.[endpoint].enabled&lt;/code&gt; se puede cambiar si el servicio se considera sensible y si está activado respectivamente. Para permitir el acceso sin restricciones a las métricas y habilitar el &lt;em&gt;endpoint&lt;/em&gt; para detener la aplicación necesitaríamos establecer las siguientes propiedades de configuración:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/69b393c6a00fdd4f3ca3.js?file=application.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;El &lt;em&gt;endpoint&lt;/em&gt; &lt;em&gt;info&lt;/em&gt; mostrará todas las propiedades con el patrón &lt;code&gt;info.*&lt;/code&gt; y con el &lt;em&gt;plugin&lt;/em&gt; de &lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt; &lt;em&gt;com.gorylenko.gradle-git-properties&lt;/em&gt; también podremos conocer el &lt;em&gt;commit&lt;/em&gt; y rama del código fuente del archivo &lt;em&gt;.jar&lt;/em&gt; en ejecución. Se pueden implementar nuevos indicadores de salud escribiendo un componente de Spring que implemente la interfaz &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/actuate/health/HealthIndicator.html&#34;&gt;HealthIndicator&lt;/a&gt;. Con la propiedad de configuración &lt;code&gt;management.context-path&lt;/code&gt; se puede cambiar el &lt;em&gt;path&lt;/em&gt; usado para todos los &lt;em&gt;endpoint&lt;/em&gt; de forma que no colisione con los propios de la aplicación. También se puede cambiar el puerto y dirección &lt;abbr title=&#34;Internet Protocol&#34;&gt;IP&lt;/abbr&gt; de la aplicación en el que se ofrecen los &lt;em&gt;endpoints&lt;/em&gt; con las propiedad de configuración &lt;code&gt;management.port&lt;/code&gt; y &lt;code&gt;management.address&lt;/code&gt; y protegerlos con un cortafuegos. Dependiendo de la combinación de seguridad requerida y consideración de sensibilidad se muestra más información o solo información de estado.&lt;/p&gt;
&lt;p&gt;Las métricas ofrecidas en el &lt;em&gt;endpoint&lt;/em&gt; &lt;em&gt;metrics&lt;/em&gt; por Spring Boot Actuator muestran información del sistema (memoria total, procesadores, tipo de inicio de aplicación y sistema, carga media, memoria usada, &lt;em&gt;threads&lt;/em&gt;, clases cargadas y información del recolector de basura de Java), información de los &lt;em&gt;datasource&lt;/em&gt; (número de conexiones establecidas y uso actual), métricas de las caches, usando &lt;a href=&#34;https://tomcat.apache.org/&#34;&gt;Tomcat&lt;/a&gt; de las sesiones (actuales y máximas). Haciendo uso de los servicios de Spring &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/actuate/metrics/CounterService.html&#34;&gt;CounterService&lt;/a&gt; y &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/actuate/metrics/GaugeService.html&#34;&gt;GaugeService&lt;/a&gt; se pueden establecer métricas relativas y absolutas en cualquier punto de la aplicación con la lógica que deseemos.&lt;/p&gt;
&lt;p&gt;En la aplicación Spring Boot incluyendo la dependencia de Spring Boot Actuator en el archivo &lt;em&gt;build.gradle&lt;/em&gt; del proyecto podemos acceder a los &lt;em&gt;endpoints&lt;/em&gt; comentados en las &lt;abbr title=&#34;Uniform Resource Locator&#34;&gt;URL&lt;/abbr&gt; según el puerto y contexto de la interfaz de administración.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/69b393c6a00fdd4f3ca3.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/113/spring-boot-actuator-health.png&#34; title=&#34;Spring Boot Actuator endpoint Health&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/113/spring-boot-actuator-health-thumb.png&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Spring Boot Actuator endpoint Health&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/113/spring-boot-actuator-env.png&#34; title=&#34;Spring Boot Actuator endpoint Env&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/113/spring-boot-actuator-env-thumb.png&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Spring Boot Actuator endpoint Env&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/113/spring-boot-actuator-metrics.png&#34; title=&#34;Spring Boot Actuator endpoint Metrics&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/113/spring-boot-actuator-metrics-thumb.png&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Spring Boot Actuator endpoint Metrics&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Spring Boot Actuator es otro de los varios módulos disponibles en Spring Boot. Para conocer más en detalle cuales son sus posibilidades el libro &lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.es/gp/product/1617292540/ref=as_li_ss_tl?ie=UTF8&amp;camp=3626&amp;creative=24822&amp;creativeASIN=1617292540&amp;linkCode=as2&amp;tag=blobit-21&#34;&gt;Spring Boot in Action&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=as2&amp;o=30&amp;a=1617292540&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt; lo explica bastante bien.&lt;/p&gt;
&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
&lt;iframe src=&#34;https://rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=1617292540&amp;internal=1&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;De cualquier modo conviene también tener automatizada la monitorización de las métricas. Con estos &lt;em&gt;endpoints&lt;/em&gt; y una herramienta como &lt;a href=&#34;http://prometheus.io&#34;&gt;Prometheus&lt;/a&gt; podemos visualizar gráficas generadas con los datos a lo largo del tiempo, con los datos visualizados de forma gráfica podremos ver rápidamente picos, cambios bruscos y tendencias en alguno de ellos o compararlos con tiempos pasados. Esta misma herramienta nos puede servir para enviar alertas y notificaciones o hacer consultas sobre los datos recolectados.&lt;/p&gt;
&lt;p&gt;Con Uptime Robot y el &lt;em&gt;endpoint&lt;/em&gt; &lt;em&gt;health&lt;/em&gt; podemos &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/12/monitorizar-estado-de-sitios-web-con-uptime-robot/&#34;&gt;monitorizar la aplicación y recibir notificaciones&lt;/a&gt; si en algún momento la aplicación deja de responder.&lt;/p&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringBoot&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/10/aplicacion-java-autocontenida-con-spring-boot/&#34;&gt;Aplicación Java autocontenida con Spring Boot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/11/configuracion-de-una-aplicacion-en-diferentes-entornos-con-spring-cloud-config/&#34;&gt;Configuración de una aplicación en diferentes entornos con Spring Cloud Config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/12/monitorizar-estado-de-sitios-web-con-uptime-robot/&#34;&gt;Monitorizar estado de sitios web con Uptime Robot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="blog-stack"/><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2015/11/configuracion-de-una-aplicacion-en-diferentes-entornos-con-spring-cloud-config/</id><title>Configuración de una aplicación en diferentes entornos con Spring Cloud Config</title><updated>2015-12-11T22:00:00+01:00</updated><published>2015-11-28T11:00:00+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/11/configuracion-de-una-aplicacion-en-diferentes-entornos-con-spring-cloud-config/"/><author><name>picodotdev</name></author><content type="html">
&lt;p&gt;&lt;strong&gt;La configuración de una aplicación suele varíar según el entorno en el que se ejecuta, la opción recomendada es que este externalizada y que el artefacto que se despliega en cada entorno sea el mismo. Con Spring Cloud Config en vez de guardar la configuración en un archivo de la propia máquina donde se instala podemos guardar de forma centralizada en un repositorio y que la aplicación obtenga la versión más actualizada cuando se inicia. En este ejemplo explicaré como crear el servidor de configuraciones con Spring Cloud Config y un ejemplo de cliente con Spring Boot que le solicita su configuración según su entorno.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Desarrollar una aplicación no consiste solo en programar el código que proporciona su funcionalidad, con igual de importancia está como poner en producción esa aplicación para que preste su servicio, algo de lo que el desarrollador no debería ser ajeno. Casi siempre hay algo de configuración que varia entre entornos siendo estos al menos el de desarrollo y producción. En el ciclo de vida de una aplicación esta pasa por varios entornos de ejecución hasta llegar a producción, desde desarrollo, pruebas, &lt;abbr title=&#34;Quality assurance&#34;&gt;QA&lt;/abbr&gt; y finalmente en producción. Casi seguro que la aplicación en cada uno de estos entornos la configuración varía, por ejemplo, las direcciones ya sean IP o nombres de dominio de las bases de datos relacional u otros servicios externos. Para que en el entorno de pruebas y QA se use exactamente el mismo artefacto (en Java un archivo war o jar) que el que se enviaría al entorno de producción la configuración de la aplicación no debería ser incluida en el propio artefacto, si la configuración fuese incluida en el propio artefacto sería distinto que el que se enviaría a producción y las pruebas no válidas, podría haber alguna diferencia en la construcción del artefacto para cada entorno.&lt;/p&gt;
&lt;p&gt;El proyecto &lt;a href=&#34;https://projects.spring.io/spring-cloud/&#34;&gt;Spring Cloud&lt;/a&gt; con &lt;a href=&#34;https://cloud.spring.io/spring-cloud-config/&#34;&gt;Spring Cloud Config&lt;/a&gt; proporciona un mecanismo para externalizar y actualizar de forma sencilla las varias configuraciones de una aplicación en los diferentes entornos en los que se vaya a ejecutar. La opción recomendada es crear un repositorio de Git donde se almacenarán las diferentes configuraciones de la aplicación para cada entorno y bajo un sistema de control de versiones. El que las configuraciones se obtengan de un repositorio y con &lt;a href=&#34;https://git-scm.com/&#34;&gt;Git&lt;/a&gt; evita que el archivo de configuración esté como un fichero regular en cada máquina del entorno de ejecución, duplicados si hay varias máquinas o con algunas diferencias en cada una. En caso de tener solo una máquina si deja de funcionar o ser accesible perderíamos el archivo de configuración y los cambios que hubiésemos hecho en él directamente, al mismo tiempo estando en un sistema de control de versiones como Git tendremos un histórico de los cambios realizados.&lt;/p&gt;
&lt;p&gt;En el caso de este ejemplo usaré la opción del sistema de archivos en vez de Git por ser más sencilla para el ejemplo. Spring Cloud Config usa una arquitectura cliente/servidor en la que cada aplicación al iniciarse solicitará su configuración en función del entorno para el que se desee ejecutar. Spring Cloud Config no solo es usable en aplicaciones Java sino que al proporcionar una &lt;abbr title=&#34;Application Programming Interface&#34;&gt;API&lt;/abbr&gt; &lt;abbr title=&#34;Representational State Transfer&#34;&gt;REST&lt;/abbr&gt; y devolver documentos &lt;abbr title=&#34;JavaScript Object Notation&#34;&gt;JSON&lt;/abbr&gt; puede ser usado por cualquier lenguaje popular (&lt;a href=&#34;http://www.microsoft.com/net&#34;&gt;C#&lt;/a&gt;, &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt;, &lt;a href=&#34;https://www.ruby-lang.org/es/&#34;&gt;Ruby&lt;/a&gt;, &lt;a href=&#34;http://www.groovy-lang.org/&#34;&gt;Groovy&lt;/a&gt;, &amp;hellip;).&lt;/p&gt;
&lt;p&gt;Para el ejemplo me basaré en varios artículos que he escrito anteriormente como &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2012/03/herramienta-de-construccion-gradle.html&#34;&gt;la herramienta de construcción Gradle&lt;/a&gt; ya que con esta herramienta construiré el proyecto, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-de-multiproyecto-con-gradle/&#34;&gt;multiproyectos con Gradle&lt;/a&gt; dado que el ejemplo se dividirá en dos, la parte cliente y la parte servidor y &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/10/aplicacion-java-autocontenida-con-spring-boot/&#34;&gt;aplicación autocontenida con Spring Boot&lt;/a&gt; como forma de iniciar tanto la aplicación cliente como servidor, también como obtener &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/12/informacion-y-metricas-de-la-aplicacion-con-spring-boot-actuator/&#34;&gt;información y métricas de la aplicación con Spring Boot Actuator&lt;/a&gt;. Recomiendo leer estos artículos si no las conoces aún.&lt;/p&gt;
&lt;p&gt;Para la parte servidor deberemos incluir como dependencia en el archivo &lt;em&gt;build.gradle&lt;/em&gt; la propia del servidor de Spring Cloud Config, &lt;em&gt;org.springframework.cloud:spring-cloud-config-server&lt;/em&gt;, y dos archivos de configuración, &lt;em&gt;application.yml&lt;/em&gt; y &lt;em&gt;bootstrap.yml&lt;/em&gt; donde indicaremos el puerto donde escuchará la aplicación y la ruta del sistema de ficheros del repositorio de configuraciones. En la clase que inicia el servidor con &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; usaremos la anotación &lt;code&gt;@EnableConfigServer&lt;/code&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8f1cb4de86c56e21edb9.js?file=Main-server.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8f1cb4de86c56e21edb9.js?file=build-server.gradle&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8f1cb4de86c56e21edb9.js?file=application.yml&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8f1cb4de86c56e21edb9.js?file=bootstrap-server.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;En el repositorio de configuraciones cada combinación de aplicación y entorno de ejecución tendrá su propio archivo de configuración. En el caso de una aplicación de nombre &lt;em&gt;springcloudclient&lt;/em&gt; que se ejecuta en los entornos &lt;em&gt;dev&lt;/em&gt;, &lt;em&gt;test&lt;/em&gt; y &lt;em&gt;prod&lt;/em&gt; los archivos serían los siguientes. Cada archivo tiene similares propiedades de configuración pero posiblemente variando los valores de cada una de ellas. Los archivos pueden definirse en varios formatos, en este caso usando &lt;abbr title=&#34;YAML Ain&#39;t Another Markup Language&#34;&gt;YAML&lt;/abbr&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8f1cb4de86c56e21edb9.js?file=springcloudclient-dev.yml&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8f1cb4de86c56e21edb9.js?file=springcloudclient-test.yml&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8f1cb4de86c56e21edb9.js?file=springcloudclient-prod.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;En la búsqueda de las ubicaciones de los archivos de configuración se siguen los siguientes patrones, en el caso del ejemplo he usado la segunda opción, el primero que se encuentre es el que se usa:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;/{application}/{profile}[/{label}]&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;/{application}-{profile}.yml&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;/{label}/{application}-{profile}.yml&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;/{application}-{profile}.properties&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;/{label}/{application}-{profile}.properties&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Este sería el inicio del servidor de configuración y el documento JSON que devuelve para la aplicación &lt;em&gt;springcloudclient&lt;/em&gt; para el entorno &lt;em&gt;prod&lt;/em&gt; en una petición &lt;abbr title=&#34;Hypertext Transfer Protocol&#34;&gt;HTTP&lt;/abbr&gt;.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/30811.js&#34; id=&#34;asciicast-30811&#34; async&gt;&lt;/script&gt;
&lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/30811&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/30811.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
&lt;figcaption&gt;Inicio del servidor Spring Cloud Config&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/112/spring-cloud-client-prod.png&#34; title=&#34;Configuración de la aplicación para el entorno de producción&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/112/spring-cloud-client-prod-thumb.png&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;Configuración de la aplicación para el entorno de producción&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;La aplicación cliente cuando se inicie solicitará su configuración al servidor Spring Cloud Config mediante una petición HTTP en función del entorno para el que se inicie. Deberemos usar la dependencia &lt;em&gt;org.springframework.cloud:spring-cloud-starter-config&lt;/em&gt;. Para obtener los valores de las propiedades de configuración podemos usar la anotación &lt;code&gt;@Value&lt;/code&gt;. En los archivos &lt;em&gt;application.yml&lt;/em&gt; y &lt;em&gt;bootstrap.yml&lt;/em&gt; indicamos el perfil para el cual se activará la aplicación y podemos especificar la &lt;abbr title=&#34;Uniform Resource Locator&#34;&gt;URL&lt;/abbr&gt; con la localización del servidor de configuración.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8f1cb4de86c56e21edb9.js?file=Main-client.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8f1cb4de86c56e21edb9.js?file=build-client.gradle&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/8f1cb4de86c56e21edb9.js?file=bootstrap-client.yml&#34;&gt;&lt;/script&gt;
&lt;p&gt;Si no queremos obtener las propiedades con la anotación &lt;code&gt;@Value&lt;/code&gt; podemos usar el &lt;em&gt;bean&lt;/em&gt; &lt;a href=&#34;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/env/Environment.html&#34;&gt;Environment&lt;/a&gt; que define Spring y sus métodos &lt;em&gt;getProperty&lt;/em&gt; con el que además podremos averiguar los perfiles activos de la aplicación. Por otra parte las mismas propiedades de configuración del cliente podemos especificarlos mediante parámetros, propiedades de sistema, propiedades de entorno y algunas formas más como se explica en como &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html&#34;&gt;externalizar la configuración en las aplicaciones Spring&lt;/a&gt;. De cualquiera de estas formas podemos indicar o sobreescribir los valores como puede ser el perfil activo de la aplicación.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/30810.js&#34; id=&#34;asciicast-30810&#34; async&gt;&lt;/script&gt;
&lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/30810&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/30810.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
&lt;figcaption&gt;Inicio de aplicación cliente de servidor Spring Cloud Config&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Este ejemplo solo muestra una pequeña parte de las posibilidades que ofrece Spring Cloud Config, otras son la posibilidad de &lt;a href=&#34;http://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_serving_plain_text&#34;&gt;servir archivos de configuración completos&lt;/a&gt; para por ejemplo &lt;a href=&#34;https://nginx.org/&#34;&gt;Nginx&lt;/a&gt;, los valores de las propiedades de configuración en el repositorio de configuración pueden ser cifradas y al enviarlas al cliente ser descifradas. Spring Cloud Config solo es una pequeña parte del proyecto Spring Cloud que proporciona más funcionalidades útiles para sistemas distribuidos y microservicios y un complemento adicional interesante para Spring Boot.&lt;/p&gt;
&lt;p&gt;
El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringCloud&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew cloudconfig:run &amp;amp;&amp;amp; ./gradlew clouddiscovery:run &amp;amp;&amp;amp; ./gradlew service:run &amp;amp;&amp;amp; ./gradlew client:run&lt;/code&gt;.
&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2012/03/herramienta-de-construccion-gradle.html&#34;&gt;Herramienta de construcción Gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-de-multiproyecto-con-gradle/&#34;&gt;Ejemplo de multiproyecto con Gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/10/aplicacion-java-autocontenida-con-spring-boot/&#34;&gt;Aplicación Java autocontenida con Spring Boot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/12/informacion-y-metricas-de-la-aplicacion-con-spring-boot-actuator/&#34;&gt;Información y métricas de la aplicación con Spring Boot Actuator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://projects.spring.io/spring-cloud/&#34;&gt;Spring Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.spring.io/spring-cloud-config/&#34;&gt;Spring Cloud Config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cloud.spring.io/spring-cloud-config/spring-cloud-config.html&#34;&gt;Documentación Spring Cloud Config&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="blog-stack"/><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2015/10/aplicacion-java-autocontenida-con-spring-boot/</id><title>Aplicación Java autocontenida con Spring Boot</title><updated>2015-12-06T12:00:00+01:00</updated><published>2015-10-13T00:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/10/aplicacion-java-autocontenida-con-spring-boot/"/><author><name>picodotdev</name></author><content type="html">
&lt;p&gt;&lt;strong&gt;Si queremos una aplicación Java autocontenida ya sea una aplicación de linea de comandos, de escritorio o aplicación web que use el contenedor de dependencias de Spring podemos usar Spring Boot. Además de inicializar el contenedor IoC de Spring, Spring Boot proporciona en una aplicación web elegir el servidor de aplicaciones de entre el por defecto Tomcat y los seleccionables Jetty y Undertow junto con algunas funcionalidades más.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/spring.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Spring&#34; title=&#34;Spring&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Tradicionalmente las aplicaciones Java web han sido instaladas en un contenedor de &lt;em&gt;servlets&lt;/em&gt; como &lt;a href=&#34;https://tomcat.apache.org/&#34;&gt;Tomcat&lt;/a&gt; o &lt;a href=&#34;https://eclipse.org/jetty/&#34;&gt;Jetty&lt;/a&gt; y &lt;a href=&#34;http://wildfly.org/&#34;&gt;Wildfly&lt;/a&gt;, &lt;a href=&#34;https://www.jboss.org/&#34;&gt;JBoss&lt;/a&gt; o &lt;a href=&#34;http://www.oracle.com/us/products/middleware/cloud-app-foundation/weblogic/overview/index.html&#34;&gt;Weblogic&lt;/a&gt; si necesita más servicios que son ofrecidos por la plataforma &lt;abbr title=&#34;Java Enterprise Edition&#34;&gt;Java EE&lt;/abbr&gt; completa como &lt;abbr title=&#34;Java Message Service&#34;&gt;JMS&lt;/abbr&gt;, &lt;abbr title=&#34;Java Persistence API&#34;&gt;JPA&lt;/abbr&gt;, &lt;abbr title=&#34;Java Transaction API&#34;&gt;JTA&lt;/abbr&gt; o &lt;abbr title=&#34;Enterprise JavaBeans&#34;&gt;EJB&lt;/abbr&gt;. Aunque las aplicaciones se ejecutan independientemente unas de otras comparten el entorno de ejecución del servidor de aplicaciones, algunas aplicaciones no necesitarán todos los servicios que ofrecen los servidores de aplicaciones en su implementación del perfil completo Java EE y algunas nuevas aplicaciones pueden necesitar hacer uso de una nueva versión de un servicio como JMS con funcionalidades mejoradas. En el primer caso algunos servicios son innecesarios y en el segundo la actualización del servidor de aplicaciones se ha de producir para todas las aplicaciones que en él se ejecuten o tener varias versiones del mismo servidor de aplicaciones e ir instalando las aplicaciones en la versión del servidor según las versiones de los servicios para las que se desarrolló la aplicación.&lt;/p&gt;
&lt;p&gt;Los microservicios proponen una aproximación diferente al despliegue de las aplicaciones prefiriendo entre otros aspectos que sean autocontenidos de tal forma que puedan evolucionar independieintemente unas de otras. Se puede &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/03/aplicacion-web-java-autocontenida-con-tomcat-embedded/&#34;&gt;ejecutar una aplicación web Java de forma autocontenida con la versión embebida de Tomcat&lt;/a&gt;, Jetty también ofrece una versión embebible que puede usarse de forma similar de tal modo que ya no necesitemos instalar previamente además del &lt;abbr title=&#34;Java Development Kit&#34;&gt;JDK&lt;/abbr&gt; la versión del servidor de aplicaciones que necesite.&lt;/p&gt;
&lt;p&gt;Otra forma de poder hacer la aplicación autocontenida es con &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt;, internamente usa una versión embebible del servidor de aplicaciones de la misma forma que lo podemos usar directamente, la ventaja al usar Spring Boot es que soporta Tomcat, Jetty o &lt;a href=&#34;http://undertow.io/&#34;&gt;Undertow&lt;/a&gt; y pasar de usar uno a otro es muy sencillo y prácticamente transparente para la aplicación, además proporciona algunas características adicionales como inicializar el contenedor &lt;abbr title=&#34;Inversion of Control&#34;&gt;IoC&lt;/abbr&gt; de &lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt;, configuración, perfiles para diferentes entornos (desarrollo, pruebas, producción), monitorización y métricas del servidor de aplicaciones y soporte para &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2012/03/herramienta-de-construccion-gradle.html&#34;&gt;la herramienta de automaticación Gradle&lt;/a&gt; entre algunas más. En el siguiente ejemplo mostraré como ejecutar una aplicación Java y una aplicación web Java con Spring Boot que usa &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/alternativa-a-hibernate-u-orm-y-ejemplo-de-jooq/&#34;&gt;jOOQ como alternativa a Hibernate&lt;/a&gt;, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/libro-sobre-desarrollo-de-aplicaciones-con-apache-tapestry/&#34;&gt;Apache Tapestry como &lt;em&gt;framework&lt;/em&gt; web&lt;/a&gt;, &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2013/05/modificar-la-base-de-datos-con-liquibase.html&#34;&gt;Liquibase para crear el esquema y tablas de la base de datos&lt;/a&gt; y por simplicidad &lt;a href=&#34;http://www.h2database.com/html/main.html&#34;&gt;H2&lt;/a&gt; como base de datos.&lt;/p&gt;
&lt;p&gt;Los mostrado en este artículo es solo una pequeña parte de lo que ofrece Sring Boot, en el libro &lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.es/gp/product/1617292540/ref=as_li_ss_tl?ie=UTF8&amp;camp=3626&amp;creative=24822&amp;creativeASIN=1617292540&amp;linkCode=as2&amp;tag=blobit-21&#34;&gt;Spring Boot in Action&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=as2&amp;o=30&amp;a=1617292540&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt; se comenta en mucho más detalle y de forma didáctica, un libro muy recomendable para adentrarse rápidamente en ste nuevo mundo de posibilidades.&lt;/p&gt;
&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
&lt;iframe src=&#34;https://rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=1617292540&amp;internal=1&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;Spring Boot proporciona un &lt;em&gt;plugin&lt;/em&gt;, &lt;em&gt;spring-boot&lt;/em&gt;, para &lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt; que deberemos añadir al archivo &lt;em&gt;build.gradle&lt;/em&gt;, a partir de este momento dispondremos algunas tareas adicionales en el proyecto como &lt;em&gt;bootRun&lt;/em&gt; para ejecutar la aplicación desde Gradle (similar a la opción &lt;em&gt;run&lt;/em&gt; y el parámetro &lt;em&gt;mainClassName&lt;/em&gt; que añade el &lt;em&gt;plugin application&lt;/em&gt;) y &lt;em&gt;bootRepackage&lt;/em&gt; para poder ejecutar la aplicación con el comando &lt;code&gt;java -jar&lt;/code&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/3819a18dcdde7cbeeb6c.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;p&gt;El punto de inicio de una aplicación de Spring Boot es una clase Java con su tradicional método &lt;em&gt;main&lt;/em&gt;, en el ejemplo la clase &lt;em&gt;Main&lt;/em&gt;. Bastan tres lineas para iniciar la aplicación y una anotación. Anotando con &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/SpringBootApplication.html&#34;&gt;&lt;code&gt;@SpringBootApplication&lt;/code&gt;&lt;/a&gt; la clase que contiene el método &lt;em&gt;main&lt;/em&gt; activaremos Spring Boot y el procesado de las anotaciones de Spring. En el método &lt;em&gt;main&lt;/em&gt; estableciendo la clase contexto de la aplicación variaremos el tipo de aplicación &lt;a href=&#34;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/AnnotationConfigApplicationContext.html&#34;&gt;AnnotationConfigApplicationContext&lt;/a&gt; para una aplicación de linea de comandos o de escritorio y &lt;a href=&#34;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/support/AnnotationConfigWebApplicationContext.html&#34;&gt;AnnotationConfigWebApplicationContext&lt;/a&gt; para las aplicaciones web que inicializará el servidor de aplicaciones embebido. Implementando la interfaz &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/CommandLineRunner.html&#34;&gt;CommandLineRunner&lt;/a&gt; en la clase que contiene la anotación &lt;em&gt;SpringBootApplication&lt;/em&gt; y su método &lt;em&gt;run&lt;/em&gt; será el punto de entrada de la aplicación, en el método recibiremos los parámetros de la linea de comandos. Implementar esta interfaz es opcional en las aplicaciones web.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/3819a18dcdde7cbeeb6c.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;La clase &lt;em&gt;AppConfiguration&lt;/em&gt; contiene la definición de &lt;em&gt;beans&lt;/em&gt; propios del contenedor de inversión de control de las aplicaciones que serán inyectados en las clases donde se indiquen. Pero además definiendo algunos &lt;em&gt;beans&lt;/em&gt; podremos configurar el servidor de aplicaciones embebido y la aplicación. Con el &lt;em&gt;bean&lt;/em&gt; &lt;a href=&#34;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/SpringServletContainerInitializer.html&#34;&gt;ServletContextInitializer&lt;/a&gt; podemos definir parámetros de inicialización, filtros, &lt;em&gt;servlets&lt;/em&gt;, listeners, propiedades de &lt;em&gt;cookies&lt;/em&gt; y obtener información del entorno. Con el &lt;em&gt;bean&lt;/em&gt; &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/embedded/EmbeddedServletContainerCustomizer.html&#34;&gt;EmbeddedServletContainerCustomizer&lt;/a&gt; podemos añadir páginas de error para estados como 404 o 500, configurar el puerto de servicio, establecer la dirección IP, el contexto de la aplicación, directorio raíz de archivos del servidor web, SSL/TLS y tiempo de vida de las sesiones. Con el &lt;em&gt;bean&lt;/em&gt; &lt;a href=&#34;http://docs.spring.io/autorepo/docs/spring-boot/current/api/org/springframework/boot/context/embedded/tomcat/TomcatConnectorCustomizer.html&#34;&gt;TomcatConnectorCustomizer&lt;/a&gt; se pueden personalizar diferentes parámetros del conector y con el &lt;em&gt;bean&lt;/em&gt; &lt;a href=&#34;http://docs.spring.io/autorepo/docs/spring-boot/current/api/org/springframework/boot/context/embedded/tomcat/TomcatContextCustomizer.html&#34;&gt;TomcatContextCustomizer&lt;/a&gt; varios parámetros del contexto que en un Tomcat instalado como paquete de software configuraríamos mediante el archivo de configuración &lt;em&gt;server.xml&lt;/em&gt; o &lt;em&gt;context.xml&lt;/em&gt;. Para que las peticiones se procesen por el &lt;em&gt;framework&lt;/em&gt; web Tapestry se define su filtro en el ejemplo o si fuese el caso un &lt;em&gt;servlet&lt;/em&gt;. Toda esta configuración es similar a lo que definimos en el archivo &lt;em&gt;web.xml&lt;/em&gt;, pero en código Java al ser validado por el compilador es menos propenso a errores que los archivos de texto xml.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/3819a18dcdde7cbeeb6c.js?file=AppConfiguration.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;No será muy común pero si queremos configurar algunas propiedades internas como las &lt;a href=&#34;https://tomcat.apache.org/tomcat-8.0-doc/config/valve.html&#34;&gt;válvulas de Tomcat&lt;/a&gt; que funcionalmente es similar a un filtro de una aplicación web Java podemos definir un &lt;em&gt;bean&lt;/em&gt; del tipo &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/embedded/tomcat/TomcatEmbeddedServletContainerFactory.html&#34;&gt;TomcatEmbeddedServletContainerFactory&lt;/a&gt;, con esta factoría además podremos configurar muchas de las propiedades que podemos configurar con ServletContextInitializer y EmbeddedServletContainerCustomizer pero salvo por las válvulas que es específico de Tomcat la forma preferida hacer la configuración es con estas últimas clases.&lt;/p&gt;
&lt;p&gt;Si en vez de usar Tomcat queremos usar Jetty o Undertow debemos cambiar las dependencias de la aplicación, excluimos la dependencia transitiva Tomcat y por defecto de &lt;em&gt;spring-boot-starter-web&lt;/em&gt; e incluimos la propia del servidor que deseemos.
&lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-use-jetty-instead-of-tomcat&#34;&gt;spring-boot-starter-jetty&lt;/a&gt; para Jetty y &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-use-undertow-instead-of-tomcat&#34;&gt;spring-boot-starter-undertow&lt;/a&gt; para Undertow. En el siguiente código la configuración a modificar en el archivo &lt;em&gt;build.gradle&lt;/em&gt; para ambas.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/3819a18dcdde7cbeeb6c.js?file=build-jetty.gradle&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/3819a18dcdde7cbeeb6c.js?file=build-undertow.gradle&#34;&gt;&lt;/script&gt;
&lt;p&gt;El resto de esta aplicación de ejemplo es propio de &lt;a href=&#34;https://www.jooq.org/&#34;&gt;jOOQ&lt;/a&gt; y de &lt;a href=&#34;https://tapestry.apache.org/&#34;&gt;Apache Tapestry&lt;/a&gt;. Para inicializar la base de datos H2 antes de ejecutar la aplicación debemos ejecutar la tarea de Gradle &lt;em&gt;updataDatabase&lt;/em&gt; que creará las base de datos, esquema y tablas con la herramienta &lt;a href=&#34;http://www.liquibase.org/&#34;&gt;Liquibase&lt;/a&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/3819a18dcdde7cbeeb6c.js?file=update-database.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringBoot&#34;&gt;código fuente del ejemplo completo&lt;/a&gt; puedes encontrarlo en el repositorio de ejemplos de Blog Bitix, arrancarlo y acceder con el navegador a la dirección &lt;a href=&#34;http://127.0.0.1:8080/&#34;&gt;http://127.0.0.1:8080/&lt;/a&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/3819a18dcdde7cbeeb6c.js?file=run.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;En el siguiente vídeo puede verse como es la salida en la terminal cuando la aplicación se arranca con Gradle y con el comando &lt;code&gt;java -jar&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/27694.js&#34; id=&#34;asciicast-27694&#34; async&gt;&lt;/script&gt;
&lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/27694&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/27694.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
&lt;figcaption&gt;Uso de Spring Boot con Gradle y Java&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Añadiendo la dependencia &lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready&#34;&gt;Spring Boot Actuator&lt;/a&gt; podemos &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/12/informacion-y-metricas-de-la-aplicacion-con-spring-boot-actuator/&#34;&gt;obtener información de estado y métricas en las aplicaciones Spring Boot&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;En un repositorio de GitHub de Spring hay muchos más &lt;a href=&#34;https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples&#34;&gt;ejemplos sobre Spring Boot&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/&#34;&gt;Documentación de Spring Boot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/12/informacion-y-metricas-de-la-aplicacion-con-spring-boot-actuator/&#34;&gt;Información y métricas de aplicación con Spring Boot Actuator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/11/configuracion-de-una-aplicacion-en-diferentes-entornos-con-spring-cloud-config/&#34;&gt;Configuración de una aplicación en diferentes entornos con Spring Cloud Config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/03/aplicacion-web-java-autocontenida-con-tomcat-embedded/&#34;&gt;Aplicación web Java de forma autontenida con la versión embebida de Tomcat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2012/03/herramienta-de-construccion-gradle.html&#34;&gt;La herramienta de automaticación Gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/alternativa-a-hibernate-u-orm-y-ejemplo-de-jooq/&#34;&gt;Alternativa a Hibernate u ORM y ejemplo de jOOQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="blog-stack"/><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2015/03/datos-de-sesion-externalizados-con-spring-session/</id><title>Datos de sesión externalizados con Spring Session</title><updated>2015-03-08T03:30:00+01:00</updated><published>2015-03-07T09:05:06+01:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/03/datos-de-sesion-externalizados-con-spring-session/"/><author><name>picodotdev</name></author><content type="html">
&lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;
&lt;p&gt;Por defecto los datos de la sesión de una aplicación web Java se guardan en el servidor de aplicaciones y en memoria, esto produce que al reiniciar el servidor por un despliegue los datos de la sesión se pierdan y provoque en los usuarios alguna molestia como tener que volver a iniciar sesión. En &lt;a href=&#34;https://tomcat.apache.org/&#34;&gt;Tomcat&lt;/a&gt; existe la posibilidad de que los datos de las sesiones sean persistidas en disco con la opción &lt;em&gt;saveOnRestart&lt;/em&gt; del &lt;a href=&#34;http://tomcat.apache.org/tomcat-8.0-doc/config/manager.html&#34;&gt;elemento de configuración &lt;em&gt;Manager&lt;/em&gt;&lt;/a&gt; que evita que los datos de las sesiones se pierdan en los reinicios, al menos para los servicios formados por una única instancia. Para evitar que los usuarios perciban los reinicios o caídas del servidor hay varias soluciones algunas tratando de diferentes formas externalizar las sesiones del servidor de aplicaciones. Con estas soluciones se pueden hacer despliegues sin caídas, sin que las perciban los usuarios, siendo útil para hacer actualizaciones frecuentemente, continuos, y en cualquier momento cuando tengamos una nueva versión de la aplicación.&lt;/p&gt;
&lt;p&gt;Las soluciones más comentadas son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Cluster&lt;/em&gt; de servidores: para evitar las caídas podemos formar un &lt;em&gt;cluster&lt;/em&gt; de máquinas de forma que si una se reinicia las peticiones sean atendidas por el resto de servidores del &lt;em&gt;cluster&lt;/em&gt;. Añadiendo una poca configuración se puede formar un &lt;a href=&#34;http://tomcat.apache.org/tomcat-8.0-doc/cluster-howto.html&#34;&gt;&lt;em&gt;cluster&lt;/em&gt; de servidores Tomcat&lt;/a&gt;. Si el &lt;em&gt;cluster&lt;/em&gt; está formado por unos pocos servidores esta solución es válida pero si el &lt;em&gt;cluster&lt;/em&gt; es grande (¿media docena de máquinas?) el tráfico que se genera para sincronizar los datos de sesión en todas las máquinas puede ser significativo, momento en el cual se opta por otras soluciones.&lt;/li&gt;
&lt;li&gt;Sesión en base de datos relacional: los datos de la sesión se pueden guardar en una base de datos relacional, al llegar una petición al servidor se recupera de la base de datos la sesión con una consulta y al finalizar la petición se lanza otra consulta de actualización. En las aplicaciones la base de datos suele ser un cuello de botella prefiriéndose guardar la sesión en otro servidor que no sea el servidor de base de datos para no generarle más carga.&lt;/li&gt;
&lt;li&gt;Caché externa: en esta opción los datos se guardan en un servidor externo al servidor de aplicaciones de forma que todos los servidores del &lt;em&gt;cluster&lt;/em&gt; las compartan pero no en la base de datos relacional, algunas opciones que se pueden utilizar son &lt;a href=&#34;https://memcached.org/&#34;&gt;memcached&lt;/a&gt; o &lt;a href=&#34;https://redis.io/&#34;&gt;redis&lt;/a&gt; que almacenan los datos en memoria y son muy rápidas. Esta opción añade una pieza más a la infraestructura de la aplicación que hay que mantener. En este artículo pondré un ejemplo usando esta opción utilizando Spring Session y un servidor Redis.&lt;/li&gt;
&lt;li&gt;Sesión en &lt;em&gt;cookie&lt;/em&gt;: para no añadir una pieza más a la infraestructura del servidor se puede externalizar la sesión en el cliente mediante una &lt;em&gt;cookie&lt;/em&gt;. Como la &lt;em&gt;cookie&lt;/em&gt; es enviada por el navegador cliente en cada petición el servidor puede recuperar los datos de la sesión. Sin embargo, como los datos son guardados en el cliente los datos de la &lt;em&gt;cookie&lt;/em&gt; han de ser cifrados y firmados digitalmente para evitar problemas de seguridad ante modificaciones de los datos. También deberemos evitar guardar muchos datos y tendremos cierta limitación para que la &lt;em&gt;cookie&lt;/em&gt; no sea grande, el tamaño recomendado no exceder es 4096 bytes si lo hacemos puede que ocasionemos errores con el mensaje &lt;em&gt;400 bad request, request header or cookie too large&lt;/em&gt; y consuma mucho ancho de banda, hay que tener en cuenta que las &lt;em&gt;cookies&lt;/em&gt; son enviadas en cada petición al servidor origen no solo para las peticiones dinámicas sino también para los recursos estáticos como imágenes u hojas de estilos, si las &lt;em&gt;cookies&lt;/em&gt; son grandes y el número de usuarios también el ancho de banda consumido por las &lt;em&gt;cookies&lt;/em&gt; puede ser significativo, en estos últimos casos &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/07/servir-recursos-estaticos-desde-un-cdn-en-apache-tapestry/&#34;&gt;empleando un CDN&lt;/a&gt; puede aliviarse el tráfico generado. En la siguiente página podemos encontrar los &lt;a href=&#34;http://browsercookielimits.squawky.net/&#34;&gt;límites de las cookies para cada navegador y el número máximo por dominio&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Usando &lt;a href=&#34;https://projects.spring.io/spring-session/&#34;&gt;Spring Session&lt;/a&gt; podemos externalizar los datos de la sesión en un servidor Redis usándolo como caché externa. Para demostrar y enseñar el código necesario he creado una pequeña aplicación web con &lt;a href=&#34;https://projects.spring.io/spring-framework/&#34;&gt;Spring MCV&lt;/a&gt;. El controlador no tiene nada especial, obtiene la sesión y guarda los datos que necesita. Usando la anotación &lt;em&gt;@EnableRedisHttpSession&lt;/em&gt; activamos la infraestructura necesaria en el contenedor de Spring para guardar los datos de la sesión en Redis. Por supuesto deberemos añadir las dependencias que necesitemos en la herramienta de construcción que usemos.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/69e8c57980f6c9d0f1b8.js?file=SessionController.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/69e8c57980f6c9d0f1b8.js?file=Initializer.java&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/69e8c57980f6c9d0f1b8.js?file=Config.java&#34;&gt;&lt;/script&gt;
&lt;p&gt;Descargado el &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringSession&#34;&gt;código fuente de la aplicación de ejemplo&lt;/a&gt; se puede iniciar con:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/picodotdev/69e8c57980f6c9d0f1b8.js?file=gradlew.sh&#34;&gt;&lt;/script&gt;
&lt;p&gt;Lanzando una petición se puede ver como el Redis se guardan los datos de la sesión. Podemos detener el servidor y volverlo a iniciar y comprobaremos que los datos de la sesión no se han perdido al estar persistidos en redis.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/70/dato-en-sesion.png&#34; title=&#34;Dato en sesión&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/70/dato-en-sesion-thumb.png&#34;/&gt;&lt;/a&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/70/cookie-navegador.png&#34; title=&#34;Cookie de sesión en el navegador&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/70/cookie-navegador-thumb.png&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Examinando los datos en redis podemos ver que se ha creado una clave con el mismo identificativo de la cookie &lt;em&gt;SESSION&lt;/em&gt;, en la clave están guardados los valores serializados entre ellos el nombre del atributo y su valor y otros datos como la fecha de creación, el último acceso y el intervalo máximo de inactividad antes de la expiración.&lt;/p&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
&lt;figure&gt;
&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/70/contenido-sesion-redis.png&#34; title=&#34;Contenido sesión en redis&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2015/70/contenido-sesion-redis-thumb.png&#34;/&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;En el momento de escribir este artículo Spring Session es un proyecto reciente y solo soporta la opción de Redis como caché externa pero seguramente con nuevas versiones soporte otras opciones como memcached, guardar la sesión en una &lt;em&gt;cookie&lt;/em&gt; o en una base de datos relacional. La solución propuesta por Spring Session es válida para cualquier servidor de aplicaciones ya que se basa en crear un filtro en la aplicación que proporciona una versión modificada de &lt;a href=&#34;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSession.html&#34;&gt;HttpSession&lt;/a&gt; mediante el cual se guardan los datos de forma externa.&lt;/p&gt;
&lt;p&gt;Otras posibilidades ofrecidas por Spring Session son múltiples sesiones en la misma instancia del navegador y soporte para aplicaciones RESTful y WebSocket.&lt;/p&gt;
&lt;p&gt;Otra posibilidad similar es usar memcached mediante la librería &lt;a href=&#34;https://code.google.com/p/memcached-session-manager/&#34;&gt;memcached-session-manager&lt;/a&gt; aunque es una solución específica para Tomcat.&lt;/p&gt;
&lt;div class=&#34;reference&#34;&gt;
Referencia:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://projects.spring.io/spring-session/&#34;&gt;Spring Session&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.shinetech.com/2012/12/18/simple-session-sharing-in-tomcat-cluster-using-the-session-in-cookie-pattern/&#34;&gt;Simple Session-Sharing in Tomcat Cluster Using the Session-in-Cookie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tomcat.apache.org/tomcat-8.0-doc/cluster-howto.html&#34;&gt;Tomcat Cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://code.google.com/p/memcached-session-manager/&#34;&gt;Memcached Session Manager&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><category term="blog-stack"/><category term="java"/><category term="planeta-codigo"/><category term="programacion"/></entry></feed>

<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://picodotdev.github.io/blog-bitix/series/docker/index.xml</id>
    <title type="text">Blog Bitix</title>
    <subtitle>Recent content on Blog Bitix</subtitle>
    <updated>0001-01-01T00:00:00+00:00</updated>
    <author><name>pico.dev</name></author>
    <generator>Hugo</generator>
    <icon>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</icon>
    <logo>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</logo>
    <rights>https://creativecommons.org/licenses/by-sa/4.0/</rights>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/</id>
        <title>Introducción y ejemplo de cluster de contenedores con Docker Swarm</title>        
        <updated>2017-03-19T12:00:00+01:00</updated>
        <published>2017-03-19T12:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Las funcionalidades de Docker Swarm están incorporadas en Docker para gestionar &lt;em&gt;clusters&lt;/em&gt; de nodos con contenedores de los servicios que deseemos. En artículo comentaré algunas de las propiedades de &lt;em&gt;networkning&lt;/em&gt; distribuido incorporado en Docker, como crear un &lt;em&gt;cluster&lt;/em&gt; de nodos Docker usando VirtualBox con máquinas virtuales para simular múltiples máquinas junto con como lanzar un servicio en el &lt;em&gt;cluster&lt;/em&gt; que en este caso consistirá en un servidor web nginx.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/docker.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Docker&#34; title=&#34;Docker&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/docker/&#34;&gt;artículos anteriores de la serie sobre Docker&lt;/a&gt; comentaba varias de las herramientas de &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; como &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker Compose&lt;/a&gt;, Dockerfile o &lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker Machine&lt;/a&gt; con ejemplos de como usarlo en local. Una de las herramientas que me quedaba por investigar era &lt;a href=&#34;https://docs.docker.com/swarm/&#34;&gt;Docker Swarm&lt;/a&gt; para crear &lt;em&gt;clusters&lt;/em&gt; de nodos para contenedores Docker en un entorno de producción. A partir de la versión 1.12 de Docker se han incorporado varias características a Docker para usaar contenedores de forma distribuida y que a pesar de la complejidad subjacente que debe haber es realmente simple usarlo.&lt;/p&gt;

&lt;p&gt;Una de las características es el &lt;em&gt;networking&lt;/em&gt; que hace trasnparente la comunicación en red distribuida que se hace entre los nodos y los contenedores de esos nodos. Además permite crear redes por software para que los contenedores conectados a esas redes se comuniquen de forma privada. Otra característica interesante de Docker Swarm es que se encarga de monitorizar el estado de los servicios recreando contendores si alguno deja de funcionar. También a través del denominado &lt;em&gt;routing mesh&lt;/em&gt; da igual al nodo del &lt;em&gt;cluster&lt;/em&gt; por el que se acceda y da igual en que nodo esté el contenedor que Docker Swarm con esta propiedad se encargará de hacer llegar la petición al contenedor. Además, a lo que en Docker Swarm se denomina servicio se realiza balanceo de carga entre la instancias del mismo que haya en el &lt;em&gt;cluster&lt;/em&gt; y al servicio se le asigna un DNS y dirección IP por el que puede ser accedido por otros servicios.&lt;/p&gt;

&lt;p&gt;En el siguiente ejemplo para crear el &lt;em&gt;cluster&lt;/em&gt; de nodos Docker usaré Docker Machine para crear las máquinas de los nodos en máquinas virtuales de &lt;a href=&#34;http://virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt; aunque su funcionamiento es similar si usásemos la nube de &lt;a href=&#34;http://aws.amazon.com/es/ec2/&#34;&gt;Amazon EC2&lt;/a&gt;, &lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;Digital Ocean&lt;/a&gt; u otros.&lt;/p&gt;

&lt;p&gt;El siguiente &lt;em&gt;script&lt;/em&gt; crea primeramente varios nodos cada uno en una máquina virtual, luego establece el nodo 01 como &lt;em&gt;manager&lt;/em&gt; y los nodos 02 y 03 como &lt;em&gt;workers&lt;/em&gt; usando un &lt;em&gt;token&lt;/em&gt; para unirlos al &lt;em&gt;cluster&lt;/em&gt; según su rol. Los nodos &lt;em&gt;manager&lt;/em&gt; se encargan de mantener el estado del &lt;em&gt;cluster&lt;/em&gt; y los que a través de ellos los comandos de los servicios deben ser lanzados, en un entorno de producción posiblemente tendríamos 3 nodos &lt;em&gt;manager&lt;/em&gt; para soportar tolerancia a fallos. Finalmente, se obtiene lista los nodos del &lt;em&gt;cluster&lt;/em&gt;. El comando &lt;em&gt;docker-machine env node-01&lt;/em&gt; permite establecer el entorno contra el que el comando &lt;em&gt;docker&lt;/em&gt; lanzará las operaciones como si de la máquina local se tratase.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=cluster-create.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una vez creado los nodos es cuando podemos empezar a crear servicios en el &lt;em&gt;cluster&lt;/em&gt;. Los servicios son una definición de los contenedores de Docker que queremos que el &lt;em&gt;cluster&lt;/em&gt; ejecute. En el ejemplo definiré el servicio de un servidor web &lt;a href=&#34;http://nginx.org/&#34;&gt;nginx&lt;/a&gt;, primeramente crearé una red por software en el &lt;em&gt;cluster&lt;/em&gt; a la que los servicios pueden conectarse que en el ejemplo (aunque para este no es necesario) utilizaré para hacer una consulta DNS con la herramienta &lt;a href=&#34;https://linux.die.net/man/1/drill&#34;&gt;drill&lt;/a&gt; para ver el nombre de dominio y dirección IP que asigna Docker Swarm al servicio del servidor web. Con &lt;em&gt;docker service create&lt;/em&gt; se crean los servicios, algunos de los parámetros del comando son el nombre del servicio que queremos asignarle, los puertos que expone en este caso el 80 y 443 en el &lt;em&gt;host&lt;/em&gt; para que sea accesible desde fuera del &lt;em&gt;cluster&lt;/em&gt;, la redes a las que está conectado y finalmente la imagen del contenedor del servicio que en este caso será la versión de &lt;a href=&#34;https://hub.docker.com/_/nginx/&#34;&gt;nginx con Alpine para Docker&lt;/a&gt;. Se pueden listar los servicios que contiene el &lt;em&gt;cluster&lt;/em&gt; con &lt;em&gt;docker service ls&lt;/em&gt; y los procesos de cada nodo donde podemos ver en que nodos se está ejecutando los contenedores con &lt;em&gt;docker ps&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=nginx-create.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una de las propiedades interesantes del &lt;em&gt;networking&lt;/em&gt; de Docker Swarm es que ofrece incorporado balanceo de carga, esto es, si el servicio de nginx del ejemplo estuviese formado por dos instancias las peticiones se distribuirían entre las instancias usando el método &lt;em&gt;round-robin&lt;/em&gt;. Otra característica interesante si se observa el ejemplo con detalle es que da igual el nodo al que hagamos la petición que la respuesta se obtendrá igualmente, esto es, aunque la petición se haga al nodo 01 y realmente el contenedor del servidor nginx se esté ejecutando en el nodo 02 la petición se realizará correctamente gracias al &lt;em&gt;routing mesh&lt;/em&gt; del &lt;em&gt;neworking&lt;/em&gt; de Docker Swarm, esto es gracias a que cada servicio tiene asignada una dirección IP, como se ha visto anteriormente en la salida del comando &lt;em&gt;drill&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;En este vídeo de &lt;a href=&#34;https://asciinema.org/&#34;&gt;asciinema&lt;/a&gt; se ve en funcionamiento todos los anteriores comandos. Y en la aplicación de VirtualBox estarán las máquinas virtuales de cada uno de los nodos que crea el ejemplo. En el vídeo se aprecia que el servicio de nginx se está ejecutando en el nodo 02 cuando se listan los procesos de Docker de cada nodo con &lt;em&gt;docker ps&lt;/em&gt;, nótese sin embargo que al hacer un petición HTTP a cualquiera de los nodos se devuelve la página de inicio de nginx ya que gracias al &lt;em&gt;routing mesh&lt;/em&gt; de Docker Swarm la petición se redirige de forma transparente para el cliente y el servicio al nodo donde realmente se está ejecutando el contenedor de nginx.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/107868.js&#34; id=&#34;asciicast-107868&#34; async&gt;&lt;/script&gt;
        &lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/107868&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/107868.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
        
        &lt;figcaption&gt;Introducción y ejemplo de cluster de contenedores con Docker Swarm&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/div&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/216/maquinas-virtuales-cluster.png&#34; title=&#34;Máquinas virtuales de los nodos del _cluster_ de Docker Swarm&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/216/maquinas-virtuales-cluster-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Máquinas virtuales de los nodos del _cluster_ de Docker Swarm&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Los comandos para eliminar un servicio del &lt;em&gt;cluster&lt;/em&gt; y eliminar completamente el &lt;em&gt;cluster&lt;/em&gt; son los siguientes.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=nginx-remove.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=cluster-remove.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Un libro que me ha gustado mucho y que recomiendo leer sobre Docker Swarm es &lt;a href=&#34;http://amzn.to/2mIirti&#34;&gt;The Devops 2.1 Toolkit&lt;/a&gt; que lo explica detalladamente y todo el libro está orientado a como usarlo en un entorno de producción. Un libro más introductorio que también he leído y que está bastante bien es &lt;a href=&#34;http://amzn.to/2mF3Xtj&#34;&gt;Docker in Action&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=a6c4acab72c208d29232f2e0a8edb8ee&#34;&gt;&lt;/iframe&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1542468914&amp;linkId=2101ae950cfcfe9e69b6cc1210e4bf2c&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Finalmente, quizás si estás usando GNU/Linux y VirtualBox como yo al crear los nodos con el comando &lt;em&gt;docker-machine&lt;/em&gt; te produzca el siguiente error (quizá se corrija en futuras versiones de Docker o VirtualBox).&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=vboxnet0-error.out&#34;&gt;&lt;/script&gt;

&lt;p&gt;La solución que he encontrado para que funcione es asignar una dirección IP al adaptador puente solo-anfitrión y levantar la interfaz que usa Docker para comunicarse con las máquinas virtuales previamente a crear el nodo. En &lt;a href=&#34;https://www.archlinux.org/&#34;&gt;Arch Linux&lt;/a&gt; con los siguientes comandos.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=vboxnet0-configure.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Se puede definir un conjunto de servicios como una unidad en un archivo en &lt;em&gt;stacks&lt;/em&gt; de forma similar a como es posible hacer con Docker Compose cosa que mostraré en otro artículo.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/DockerSwarm&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/</id>
        <title>Cambiar la ruta raíz del entorno de Docker</title>        
        <updated>2015-11-14T12:00:00+02:00</updated>
        <published>2015-07-24T20:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/07/cambiar-la-ruta-raiz-del-entorno-de-docker/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Cambiando la ruta raíz del entorno de ejecución de docker, dónde guarda las imágenes de los contenedores, los datos de los contenedores y otros metadatos, podemos almacenar esta información en un disco duro externo o memoria USB.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/docker.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Docker&#34; title=&#34;Docker&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Por defecto el directorio donde se guardan las imágenes y los contenedores junto con otros metadatos de &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; es &lt;em&gt;/var/lib/docker&lt;/em&gt;. En mi caso hace un tiempo me compre un &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/desempaquetado-y-analisis-samsung-840-evo-ssd-250-gb/&#34;&gt;disco de estado sólido Samsung 840 EVO de 250 GiB&lt;/a&gt; y comenté en el artículo del anterior enlace. Aunque probablemente un disco SSD sea suficientemente fiable como para que antes de que falle cambiémos de ordenador porque ya es antiguo, yo trato de evitar hacer muchas escrituras al disco. Al trabajar con Docker ya sea descargando imágenes, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/&#34;&gt;construyendo imágenes propias con archivos Dockerfile&lt;/a&gt; y al arrancar contenedores cuyos procesos escriben en disco prefiero externalizar esas escrituras en una unidad USB ya sea un pendrive o un disco duro. En este artículo comentaré como modificar Docker para que las imágenes y los contenedores estén almacenados en una memoria USB o en otra localización de la por defecto.&lt;/p&gt;

&lt;p&gt;En Arch Linux el proceso de docker se arranca con un servicio de systemd:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1dd776471f97f0c383a9.js?file=docker-start.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;En la definición del servicio de docker se establecen los parámetros de inicio del demonio de docker y deberemos cambiarlo para cambiar la localización de las imágenes y contenedores. En la información de ayuda del comando de docker podemos ver que si queremos cambiar la localización por defecto de las imágenes y contenedores de docker debemos emplear la opción &lt;em&gt;-g &amp;ldquo;/var/lib/docker&amp;rdquo;&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1dd776471f97f0c383a9.js?file=docker-help.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;En Arch Linux el servicio de systemd de docker se guarda en &lt;em&gt;/usr/lib/systemd/system/docker.service&lt;/em&gt;. Modificando el parámetro &lt;em&gt;ExecStart&lt;/em&gt; de la sección &lt;em&gt;[Service]&lt;/em&gt; para añadir el parámetro &lt;em&gt;-g&lt;/em&gt; nos quedaría algo como:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1dd776471f97f0c383a9.js?file=docker.service&#34;&gt;&lt;/script&gt;

&lt;p&gt;Iniciando ahora el servicio de Docker veremos que en el directorio que hayamos elegido se crean los metadatos y si hacemos un &lt;em&gt;pull&lt;/em&gt; de una imagen se guardará en esta localización.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/91/docker-root.png&#34; title=&#34;Directorio raíz de docker&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/91/docker-root.png&#34;&gt;&lt;/a&gt;
        &lt;figcaption&gt;Directorio raíz de docker&lt;/figcaption&gt;
    &lt;/figure&gt;
&lt;/div&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  Cada vez que se actualice el paquete de docker el archivo del servicio de systemd se sobreescribirá y perderemos la configuración, de modo que en cada actualización de docker deberemos realizar de nuevo la modificación.
&lt;/div&gt;

&lt;p&gt;Este artículo es uno de otros que he publicado, en otros artículos he escrito sobre otras cosas relacionadas con docker.&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/</id>
        <title>Usar docker con Docker Machine en Linux, Windows o Mac</title>        
        <updated>2015-07-18T21:00:00+02:00</updated>
        <published>2015-07-18T12:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/07/usar-docker-con-docker-machine-en-linux-windows-o-mac/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Aunque no usemos Linux podemos hacer uso de docker a través de una máquina virtual de VirtualBox y con Docker Machine. Docker Machine permite crear un sistema con la misión de albergar contenedores de docker, puede ser en VirtualBox pero también en Amazon EC2 o Digital Ocean además de otras muchas opciones.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/docker.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Docker&#34; title=&#34;Docker&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; ha dejado de ser únicamente una tecnología de contenedores formando un ecosistema alrededor de docker más completo, &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker Compose&lt;/a&gt; que permite &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/&#34;&gt;definir un grupo de contenedores en un archivo&lt;/a&gt;, por supuesto parte importante de este ecosistema es &lt;a href=&#34;https://registry.hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt; para &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/&#34;&gt;compartir imágenes de contenedores&lt;/a&gt; y &lt;a href=&#34;https://docs.docker.com/swarm/&#34;&gt;Docker Swarm&lt;/a&gt; que permite formar un &lt;em&gt;cluster&lt;/em&gt; de máquinas. En este artículo comentaré cómo usar &lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker Machine&lt;/a&gt; y dejaré para un futuro &lt;a href=&#34;https://docs.docker.com/swarm/&#34;&gt;Docker Swarm&lt;/a&gt; (ya que por el momento las pruebas que he hecho no han sido exitosas).&lt;/p&gt;

&lt;p&gt;Antes de nada decir que tanto Docker Machine en el momento de escribir este artículo están en las fases iniciales de desarrollo y pueden cambiar significativamente antes de lanzar una versión 1.0, ahora Docker Machine está en las version 0.3.0. La combinación de Docker Machine y Docker Swarm en algunos puntos son parecidos a los que se ofrecen en &lt;a href=&#34;https://coreos.com/&#34;&gt;CoreOS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Si has usado &lt;a href=&#34;https://www.vagrantup.com/&#34;&gt;Vagrant&lt;/a&gt; te resultará Docker Machine muy similar ya que permite crear máquinas virtuales en diferentes proveedores en una máquina anfitrión con &lt;a href=&#34;http://virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt; hasta &lt;a href=&#34;http://aws.amazon.com/es/ec2/&#34;&gt;Amazon EC2&lt;/a&gt; o &lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;Digital Ocean&lt;/a&gt;, la &lt;a href=&#34;https://docs.docker.com/machine/#drivers&#34;&gt;lista de controladores soportados&lt;/a&gt; es bastante amplia. Estas máquinas que creamos con Docker Machine están destinadas como único objetivo a albergar contenedores docker usando el sistema operativo &lt;a href=&#34;http://boot2docker.io/&#34;&gt;boot2docker&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Para usar Docker Machine debemos &lt;a href=&#34;https://github.com/docker/machine/releases&#34;&gt;descargar el binario&lt;/a&gt;, darle permisos de ejecución y si queremos añadirlo a la variable &lt;em&gt;PATH&lt;/em&gt; del sistema.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/691729e2d27cade948ea.js?file=docker-machine-version.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con los siguientes comandos podemos crear una máquina virtual para los contenedores docker, listar las máquinas virtuales creadas, hacer SSH a ella, ejecutar un contenedor en ella, parala y eliminar una máquina virtual además de obtener la &lt;em&gt;IP&lt;/em&gt; asignada.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/691729e2d27cade948ea.js?file=docker-machine-create.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Estableciendo las variables de entorno de la máquina virtual podemos usar el comando docker como si de la máquina anfitrión fuera, todos los comandos de docker que lancemos se ejecutarán contra el contenedor docker de la máquina virtual. En el siguiente caso se ejecuta el contenedor de &lt;em&gt;busybox&lt;/em&gt; en la máquina virtual &lt;em&gt;dev&lt;/em&gt;. Con &lt;em&gt;&amp;ndash;unset&lt;/em&gt; podemos reiniciar la configuración a la máquina anfitrión.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/691729e2d27cade948ea.js?file=docker-machine-run.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Podemos detener, volver a iniciar, hacer SSH y eliminar la máquina virtual con:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/691729e2d27cade948ea.js?file=docker-machine-manage.sh&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/23600.js&#34; id=&#34;asciicast-23600&#34; async&gt;&lt;/script&gt;
        &lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/23600&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/23600.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
        
        &lt;figcaption&gt;Comandos y uso de Docker Machine en una máquina virtual&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/div&gt;

El directorio por defecto donde se guardarán los archivos de las máquinas virtuales es _~/.docker/machine_, si queremos cambiarlo podemos utilizar el parámetro _--storage-path_ en cada uno de los comandos anteriores de la siguiente forma, el orden de los parámetros es importante:

&lt;script src=&#34;//gist.github.com/picodotdev/691729e2d27cade948ea.js?file=docker-machine-storage-path.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;En el administrador de VirtualBox veremos que se ha creado la máquina virtual &lt;em&gt;dev&lt;/em&gt; además de poder cambiar la configuración de memoria y otros parámetros de la máquina virtual.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/89/virtualbox.png&#34; title=&#34;Máquina de Docker Machine ne VirtualBox&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/89/virtualbox-thumb.png&#34;&gt;&lt;/a&gt;
        &lt;figcaption&gt;Máquina de Docker Machine en VirtualBox&lt;/figcaption&gt;
    &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Dado que los contenedores se ejecutan en una máquina virtual de VirtualBox y VirtualBox está disponible en Windows y Mac OS además del binario de Docker Machine para estas plataformas podemos usar docker en cualquiera de estos. Aunque no sea de forma nativa como en Linux para un entorno de desarrollo donde las personas trabajan con cualquiera de estos sistemas operativos puede sernos de utilidad.&lt;/p&gt;

&lt;p&gt;Como nota final diré que después de crear una máquina virtual las siguientes veces al crear una nueva Docker Machine se me quedaba indefinidamente en el mensaje &lt;em&gt;Starting VM&amp;hellip;&lt;/em&gt;, algún problema con Docker Machine o VirtualBox que en una futura versión podría solucionarse, la única forma de resolverlo que se es reiniciando el ordenador pero seguro que hay alguna mejor.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker Machine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/</id>
        <title>Crear y usar un repositorio en Docker Hub</title>        
        <updated>2015-07-11T01:00:00+02:00</updated>
        <published>2015-07-10T20:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/07/crear-y-usar-un-repositorio-en-docker-hub/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;¿Por qué se habla tanto de Docker y despierta tanto interes si la tecnología ya existía desde hace tiempo tanto en otros sistemas operativos como en Linux? Uno de los éxitos que ha contribuido a ellos es Docker Hub, un repositorio de imágenes en el que cualquiera puede contribuir con las suyas. Esto hace que pueda encontrarse cualquier herramienta de las populares y empezar a usarlas en muy pocos minutos.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/docker.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Docker&#34; title=&#34;Docker&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Probablemente uno de los éxitos de Docker más que la propia tecnología de contenedores sea &lt;a href=&#34;https://registry.hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt; que permite a los usuarios compartir las imágenes construidas, se podría decir que es el &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; de los contenedores docker y quizá por ello el paralelismo en el nombre entre ambos. Docker Hub permite subir imágenes o usar las imágenes oficiales de &lt;a href=&#34;http://www.postgresql.org/&#34;&gt;postgresql&lt;/a&gt;, &lt;a href=&#34;http://redis.io/&#34;&gt;redis&lt;/a&gt;, &lt;a href=&#34;http://www.mysql.com/&#34;&gt;mysql&lt;/a&gt;, &lt;a href=&#34;http://www.ubuntu.com/&#34;&gt;ubuntu&lt;/a&gt;, &lt;a href=&#34;https://www.rabbitmq.com/&#34;&gt;rabbitmq&lt;/a&gt;, &amp;hellip; y otra &lt;a href=&#34;https://registry.hub.docker.com/&#34;&gt;multitud de proyectos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;El &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/&#34;&gt;archivo Dockerfile con el que construimos una imagen&lt;/a&gt; podemos hospedarlo en un repositorio de GitHub y que Docker Hub lo obtenga para construir la imagen. Docker Hub ofrece repositorios públicos en los que colocar las imágenes que cualquier otro usuario puede acceder y usar o repositorios privados con cierto coste según el número de repositorios privados, el primer repositorio privado es gratuito.&lt;/p&gt;

&lt;h3 id=&#34;otros-artículos-sobre-docker&#34;&gt;Otros artículos sobre Docker&lt;/h3&gt;

&lt;p&gt;Este artículo forma parte de otros artículos sobre Docker que ya he escrito si quieres empezar por el principio puedes leer primero la &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/&#34;&gt;Introducción y características sobre Docker&lt;/a&gt;, el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/&#34;&gt;Inicio básico de Docker&lt;/a&gt;, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/&#34;&gt;Como crear una imagen con un Dockerfile&lt;/a&gt; o &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/&#34;&gt;Como usar docker con Docker Compose&lt;/a&gt;. En siguientes artículos hablaré de otras herramientas como Docker Machine y Docker Swarm.&lt;/p&gt;

&lt;p&gt;A continuación explicaré como crear un repositorio en Docker Hub que obtenga los Dockerfile de un repositorio de GitHub y construya las imágenes de los Dockerfile de forma automática cuando haya cambios en los archivos dockerfile de GitHub.&lt;/p&gt;

&lt;h3 id=&#34;crear-una-cuenta-en-docker-hub&#34;&gt;Crear una cuenta en Docker Hub&lt;/h3&gt;

&lt;p&gt;Primero necesitaremos crear una cuenta en Docker Hub. El nombre de usuario determinará el nombre de las imágenes, siendo mi nombre de usuario &lt;em&gt;picodotdev&lt;/em&gt; al usar las imágenes debería usar:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/b8ce1632e34bf0a20f59.js?file=docker-run.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/88/dockerhub.png&#34; title=&#34;Docker Hub&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/88/dockerhub-thumb.png&#34;&gt;&lt;/a&gt;
        &lt;figcaption&gt;Docker Hub&lt;/figcaption&gt;
    &lt;/figure&gt;
&lt;/div&gt;

&lt;h3 id=&#34;subir-el-archivo-dockerfile-a-un-repositorio-de-github&#34;&gt;Subir el archivo Dockerfile a un repositorio de GitHub&lt;/h3&gt;

&lt;p&gt;Posteriormente deberemos crear un repositorio en GitHub para alojar los archivos Dockerfile que usará Docker Hub para construir las imágenes de Docker. En el ejemplo usaré el &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/DockerHub&#34;&gt;repositorio blog-ejemplos&lt;/a&gt; y dentro de este los dockerfiles los he &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/DockerHub/postgres/9.4&#34;&gt;ubicado dentro de una carpeta&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Una vez que tenemos el repositorio de GitHub subimos un &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/blob/master/DockerHub/postgres/9.4/Dockerfile&#34;&gt;Dockerfile para el ejemplo&lt;/a&gt;, usaré el proporcionado de forma &lt;a href=&#34;https://registry.hub.docker.com/_/postgres/&#34;&gt;oficial de posgresql&lt;/a&gt;, y creamos en Docker Hub una &lt;em&gt;build&lt;/em&gt; automatizada, se nos solicitará permisos en la cuenta de GitHub para que Docker Hub pueda acceder a nuestros repositorios.&lt;/p&gt;

&lt;h3 id=&#34;crear-el-repositorio-en-dockerhub-y-la-build-automática&#34;&gt;Crear el repositorio en DockerHub y la &lt;em&gt;build&lt;/em&gt; automática&lt;/h3&gt;

&lt;p&gt;En la creación del repositorio en Docker Hub con &lt;em&gt;build&lt;/em&gt; automatizada seleccionamos el repositorio de GitHub que contiene los repositorios y el archivo DockerFile para el que queremos hacer la build automatizada. Le asignamos un nombre al repositorio y un &lt;em&gt;tag&lt;/em&gt; a la &lt;em&gt;build&lt;/em&gt; que podremos usar al hacer el &lt;em&gt;pull&lt;/em&gt; de la imagen.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/88/dockerhub-automated-build.png&#34; title=&#34;Docker Hub&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/88/dockerhub-automated-build-thumb.png&#34;&gt;&lt;/a&gt;
        &lt;figcaption&gt;Build automatizada de Docker Hub&lt;/figcaption&gt;
    &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Docker Hub se encargará de obtener el archivo Dockerfile y construir la imagen, en el proceso podremos ver las trazas generadas.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/userguide/dockerrepos/&#34;&gt;Get started with Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.docker.com/docker-hub/builds/#the-dockerfile-and-automated-builds&#34;&gt;The Dockerfile and Automated Builds&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/</id>
        <title>Aplicaciones multicontenedor con Docker Compose</title>        
        <updated>2015-07-18T21:00:00+02:00</updated>
        <published>2015-07-03T16:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/07/aplicaciones-multicontenedor-con-docker-compose/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Continuando la serie de artículos sobre Docker, otra de las herramientas disponibles en el ecosistema y que nos facilitará enormemente el administrar aplicaciones compuestas por varios contenedores relacionados entre sí es Docker Compose. Definiendo en un archivo los contenedores que forman parte de una aplicación podemos iniciarlos, pararlos, eliminarlos o ver su estado como si de una unidad se tratara.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/docker.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Docker&#34; title=&#34;Docker&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Una vez que ya sabemos que nos puede proporcionar una de las herramientas de la que más se está hablando con la &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/&#34;&gt;introducción a docker&lt;/a&gt;, conocemos &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/&#34;&gt;como empezar a usar docker&lt;/a&gt; y sabemos &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/&#34;&gt;cómo crear nuestras propias imágenes de docker&lt;/a&gt; para los propósitos específicos que necesitemos nos resultará interesante algunas de las nuevas herramientas que proporciona docker. El ecosistema de docker ya no solo se compone del entorno de ejecución de los contenedores, explicadas de forma básica son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt;: el sistema de contenedores (&lt;em&gt;runtime&lt;/em&gt;, imágenes, &amp;hellip;).&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;: el repositorio de imágenes que las diferentes herramientas de forma oficial o a través de usuarios construyen y comparten imágenes que cualquiera puede usar.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker Compose&lt;/a&gt;: permite describir un conjunto de contenedores que se relacionan entre ellos.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker Machine&lt;/a&gt;: permite construir máquinas virtuales para alojar contenedores. Similar a lo que hace &lt;a href=&#34;https://www.vagrantup.com/&#34;&gt;Vagrant&lt;/a&gt;, al igual que el anterior también permite construir máquinas que ejecuten contenedores con &lt;a href=&#34;http://virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt; o diferentes sistemas de computación en en la nube como &lt;a href=&#34;http://aws.amazon.com/es/ec2/&#34;&gt;Amazon EC2&lt;/a&gt;, &lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;Digital Ocean&lt;/a&gt; u otros. Docker Machine puede ser la forma de usar docker en Windows o Mac OS hasta que funcione de forma nativa como en GNU/Linux.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/swarm/&#34;&gt;Docker Swarm&lt;/a&gt;: permite construir un &lt;em&gt;cluster&lt;/em&gt; de máquinas al que se puede enviar contenedores docker para su ejecución.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Continuando la &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/docker/&#34;&gt;serie de artículos sobre docker&lt;/a&gt; que escribí hace unos meses escribiré sobre cada una de estas nuevas herramientas, empezando en este artículo con Docker Compose en el que explicaré de qué forma nos puede servir, como instalarlo y el descriptor de contenedores con un ejemplo.&lt;/p&gt;

&lt;h3 id=&#34;introducción-a-docker-compose&#34;&gt;Introducción a Docker Compose&lt;/h3&gt;

&lt;p&gt;Las aplicaciones basadas en microservicios se prestan a usar múltiples contenedores cada uno con un servicio, uno puede contener la base de datos &lt;a href=&#34;http://www.postgresql.org/&#34;&gt;postgresql&lt;/a&gt;, otro una base de datos clave/valor &lt;a href=&#34;http://redis.io/&#34;&gt;redis&lt;/a&gt; o de documentos como &lt;a href=&#34;https://www.elastic.co/products/elasticsearch/&#34;&gt;elasticsearch&lt;/a&gt; para hacer búsquedas, otro un sistema de mensajería como &lt;a href=&#34;https://www.rabbitmq.com/&#34;&gt;rabbitmq&lt;/a&gt;, otro &lt;a href=&#34;http://tomcat.apache.org/&#34;&gt;tomcat&lt;/a&gt; o &lt;a href=&#34;http://wildfly.org/&#34;&gt;wildfly&lt;/a&gt; que use los anteriores y un servidor web como &lt;a href=&#34;http://nginx.org/&#34;&gt;Nginx&lt;/a&gt;. Teniendo múltiples contenedores usar el comando &lt;em&gt;docker run&lt;/em&gt; para cada uno de ellos nos resultará incómodo. En este punto entra Docker Compose permitiéndonos definir nuestra aplicación multicontenedor en un archivo con las mismas propiedades que indicaríamos con el comando &lt;em&gt;docker run&lt;/em&gt; individualmente. Con un único comando podremos iniciar todos los contenedores y en el orden que los especifiquemos.&lt;/p&gt;

&lt;p&gt;El archivo descriptor nos puede servir no solo como forma de iniciar los contenedores en un entorno de desarrollo sino como de documentación de la aplicación en la que veremos qué contenedores, imágenes, volúmenes, enlaces y demás propiedades tienen.&lt;/p&gt;

&lt;h3 id=&#34;instalar-docker-compose&#34;&gt;Instalar Docker Compose&lt;/h3&gt;

&lt;p&gt;Tenemos varias formas de instalar Docker Compose. La que más me gusta y la que recomiendo por ser sencilla es &lt;a href=&#34;https://github.com/docker/compose/releases&#34;&gt;descargar el binario de docker compose&lt;/a&gt; según nuestra plataforma GNU/Linux o Mac.  Descargando el binario de Docker Compose deberemos darle permisos de ejecución y si nos interesa colocarlo en la variable de entorno &lt;em&gt;PATH&lt;/em&gt; del sistema:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1c2c875cc730b825647f.js?file=permisos.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/1c2c875cc730b825647f.js?file=.bashrc&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con el siguiente comando veremos que Docker Compose funciona correctamente y la versión del mismo.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1c2c875cc730b825647f.js?file=docker-compose-version.sh&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;el-descriptor-de-contenedores&#34;&gt;El descriptor de contenedores&lt;/h3&gt;

&lt;p&gt;El descriptor de los contenedores a usar con Docker Compose es un archivo de texto con &lt;a href=&#34;http://www.yaml.org/&#34;&gt;formato yaml&lt;/a&gt; en la que especificamos los diferentes contenedores y sus propiedades, básicamente podemos indicar las mismas propiedades que indicamos arrancando los contenedores individualmente con el comando &lt;em&gt;docker run&lt;/em&gt;. En el siguiente ejemplo vemos varios contenedores, dos contenedores de datos para redis y postgresql, los contenedores de redis y postgresql y un contenedor para la aplicación usando tomcat enlazado con los contenedores de redis y postgresql definidos previamente.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1c2c875cc730b825647f.js?file=docker-compose.yml&#34;&gt;&lt;/script&gt;

&lt;p&gt;La imagen de los contenedores se indica con la propiedad &lt;em&gt;image&lt;/em&gt;, los contenedores de datos, &lt;em&gt;redisdb&lt;/em&gt; y &lt;em&gt;posgresqldb&lt;/em&gt;, usan la propiedad &lt;em&gt;volumes&lt;/em&gt; con los datos que guardarán y la imagen de &lt;em&gt;busybox&lt;/em&gt; (se suele usar esta para los contenedores de datos porque es muy pequeña), con la propiedad &lt;em&gt;hostname&lt;/em&gt; podemos indicar el nombre de la máquina que al usar la propiedad &lt;em&gt;link&lt;/em&gt; docker hará visible al contenedor que los usen, con &lt;em&gt;volumes_from&lt;/em&gt; podemos usar volúmenes, con &lt;em&gt;links&lt;/em&gt; enlazar contenedores y con &lt;em&gt;ports&lt;/em&gt; asociar puertos entre los contenedores y la propia máquina anfitrión, en el ejemplo he usado los puertos por defecto de cada uno de los servicios.&lt;/p&gt;

&lt;p&gt;La &lt;a href=&#34;https://docs.docker.com/compose/yml/&#34;&gt;descripción completa del formato del archivo de Docker Compose&lt;/a&gt; nos da una idea de las opciones que podemos usar, está bastante bien explicado y con ejemplos que nos resultará sencillo entender conociendo los parámetros que usamos con &lt;em&gt;docker run&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;iniciar-los-contenedores-con-docker-compose&#34;&gt;Iniciar los contenedores con Docker Compose&lt;/h3&gt;

&lt;p&gt;Escrito el archivo de los contenedores y llamándolo &lt;em&gt;docker-compose.yml&lt;/em&gt; podemos iniciar los contenedores con el comando &lt;em&gt;docker-compose up&lt;/em&gt; estando en el mismo directorio de trabajo donde esté ubicado del archivo yml (y previamente habiendo iniciado el servicio de docker). Con &lt;em&gt;docker-compose ps&lt;/em&gt; podremos ver el estado de los contenedores y de cuales está compuesta la aplicación. Con la opción &lt;em&gt;&amp;ndash;help&lt;/em&gt; podemos ver la lista completa de comandos que podemos usar.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1c2c875cc730b825647f.js?file=docker-compose-up.yml&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/87/docker-compose.png&#34; title=&#34;Docker Compose&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/87/docker-compose-thumb.png&#34;&gt;&lt;/a&gt;
        &lt;figcaption&gt;Docker Compose&lt;/figcaption&gt;
    &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;docker-compose inicia los contenedores en el orden que hemos indicado en el archivo de definición, las trazas emitidas de los servicios de los contenedores aparecerán en la terminal si iniciamos los contenedores en primer plano y con &lt;em&gt;Ctrl+C&lt;/em&gt; se pararán los contenedores. Indicando la opción &lt;em&gt;-d&lt;/em&gt; los contenedores se iniciarán en segundo plano, con &lt;em&gt;docker-compose stop&lt;/em&gt; podremos pararlos, con &lt;em&gt;docker-compose restart&lt;/em&gt; reiniciarlos, &lt;em&gt;docker-compose rm&lt;/em&gt; para eliminar completamente los contenedores y con &lt;em&gt;docker-compose logs&lt;/em&gt; veremos las trazas emitidas por los servicios que nos serán de utilizar si iniciamos los contenedores en segundo plano.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/23602.js&#34; id=&#34;asciicast-23602&#34; async&gt;&lt;/script&gt;
        &lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/23602&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/23602.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
        
        &lt;figcaption&gt;Comandos básicos de Docker Compose&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/div&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=9d344246cd59cd65a952305379c2556a&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;En las siguientes semanas publicaré más artículos sobre esta serie de Docker comentando &lt;a href=&#34;https://registry.hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;, &lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker Machine&lt;/a&gt; y explicaré de qué forma nos pueden ser útiles estas otras herramientas.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/04/introduccion-a-elasticsearch/&#34;&gt;Introducción a elasticsearch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2014/11/integracion-entre-ansible-y-docker/</id>
        <title>Integración entre Ansible y Docker</title>        
        <updated>2014-12-29T19:00:00+01:00</updated>
        <published>2014-11-22T10:28:52+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/11/integracion-entre-ansible-y-docker/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/ansible.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Ansible&#34; title=&#34;Ansible&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/docker.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Docker&#34; title=&#34;Docker&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En la &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/&#34;&gt;introducción de Docker&lt;/a&gt; y &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/&#34;&gt;inicio básico de docker&lt;/a&gt; explicaba como usar Docker y en la &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-ansible/&#34;&gt;introducción a Ansible&lt;/a&gt; explicaba las características de Ansible y como usarlo. Podemos usar &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; y &lt;a href=&#34;http://www.ansible.com&#34;&gt;Ansible&lt;/a&gt; de forma separada pero también podemos combinarlas para beneficiarnos de las propiedades de cada una. En Ansible disponemos de dos módulos que nos permite manejar las imágenes y los contenedores de Docker, estos son &lt;a href=&#34;http://docs.ansible.com/docker_module.html&#34;&gt;docker&lt;/a&gt; y &lt;a href=&#34;http://docs.ansible.com/docker_image_module.html&#34;&gt;docker_image&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Usando tareas de ansible podemos automatizar el arranque del servicio de docker, la construcción de las imágenes con los Dokerfile y el inicio o parada de los contenedores de docker. En el ejemplo se construye una imagen base en la que se basarán el resto de imágenes, se crea una imagen con mysql, otra de redis y finalmente la imagen apps donde se ejecutarán las aplicaciones que usarán los servicios de mysql y redis.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/835ff0192d48b613714a.js?file=install.yml&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una vez que disponemos de las imágenes de docker podemos arrancar contenedores con ellas automatizándolo con ansible. En este caso se inicia el servicio de docker, se inicializan los contenedores con los volúmenes donde se guardan los datos de forma persistente de mysql y redis, se inician los contenedores de mysql y redis usando los volúmenes anteriores y finalmente el contenedor de las aplicaciones. Al final, se muestra cierta información de las imágenes como sus direcciones IP.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/835ff0192d48b613714a.js?file=start.yml&#34;&gt;&lt;/script&gt;

&lt;p&gt;Ansible &lt;a href=&#34;http://docs.ansible.com/list_of_all_modules.html&#34;&gt;dispone muchos módulos&lt;/a&gt; que nos permiten automatizar las tareas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.ansible.com/list_of_cloud_modules.html&#34;&gt;Módulos para manejo de entornos cloud&lt;/a&gt; (&lt;a href=&#34;http://aws.amazon.com/es/ec2/&#34;&gt;Amazon EC2&lt;/a&gt;, &lt;a href=&#34;http://azure.microsoft.com/es-es/&#34;&gt;Azure&lt;/a&gt;, &lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;Digital Ocean&lt;/a&gt;, &lt;a href=&#34;http://www.openstack.org/&#34;&gt;OpenStack&lt;/a&gt;, &lt;a href=&#34;http://www.rackspace.com/es/&#34;&gt;Rackspace&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.ansible.com/list_of_commands_modules.html&#34;&gt;Módulos para ejecutar comandos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.ansible.com/list_of_database_modules.html&#34;&gt;Módulos para administración de bases de datos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.ansible.com/modules_by_category.html&#34;&gt;Módulos para manejo de archivos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.ansible.com/list_of_packaging_modules.html&#34;&gt;Módulos para manejo de paquetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.ansible.com/list_of_source_control_modules.html&#34;&gt;Módulos para manejo de sistemas de control de versiones&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Y algunos más&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/&#34;&gt;Introducción a Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/&#34;&gt;Guía de inicio básico de Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/&#34;&gt;Cómo crear una imagen para Docker usando un Dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-ansible/&#34;&gt;Introducción a Ansible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-bitnami/&#34;&gt;Introducción a Bitnami&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.ansible.com/docker_module.html&#34;&gt;http://docs.ansible.com/docker_module.html&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.ansible.com/docker_image_module.html&#34;&gt;http://docs.ansible.com/docker_image_module.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="gnu-linux"/>
            
                <category term="planeta-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="blog-stack"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/</id>
        <title>Cómo crear una imagen para Docker usando un Dockerfile</title>        
        <updated>2015-05-26T20:00:00+01:00</updated>
        <published>2014-11-07T19:50:17+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Podemos usar los contenedores disponibles en Docker Hub, donde están disponibles las aplicaciones de bases de datos, servidores de aplicaciones de mútiples lenguages, servidores web más populares y entre otras muchas. Pero también podemos definir nuestras propias imágenes personalizadas con las necesidades que tengamos. Lo que necesitamos es escribir un archivo que contenga la receta para construir la imagen del contenedor, este archivo es el Dockerfile.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/docker.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Docker&#34; title=&#34;Docker&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Las imágenes de &lt;a href=&#34;https://www.docker.com/&#34;&gt;docker&lt;/a&gt; son el sistema de archivos que usa el proceso o procesos que se arrancan en los contenedores. Si nos convencen las &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/&#34;&gt;características de docker&lt;/a&gt; y estamos decididos a usarlo y ya sabemos &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/&#34;&gt;como administrar de forma básica los contendores&lt;/a&gt; si queremos disponer de una imagen adaptada a los servicios que necesitamos para iniciar contenedores tendremos que crearla, en este artículo explicaré cómo crear una imagen para docker personalizada.&lt;/p&gt;

&lt;p&gt;Antes de crear una imagen para docker podemos buscar en el &lt;a href=&#34;https://registry.hub.docker.com/&#34;&gt;registro de imágenes de docker&lt;/a&gt; que han creado otros usuarios y los han compartido por si hay alguna que ya se adapte a nuestras necesidades, si nos sirve alguna y es algo popular nos evitaremos tener que modificarla nosotros mismos según salgan nuevas versiones de los servicios que use. El registro de imágenes de docker es un servicio en el que los usuarios comparten y colaboran en la creación de las imágenes. Para los servicios más conocidos dispondremos ya de las imágenes como podrían ser: &lt;a href=&#34;https://registry.hub.docker.com/_/mysql/&#34;&gt;mysql&lt;/a&gt;, &lt;a href=&#34;https://registry.hub.docker.com/_/redis/&#34;&gt;redis&lt;/a&gt;, &lt;a href=&#34;https://registry.hub.docker.com/_/postgres/&#34;&gt;postgresql&lt;/a&gt;, &lt;a href=&#34;https://registry.hub.docker.com/_/ubuntu/&#34;&gt;ubuntu&lt;/a&gt;, &lt;a href=&#34;https://registry.hub.docker.com/_/wordpress/&#34;&gt;wordpress&lt;/a&gt;, &lt;a href=&#34;https://registry.hub.docker.com/_/nginx/&#34;&gt;nginx&lt;/a&gt;, &lt;a href=&#34;https://registry.hub.docker.com/_/mongo/&#34;&gt;mongodb&lt;/a&gt;, &amp;hellip;&lt;/p&gt;

&lt;p&gt;Si no hay ninguna que se adapte totalmente a nuestras necesidades, no nos gusta como están construidas las existes o no confiamos en el mantenimiento que puedan tener esas imágenes podemos crear las nuestras propias. Para crear una imagen de docker se necesita una receta en forma de &lt;a href=&#34;http://docs.docker.com/reference/builder/&#34;&gt;archivo Dockerfile&lt;/a&gt; que contiene la descripción e instrucciones para construir la imagen. Para crear un dockerfile podemos basarnos en los de las imágenes del registro de docker.&lt;/p&gt;

&lt;p&gt;Este podría ser el contenido y la receta de un dockerfile si quisiésemos crear una imagen de docker para mysql, lo paso a explicar después.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/6dc90582ce925f19ffcb.js?file=Dockerfile-base&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/6dc90582ce925f19ffcb.js?file=Dockerfile-mysql&#34;&gt;&lt;/script&gt;

&lt;p&gt;Los Dockerfile tienen algunas instrucciones:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FROM: indica la imagen base a partir de la cual crearemos la imagen que construirá el Dockerfile.&lt;/li&gt;
&lt;li&gt;MAINTAINER: documenta el creador de la imagen.&lt;/li&gt;
&lt;li&gt;ENV HOME: establece el directorio HOME que usarán los comandos RUN.&lt;/li&gt;
&lt;li&gt;RUN: permite ejecutar una instrucción en el contenedor, por ejemplo, para instalar algún paquete mediante el gestor de paquetes (apt-get, yum, rpm, &amp;hellip;).&lt;/li&gt;
&lt;li&gt;ADD: permite añadir un archivo al contenedor, en muchas ocasiones se utiliza para proporcionar la configuración de los servicios (ssh, mysql, &amp;hellip;).&lt;/li&gt;
&lt;li&gt;VOLUME: establece puntos de montaje que al usar el contenedor se pueden proporcionar, los volúmenes son al forma de externalizar un determinado directorio y proporcionar persistencia (las imágenes de docker son de solo lectura y no almacenan datos entre diferentes ejecuciones).&lt;/li&gt;
&lt;li&gt;EXPOSE: indica los puertos TCP/IP por los que se pueden acceder a los servicios del contenedor, los típicos son 22 (SSH), 80 (HTTP) y en este caso el puerto por defecto de mysql 3306.&lt;/li&gt;
&lt;li&gt;CDM: establece el comando del proceso de inicio que se usará si no se indica uno al iniciar un contenedor con la imagen.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El Dockerfile-base crea una imagen base que usaremos posteriormente en la imagen de mysql, configura el color del prompt, la contraseña de root y expone el puerto 22 para poder hacer ssh.&lt;/p&gt;

&lt;p&gt;En este ejemplo en vez de usar una imagen propia de Ubuntu en la directiva FROM he usado una imagen especial, &lt;a href=&#34;https://registry.hub.docker.com/u/phusion/baseimage/&#34;&gt;phusion/baseimage&lt;/a&gt;:0.9.15. La imagen phusion/baseimage proporciona un sistema init adaptado al funcionamiento de los contenedores de docker al contrario de las imágenes de ubuntu que emplean upstart. Si usásemos alguna imagen de ubuntu y quisiésemos iniciar varios procesos en el contenedor deberíamos usar un servicio como punto de entrada como &lt;a href=&#34;http://supervisord.org/&#34;&gt;supervisord&lt;/a&gt;, con la imagen phusion/baseimage no sería necesario ya que ya ofrece esta funcionalidad de forma más sencilla.&lt;/p&gt;

&lt;p&gt;Con las instrucciones RUN y ADD instalamos el paquete de mysql y el cliente de mysql y añadimos la configuración de mysql en el archivo my.cnf. En /etc/service/mysql/run dejamos el comando del servicio que iniciará el proceso de mysql como espera el sistema init de la imagen phusion. Con VOLUME [&amp;ldquo;/var/lib/mysql&amp;rdquo;] establecemos un punto de montaje para poder externalizar y persistir los datos de las bases de datos de mysql.&lt;/p&gt;

&lt;p&gt;Una vez tenemos el Dockerfile y los archivos de configuración a incluir con los comandos ADD contruimos la imagen con:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/6dc90582ce925f19ffcb.js?file=docker-build.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/51/docker-mysql.png&#34; title=&#34;docker-mysql&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/51/docker-mysql-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Para proporcionar la persistencia a la imagen de mysql podemos crear un contenedor específico que contenga los datos. Con el siguiente comando creamos un contenedor de datos, uso la imagen busybox ya que es una de las más pequeñas:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/6dc90582ce925f19ffcb.js?file=docker-run-1.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Posteriormente podemos iniciar y parar el contenedor de msql con:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/6dc90582ce925f19ffcb.js?file=docker-run-2.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;En los siguientes artículos comentaré la herramienta de automatización &lt;a href=&#34;http://www.ansible.com&#34;&gt;ansible&lt;/a&gt; y como sacarle provecho para iniciar los contenedores en una máquina de desarrollo (devbox). También en algún otro artículo comentaré la opción de &lt;a href=&#34;https://bitnami.com/&#34;&gt;bitnami&lt;/a&gt; que dentro de poco ofrecerá soporte para docker y como con esta opción podemos usar un servicio «out-of-the-box» si tener que crear ni siquiera un Dockerfile o tener que documentarnos para instalar un servicio (que en algunos casos pueden tener cierta complejidad) aunque sea usando virtualización con &lt;a href=&#34;http://virtualbox.org/&#34;&gt;virtualbox&lt;/a&gt; o computación en la nube.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=9d344246cd59cd65a952305379c2556a&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/&#34;&gt;Introducción a Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/&#34;&gt;Guía de inicio básico de Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.nkode.io/2014/08/24/valuable-docker-links.html&#34;&gt;Lista de enlaces sobre Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-ansible/&#34;&gt;Introducción a Ansible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/integracion-entre-ansible-y-docker/&#34;&gt;Integración entre Ansible y Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-bitnami/&#34;&gt;Introducción a Bitnami&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="gnu-linux"/>
            
                <category term="planeta-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="blog-stack"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/</id>
        <title>Inicio básico de Docker</title>        
        <updated>2015-05-26T20:00:00+01:00</updated>
        <published>2014-11-01T09:47:51+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;La tecnología de contenedores nos ofrece múltiples ventajas para nuestras aplicaciones. Docker es una de las más nombradas y que está creciendo muy rápidamente. Es muy sencillo empezarla a usar como mostraré en unos pocos comandos a continuación.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/docker.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Docker&#34; title=&#34;Docker&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/&#34;&gt;artículo anterior introductorio sobre Docker&lt;/a&gt; comentaba cuales son sus principales características, que diferencias tiene con la virtualización y algunos casos y motivos por los que nos puede interesar usarlo. El objetivo de este artículo será a modo de guía rápida como empezar a usar &lt;a href=&#34;https://www.docker.com/&#34;&gt;docker&lt;/a&gt;. Comentaré cuales son los comandos básicos para manejar docker, las imágenes y los contenedores.&lt;/p&gt;

&lt;p&gt;Antes de empezar con la guía propiamente hay que tener en cuenta que otra de las características de docker es que únicamente se inicia un solo proceso, cuando este finaliza finaliza la instancia del contenedor. Aunque en principio un contenedor solo tiene un proceso, podemos usar como proceso inicial uno que arranque otros, la &lt;a href=&#34;https://registry.hub.docker.com/u/phusion/baseimage/&#34;&gt;imagen pushion&lt;/a&gt; tiene un sistema de inicio adaptado al funcionamiento de docker (no siendo así upstart de las imágenes de ubuntu o systemd usado por otras distribuciones) con el que podemos iniciar otros procesos, en cualquier caso es recomendable que un contenedor sino tiene un solo proceso tenga unos pocos procesos relacionados con el servicio que proporciona la imagen, la recomendación es no proporcionar una imagen con un montón de servicios/procesos sino varias pequeñas cuyos servicios colaboren. Una imagen de un contenedor es básicamente el sistema de archivos que usará el proceso que iniciamos en el contenedor, necesitamos obtener o construir una imagen para iniciar los contenedores y trabajar con docker.&lt;/p&gt;

&lt;p&gt;Primeramente deberemos instalar el paquete de docker, en el caso de &lt;a href=&#34;https://www.archlinux.org/&#34;&gt;Arch Linux&lt;/a&gt; con el siguiente comando:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/85b091f62b462deee318.js?file=docker-1.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para poder usar docker sin emplear el comando sudo deberemos crear y añadir nuestro usuario al grupo docker:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/85b091f62b462deee318.js?file=docker-2.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una vez instalado el paquete y añadido nuestro usuario al grupo docker podemos iniciar el servicio de docker, en Arch Linux con systemd:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/85b091f62b462deee318.js?file=docker-3.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con el comando «docker images», «docker ps», «docker ps -a» podemos respectivamente ver las imágenes de docker disponibles en nuestro sistema, las instancias de los contenedores iniciadas y las instancias de los contenedores incluyendo las no iniciadas.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/85b091f62b462deee318.js?file=docker-4.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/50/docker-images.png&#34; title=&#34;docker-images&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/50/docker-images-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Con los comandos &lt;em&gt;docker rm [contenedor]&lt;/em&gt; y &lt;em&gt;docker rmi [imagen]&lt;/em&gt; podemos eliminar las instancias de contenedores y las imágenes que no estén siendo usadas por ningún contenedor, si están siendo usadas deberemos eliminar primero el contenedor.&lt;/p&gt;

&lt;p&gt;Una vez conocemos los comandos básicos para gestionar las imágenes y contenedores aún nos quedan conocer los comandos para obtener las imágenes y como iniciarlas. No hace falta que las imágenes las construyamos nosotros desde cero sino que podemos utilizar las que otras personas han construido. Docker dispone de un &lt;a href=&#34;https://registry.hub.docker.com/&#34;&gt;registro o repositorio de imágenes&lt;/a&gt; en el que la comunidad (otras personas) publica las que ellos han construido, en este registro podemos encontrar imágenes para cualquier servicio de los más utilizados ya sea &lt;a href=&#34;http://www.mysql.com/&#34;&gt;MySQL&lt;/a&gt;, &lt;a href=&#34;http://nginx.org/&#34;&gt;Nginx&lt;/a&gt;, &lt;a href=&#34;http://redis.io/&#34;&gt;Redis&lt;/a&gt;, &lt;a href=&#34;https://wordpress.org/&#34;&gt;WordPress&lt;/a&gt;, &lt;a href=&#34;http://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt;, &lt;a href=&#34;http://www.ubuntu.com/&#34;&gt;Ubuntu&lt;/a&gt;, &lt;a href=&#34;http://www.centos.org/&#34;&gt;CentOS&lt;/a&gt;, &amp;hellip; Este repositorio de imágenes hace que podamos disponer de estos servicios muy fácilmente, sin embargo, hay que tener en cuenta que algunas imágenes no son construidas por alguien &amp;ldquo;oficial&amp;rdquo; de ese servicio, cualquier persona puede &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/&#34;&gt;construir una imagen de un servicio&lt;/a&gt; y hacerlo disponible en el repositorio esto hace que algunas imágenes puedan no ser de la máxima calidad o que estén apropiadamente mantenidas. Por ello, es recomendable utilizar las imágenes más descargadas y usadas, a pesar de todo con docker si una imagen no nos gusta podemos basarnos en ella para construir una que se adapte totalmente a nuestras necesidades y con la que nos sintamos cómodos.&lt;/p&gt;

&lt;p&gt;Para obtener una imagen usamos el comando «docker pull [imagen]» indicando el usuario que creó la imagen, el nombre de la imagen y el tag. En el siguiente enlace en la pestaña tags podemos ver las &lt;a href=&#34;https://registry.hub.docker.com/_/debian/&#34;&gt;imágenes para docker de Debian y sus tag&lt;/a&gt;:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/85b091f62b462deee318.js?file=docker-5.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/50/docker-pull.png&#34; title=&#34;docker-pull&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/50/docker-pull-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Una vez descargada la imagen podemos iniciar un contenedor de la imagen con:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/85b091f62b462deee318.js?file=docker-6.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;En la terminal que se inicia podemos usar cualquier comando que usaríamos en un sistema &lt;a href=&#34;https://www.debian.org/&#34;&gt;debian&lt;/a&gt; como apt-get.&lt;/p&gt;

&lt;p&gt;Este es el momento para explicar otra de las peculiaridades de los contenedores de docker y es que estos no conservan el estado de una ejecución a otra y cada vez que ejecutemos el comando se creará una nueva instancia del contenedor. Para conseguir la persistencia al crear las imágenes se pueden establecer puntos de montaje, esta persistencia está externalizada en otros contenedores con el solo propósito de servir como volúmenes de datos, también se puede montar un directorio del sistema anfitrión.&lt;/p&gt;

&lt;p&gt;Si usamos el comando «uname -a» puede verse que aunque el contenedor usa el sistema de archivos de una distribución debian el kernel empleado es el del sistema anfitrión, esto es así porque los contenedores docker en esencia no son más que procesos dentro del sistema.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/50/docker-run.png&#34; title=&#34;docker-run&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/50/docker-run-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Continuando esta serie de artículos sobre docker explicaré como construir una imagen mediante los Dockerfiles con la que podamos usar una base de datos mysql y explicaré en más detalle como podemos conseguir la persistencia que necesitaremos para almacenar los datos de la base de datos usando otro contenedor con este propósito.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=9d344246cd59cd65a952305379c2556a&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/&#34;&gt;Introducción y características de Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/&#34;&gt;Cómo crear una imagen para Docker usando un Dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-ansible/&#34;&gt;Introducción a Ansible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/integracion-entre-ansible-y-docker/&#34;&gt;Integración entre Ansible y Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-bitnami/&#34;&gt;Introducción a Bitnami&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.hub.docker.com/&#34;&gt;Docker Hub Registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://phusion.github.io/baseimage-docker/&#34;&gt;http://phusion.github.io/baseimage-docker/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="gnu-linux"/>
            
                <category term="planeta-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="blog-stack"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/</id>
        <title>Introducción y características de Docker</title>        
        <updated>2015-05-27T20:00:00+01:00</updated>
        <published>2014-10-25T10:52:34+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/10/introduccion-y-caracteristicas-de-docker/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Los contenedores no son una tecnología nueva pero Docker ha reunido las características necesarias para hacerla sencilla y popular en Linux. Suponen un cambio en la infraestructura de las aplicaciones con algunas ventajas sobre la virtualización y la instalación de los servicios directamente en el sistema.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/docker.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Docker&#34; title=&#34;Docker&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; es una de las herramientas de la que se está hablando mucho, esto es así ya que tiene varios aspectos interesantes que &lt;a href=&#34;http://www.javaworld.com/article/2685223/java-app-dev/four-ways-docker-fundamentally-changes-application-development.html&#34;&gt;cambian la forma de desarrollar aplicaciones&lt;/a&gt;. Docker es una forma de ejecutar procesos de forma aislada pero también se compone de herramientas para construir imágenes y un repositorio para compartirlas.&lt;/p&gt;

&lt;p&gt;Al contrario de la virtualización Docker no emula o virtualiza una máquina y su sistema operativo con lo que los procesos son mucho más ligeros y hace que el hardware pueda ser aprovechado más al poder aumentar la densidad de los servicios en una misma máquina. Los contenedores y servicios incluidos en ellos inician muy rápidamente, en pocos segundos. Además, no es necesario el sistema de archivos completo del sistema operativo invitado con lo que docker usa una fracción de espacio de almacenamiento necesario en la virtualización.&lt;/p&gt;

&lt;p&gt;La tecnología de contenedores no es nueva y también está disponible en otros sistemas operativos como &lt;a href=&#34;http://openvz.org/&#34;&gt;OpenVZ&lt;/a&gt; también en Linux, &lt;a href=&#34;http://www.freebsd.org/doc/handbook/jails.html&#34;&gt;FreeBSD Jails&lt;/a&gt; o los &lt;a href=&#34;http://www.oracle.com/technetwork/server-storage/solaris/containers-169727.html&#34;&gt;contenedores de Solaris&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/49/virtual-machines.png&#34; title=&#34;Máquinas virtuales&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/49/virtual-machines.png&#34;&gt;&lt;/a&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/49/docker.png&#34; title=&#34;Docker&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/49/docker.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Docker tiene varias características interesantes. Es ligero ya que no hay virtualización aprovechándose mejor el hardware y únicamente necesitando el sistema de archivos mínimo para que funcionen los servicios. Los contenedores son autosuficientes (aunque pueden depender de otros contenedores, por ejemplo, un wordpress que necesita una base de datos mysql) no necesitando nada más que la imagen del contenedor para que funcionen los servicios que ofrece. Las imágenes de docker son portables entre diferentes plataformas el único requisito es que en el sistema huésped esté disponible docker. Es seguro, pudiendo hacer que los contenedores se comuniquen por un túnel solo disponible para ellos, los contenedores están aislados en el sistema mediante namespaces y control groups.&lt;/p&gt;

&lt;p&gt;Para los desarrolladores tiene las siguientes ventajas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Podemos disponer de un entorno de desarrollo (devbox) o servicio en varios minutos/horas en vez de algún día. Esto es así porque la configuración y los servicios necesarios están automatizados en la construcción de las imágenes de los contenedores mediante &lt;a href=&#34;https://docs.docker.com/reference/builder/&#34;&gt;Dockerfiles&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Al estar los servicios en contenedores no hace falta instalarlos en la máquina en la que son alojados, de forma que podemos disponer de los servicios y después eliminarlos de forma sencilla sin &amp;ldquo;ensuciar&amp;rdquo; el sistema huésped.&lt;/li&gt;
&lt;li&gt;Nos permite tener versiones más parecidas o iguales a las usadas en producción. Por ejemplo, en Arch Linux nos permite tener un mysql de la distribución &lt;a href=&#34;http://www.ubuntu.com/&#34;&gt;Ubuntu&lt;/a&gt; usando la misma versión.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El &lt;a href=&#34;https://registry.hub.docker.com/&#34;&gt;registro de contenedores de Docker&lt;/a&gt; es una forma colaborativa de ofrecer imágenes. Hay disponibles multitud de contenedores con los servicios más populares: &lt;a href=&#34;http://www.mysql.com/&#34;&gt;MySql&lt;/a&gt;, &lt;a href=&#34;http://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt;, &lt;a href=&#34;http://redis.io/&#34;&gt;Redis&lt;/a&gt;, &lt;a href=&#34;http://nginx.org/&#34;&gt;Nginx&lt;/a&gt;, &lt;a href=&#34;https://wordpress.org/&#34;&gt;WordPress&lt;/a&gt;, &amp;hellip;&lt;/p&gt;

&lt;p&gt;Para los administradores de sistemas tiene las siguientes ventajas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pueden proporcionar entornos similares o iguales a los entornos de pruebas, QA o producción independientemente de la distribución que se use.&lt;/li&gt;
&lt;li&gt;Es posible desplegar un contenedor en cualquier infraestructura Linux.&lt;/li&gt;
&lt;li&gt;La creación de los contenedores puede ponerse bajo un sistema de control de versiones.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En el siguiente vídeo y presentación muy completa están ampliados muchas de sus posibilidades y funcionalidades.&lt;/p&gt;

&lt;div class=&#34;video-post&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/ZzQfxoMFH0U&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;script async class=&#39;speakerdeck-embed&#39; data-id=&#39;c02e6030ee52013165c72a37516b560d&#39; data-ratio=&#39;1.33333333333333&#39; src=&#39;//speakerdeck.com/assets/embed.js&#39;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;p&gt;Una vez conocidos los aspectos básicos y en que se diferencia docker de la virtualización así como el caso de uso de por ejemplo un devbox o disponer de entornos similares a los de producción de una aplicación, en el siguiente artículo comentaré &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/&#34;&gt;cómo instalar docker, cómo empezar a usarlo, cómo obtener imágenes de servicios y pararlos y administrarlos&lt;/a&gt;. En la siguiente &lt;a href=&#34;http://www.nkode.io/2014/08/24/valuable-docker-links.html&#34;&gt;lista de enlaces sobre Docker&lt;/a&gt; se puede encontrar mucha información reunida dispersa en la red, desde introducciones, opiniones, como usarlo, como empaquetar las aplicaciones, como monitorizar o como usarlo en microservicios.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=9d344246cd59cd65a952305379c2556a&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/inicio-basico-de-docker/&#34;&gt;Inicio básico de Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/como-crear-una-imagen-para-docker-usando-un-dockerfile/&#34;&gt;Cómo crear una imagen para Docker usando un Dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-ansible/&#34;&gt;Introducción a Ansible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/integracion-entre-ansible-y-docker/&#34;&gt;Integración entre Ansible y Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/11/introduccion-a-bitnami/&#34;&gt;Introducción a Bitnami&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/articles/security/&#34;&gt;Seguridad Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javaworld.com/article/2685223/java-app-dev/four-ways-docker-fundamentally-changes-application-development.html&#34;&gt;Four ways Docker fundamentally changes application development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://openwebinars.net/docker-que-es-sus-principales-caracteristicas/&#34;&gt;Docker, qué es y sus principales características&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="gnu-linux"/>
            
                <category term="planeta-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="blog-stack"/>
            
        
    </entry>
    
</feed>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://picodotdev.github.io/blog-bitix/series/graphql/</id>
    <title type="text">Blog Bitix</title>
    <subtitle>Recent content on Blog Bitix</subtitle>
    <updated>2017-12-01T10:00:00+01:00</updated>
    <author><name>pico.dev</name></author>
    <generator>Hugo</generator>
    <icon>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</icon>
    <logo>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</logo>
    <rights>https://creativecommons.org/licenses/by-sa/4.0/</rights>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/12/definir-nuevos-tipos-de-datos-escalares-en-graphql/</id>
        <title>Definir nuevos tipos de datos escalares en GraphQL</title>        
        <updated>2017-12-01T10:00:00+01:00</updated>
        <published>2017-12-01T10:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/12/definir-nuevos-tipos-de-datos-escalares-en-graphql/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/graphql.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;GraphQL&#34; title=&#34;GraphQL&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/11/ejemplo-de-graphql-para-una-interfaz-de-un-servicio-con-spring-boot-y-java/&#34;&gt;GraphQL es una alternativa a una interfaz REST&lt;/a&gt; con las ventajas de permitir al consumidor obtener únicamente los datos que requiere y realizar varias consultas en una misma petición.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt; por defecto soporta un conjunto de tipos escalares en los datos entre los que están varios numéricos, cadenas, booleanos, enumerados además de los tipos o estructuras de datos definidos en la interfaz del servicio. Sin embargo, si es necesario es posible definir nuevos tipos de datos escalares como podría ser el caso de un tipo de dato para representar una fecha fecha y otro de importe monetario.&lt;/p&gt;

&lt;p&gt;El objeto en Java que representa una fecha con Java 8 sería &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/time/LocalDate.html&#34;&gt;LocalDate&lt;/a&gt; y la clase para el importe monetario podría ser un &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/math/BigDecimal.html&#34;&gt;BigDecimal&lt;/a&gt; o alguna de &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/07/como-trabajar-con-importes-ratios-y-divisas-en-java/&#34;&gt;la librería JavaMoney&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Para que GraphQL soporte un nuevo tipo de dato escalar es necesario implementar una clase que realice la conversión. Esta clase se encarga de realizar la conversión entre el escalar añadido a una representación a devolver en las respuestas de las peticiones y la conversión entre la representación en consultas al tipo de dato hay que proporcionar al servicio. La clase debe implementar la interfaz &lt;a href=&#34;https://github.com/graphql-java/graphql-java/blob/master/src/main/java/graphql/schema/Coercing.java&#34;&gt;Coercing&lt;/a&gt; y construyendo un objeto &lt;a href=&#34;https://github.com/graphql-java/graphql-java/blob/master/src/main/java/graphql/schema/GraphQLScalarType.java&#34;&gt;GraphQLScalarType&lt;/a&gt; proporcionárselo a GraphQL en la definición del servicio.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/ae1583aaa3182006533adad61ee73921.js?file=LocalDateCoercing.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Al definir el esquema se proporciona con el método &lt;em&gt;scalars&lt;/em&gt; una lista con los tipos de datos escalares adicionales, en este caso una instancia de &lt;em&gt;GraphQLScalarType&lt;/em&gt; con una instancia de &lt;em&gt;LocalDateCoercing&lt;/em&gt;. Además en el descriptor del esquema hay que declarar el nuevo escalar con la palabra clave &lt;em&gt;scalar&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/ae1583aaa3182006533adad61ee73921.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/ae1583aaa3182006533adad61ee73921.js?file=library.graphqls&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/ae1583aaa3182006533adad61ee73921.js?file=LibraryRepository.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Añadiendo al tipo &lt;em&gt;Book&lt;/em&gt; una fecha de publicación usando este nuevo tipo escalar al realizar una consulta y devolver el dato se realiza la conversión.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/ae1583aaa3182006533adad61ee73921.js?file=curl.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/GraphQL&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/11/paginacion-usando-cursores-en-graphql-y-java/</id>
        <title>Paginación usando cursores en GraphQL y Java</title>        
        <updated>2017-11-26T14:30:00+01:00</updated>
        <published>2017-11-26T10:30:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/11/paginacion-usando-cursores-en-graphql-y-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/graphql.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;GraphQL&#34; title=&#34;GraphQL&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;El conjunto de datos de una entidad en algunos casos será grande, miles o cientos de miles de registros, y por tanto no es viable devolverlos todos en una misma consulta por lo que es necesario realizar paginación devolviéndolos en pequeños grupos. La paginación se puede implementar de varias formas, habitualmente con un parámetro que limite el número de elementos a incluir en la página y otro parámetro &lt;em&gt;offset&lt;/em&gt; que deseche los primeros elementos hasta el primero deseado. Sin embargo, utilizar los parámetros &lt;em&gt;limit&lt;/em&gt; y &lt;em&gt;offset&lt;/em&gt; puede producir resultados inesperados si mientras la obtención de una página y la siguiente se insertan nuevos elementos anteriores al &lt;em&gt;offset&lt;/em&gt; ocasionando que lo que sería por ejemplo el décimo elemento pase a ser el undécimo.&lt;/p&gt;

&lt;p&gt;Si esta situación es importante se suelen utilizar cursores que utilizan un parámetro para indicar el número de elementos a incluir en la página pero en vez de un &lt;em&gt;offset&lt;/em&gt; utilizan el identificativo de un registro a partir del cual devolver registros de modo que aunque se inserten registros el primer elemento de la página no cambiará.&lt;/p&gt;

&lt;p&gt;En el caso de la &lt;a href=&#34;http://graphql.org/learn/pagination/&#34;&gt;paginación en GraphQL&lt;/a&gt; se proponen varias formas de implementar la paginación, una de ellas los cursores. En la documentación se explica la teoría, para implementarla es necesario &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/11/usar-un-resolver-para-recuperar-propiedades-en-graphql/&#34;&gt;crear un &lt;em&gt;data fetcher&lt;/em&gt; o &lt;em&gt;resolver&lt;/em&gt;&lt;/a&gt; que reciba los parámetros de &lt;em&gt;limit&lt;/em&gt; para indicar el número de elementos a devolver en la página y &lt;em&gt;after&lt;/em&gt; para indicar a partir de que elemento devolver elementos. También es necesario modificar el esquema de la API para tener en cuenta las nuevas estructuras de datos en las que se devuelven los resultados.&lt;/p&gt;

&lt;p&gt;En este ejemplo de una librería para mostrar la paginación he añadido a los libros una lista de comentarios que será en la que soporte paginación. La definición del esquema queda de la siguiente forma siguiendo la &lt;a href=&#34;https://facebook.github.io/relay/graphql/connections.htm&#34;&gt;especificación de Relay&lt;/a&gt; para lo cual se definen los tipos &lt;em&gt;CommentsConnection&lt;/em&gt;, &lt;em&gt;CommentEdge&lt;/em&gt; (usando &lt;em&gt;generics&lt;/em&gt; no sería necesario implementar unas de estas clases por cada entidad paginable) y &lt;em&gt;PageInfo&lt;/em&gt;. Los cursores son un dato opaco para el cliente pero que decodificado incluye el identificativo del comentario. La propiedad &lt;em&gt;comments&lt;/em&gt; utiliza un &lt;em&gt;resolver&lt;/em&gt; con parámetros que se usa para realizar la búsqueda y recuperar los elementos solicitados en la consulta.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/27db805fa81666ce6ca248c4e7409021.js?file=library.graphqls&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/27db805fa81666ce6ca248c4e7409021.js?file=CommentsConnection.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/27db805fa81666ce6ca248c4e7409021.js?file=CommentEdge.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/27db805fa81666ce6ca248c4e7409021.js?file=PageInfo.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;En el caso del ejemplo los datos se almacenan en unas listas creadas al iniciar la aplicación y la paginación y la obtención de los datos de la página se realiza usando &lt;em&gt;streams&lt;/em&gt; y con código Java para implementar la lógica según los parámetros de la paginación en el método &lt;em&gt;findComments&lt;/em&gt;. Si los datos estuvieran almacenados en una base de datos relacional o NoSQL se usarían las facilidades de sus lenguajes u operaciones de consulta como sería generar la sentencia SQL apropiada.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/27db805fa81666ce6ca248c4e7409021.js?file=LibraryRepository.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Los comentarios se obtienen usando un &lt;em&gt;data fetcher&lt;/em&gt; o &lt;em&gt;resolver&lt;/em&gt; que si existe para una determinada propiedad tiene precedencia sobre el &lt;em&gt;data fetcher&lt;/em&gt; por defecto que en Java obtiene el dato usando la convención de los &lt;em&gt;java beans&lt;/em&gt;. En este caso es el &lt;em&gt;resolver&lt;/em&gt; &lt;em&gt;BookResolver&lt;/em&gt; siendo el método &lt;em&gt;getComments&lt;/em&gt; el encargado de recuperar los datos de la propiedad &lt;em&gt;comments&lt;/em&gt; cuando se solicite en una consulta de GraphQL, recibe los datos de paginación y delega la búsqueda en el repositorio para que haga la consulta apropiada.&lt;/p&gt;

&lt;p&gt;La clase repositorio abstrae al &lt;em&gt;resolver&lt;/em&gt; de como o donde están guardados los datos, de esta forma se podría pasar de guardarlos en una base de datos &lt;a href=&#34;https://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt; a una base de datos &lt;a href=&#34;https://www.mongodb.com/&#34;&gt;MongoDB&lt;/a&gt; sin que el &lt;em&gt;resolver&lt;/em&gt; necesite ninguna modificación, también se podría optar por guardar los libros en una base de datos relacional y los comentarios en una base de datos MongoDB. El &lt;em&gt;resolver&lt;/em&gt; se encarga de crear las instancias de objetos necesarios de los tipos &lt;em&gt;CommentsConnection&lt;/em&gt;, &lt;em&gt;CommentEdge&lt;/em&gt; y &lt;em&gt;PageInfo&lt;/em&gt; para adaptarlos a las estructuras de datos apropiadas según la especificación de Relay en el servicio de GraphQL.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/27db805fa81666ce6ca248c4e7409021.js?file=BookResolver.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una vez implementada la paginación en los comentarios con la siguientes consultas se obtiene un libro usando una &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/11/consultas-con-parametros-para-filtrar-datos-en-graphql/&#34;&gt;consulta con un filtro&lt;/a&gt; todos sus comentarios, los 3 primeros comentarios usando el parámetro &lt;em&gt;limit&lt;/em&gt; y los siguientes tres comentarios a partir del tercero usando los parámetros &lt;em&gt;limit&lt;/em&gt; y &lt;em&gt;after&lt;/em&gt;. Obteniendo como respuesta un libro con únicamente los comentarios deseados. Cada elemento en el resultado contiene los datos solicitados junto con el valor del cursor que identifica al comentario además de incluir una estructura de datos &lt;em&gt;pageInfo&lt;/em&gt; con información sobre la paginación.&lt;/p&gt;

&lt;p&gt;Con el valor del cursor indicado en &lt;em&gt;pageInfo&lt;/em&gt; en la propiedad &lt;em&gt;endCursor&lt;/em&gt; se podría obtener la siguiente página de comentarios realizando otra consulta e indicándolo en el parámetro &lt;em&gt;after&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/27db805fa81666ce6ca248c4e7409021.js?file=curl-1.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/27db805fa81666ce6ca248c4e7409021.js?file=curl-2.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/27db805fa81666ce6ca248c4e7409021.js?file=curl-3.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Los cursores tiene la ventaja de que son opacos por lo que se evita que los clientes dependan de identificativos y podrían cambiarse sin que los clientes necesitasen modificaciones. Otra ventaja es que la especificación de Relay propone un marco y unas convenciones para estandarizar la paginación. Sin embargo, esta solo es una forma de hacer paginación y es perfectamente posible usar cualquier otra para adaptarla a las necesidades que haya por ejemplo añadiendo más datos a &lt;em&gt;pageInfo&lt;/em&gt; o con más u otros parámetros para realizar la consulta de paginación.&lt;/p&gt;

&lt;p&gt;Pero&amp;hellip; en este ejemplo por cada libro que se devuelve como resultado en la consulta se realiza una búsqueda de los comentarios ya que las propiedades de resultado en la consulta se recuperan una a una. Para la mayoría de propiedades esto no es problema ya que son propiedades que están en un objeto que no realizan consultas a una base de datos pero en el caso de los comentarios sí. Si se devolviesen muchos libros se realizaría una consulta para cada uno de ellos lo que no es eficiente. Si se devolviesen 500 libros y sus comentarios se realizarían 500 consultas para obtener los comentarios de cada libro, usando una base de datos relacional serían 1+500 consultas SQL por cada petición a GraphQL, 1 para obtener los libros y 500 para los comentarios. Como solución a este problema está la funcionalidad de &lt;em&gt;batching&lt;/em&gt; de GraphQL que permite obtener todos los comentarios de los libros en una única consulta, será tema para otro de los siguientes artículos de esta serie sobre GraphQL.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/GraphQL&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/11/consultas-con-parametros-para-filtrar-datos-en-graphql/</id>
        <title>Consultas con parámetros para filtrar datos en GraphQL</title>        
        <updated>2017-11-25T10:00:00+01:00</updated>
        <published>2017-11-25T10:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/11/consultas-con-parametros-para-filtrar-datos-en-graphql/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/graphql.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;GraphQL&#34; title=&#34;GraphQL&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;No será extraño que en una API para obtener datos esté la necesidad de realizar algún tipo de filtrado para recuperar únicamente la colección de datos deseados de todos los existentes en un repositorio. A las consultas de &lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt; se les pueden pasar argumentos que son recibidos por los métodos que actúan como punto de entrada de las consultas. Con los argumentos es posible implementar cualquier funcionalidad que se necesite, entre ellas el filtrado. Los argumentos pueden ser datos escalares o más complejos que se definen con la palabra reservada &lt;em&gt;input&lt;/em&gt; en el esquema.&lt;/p&gt;

&lt;p&gt;Usando el mismo ejemplo que he utilizado en artículos anteriores ahora en este caso implemento la funcionalidad de poder filtrar los libros de una biblioteca utilizando una expresión regular que el título del libro debe cumplir para obtenerse como resultado. El esquema del &lt;em&gt;enpoint&lt;/em&gt; de GraphQL queda de la siguiente forma para implementar el filtrado, usando el tipo definido con &lt;em&gt;input&lt;/em&gt; es posible pasar como argumentos datos complejos o agrupaciones de datos escalares.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/58fe2f31ef8b580d1f171baf615729b5.js?file=library.graphqls&#34;&gt;&lt;/script&gt;

&lt;p&gt;La implementación del tipo &lt;em&gt;BookFilter&lt;/em&gt; en la implementación de Java de GraphQL es una &lt;em&gt;Java Bean&lt;/em&gt; con una propiedad por cada argumento y sus correspondientes métodos &lt;em&gt;set&lt;/em&gt; y &lt;em&gt;get&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/58fe2f31ef8b580d1f171baf615729b5.js?file=BookFilter.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;La clase &lt;em&gt;Query&lt;/em&gt; es el punto de entrada a las consultas raíz y posee un método con el mimo nombre que la consulta solicitada en GraphQL y que en este caso es &lt;em&gt;findBooks&lt;/em&gt; que recibe como argumento una instancia del objeto &lt;em&gt;BookFilter&lt;/em&gt; que a su vez se lo proporciona al servicio de repositorio independiente de GraphQL para que haga la búsqueda adecuada según corresponda en el sistema de persistencia empleado. En el caso que los datos se guarden en una base de datos relacional posiblemente el filtrado se realiza ejecutando una sentencia SQL. En el caso del ejemplo como los datos están en una colección de una estructura de datos Java el filtrado se realiza usando los &lt;em&gt;streams&lt;/em&gt;, expresiones regulares y código Java.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/58fe2f31ef8b580d1f171baf615729b5.js?file=Query.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/58fe2f31ef8b580d1f171baf615729b5.js?file=LibraryRepository.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Siguiendo la idea del ejemplo es posible realizar el filtrado de los datos con los argumentos que sean necesarios y la lógica adecuada según el repositorio donde estén almacenados los datos ya sea en un sistema con una base de datos relacional como &lt;a href=&#34;https://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt; o NoSQL como &lt;a href=&#34;https://www.mongodb.com/&#34;&gt;MongoDB&lt;/a&gt;. Se podrían añadir más datos por ejemplo para filtrar por otros criterios como el número de páginas, autor o incluir otros parámetros para realizar otras funciones como especificar criterios de ordenación.&lt;/p&gt;

&lt;p&gt;Esta petición busca los libros que su título comience por las letras &lt;em&gt;O&lt;/em&gt; o &lt;em&gt;R&lt;/em&gt; obteniendo dos coincidencias como resultado. En este caso entre los datos solo se devuelve el título del libro pero perfectamente podrían haber sido cualesquiera otros de entre los que posee el tipo &lt;em&gt;Book&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/58fe2f31ef8b580d1f171baf615729b5.js?file=curl.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Pero&amp;hellip; ¿que ocurre si aún con el filtrado o en una consulta el número de coincidencias son unos cuantos miles? Seguramente sean demasiadas coincidencias para devolver en una única petición y por ello es habitual &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/11/paginacion-usando-cursores-en-graphql-y-java/&#34;&gt;realizar paginación en GraphQL&lt;/a&gt;. Eso será tema para otro de los siguientes artículos de esta serie sobre GraphQL.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/GraphQL&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/11/usar-un-resolver-para-recuperar-propiedades-en-graphql/</id>
        <title>Usar un resolver para recuperar propiedades en GraphQL</title>        
        <updated>2017-11-18T10:00:00+01:00</updated>
        <published>2017-11-18T10:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/11/usar-un-resolver-para-recuperar-propiedades-en-graphql/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/graphql.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;GraphQL&#34; title=&#34;GraphQL&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Cuando en una consulta de &lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt; se indican las propiedades a devolver GraphQL usa para cada una de ellas lo que en la implementación de Java se llama un &lt;em&gt;resolver&lt;/em&gt; y en otras implementaciones &lt;em&gt;data fetcher&lt;/em&gt;. En la mayoría de casos las propiedades serán propiedades de un objeto y en estos casos se usará un &lt;em&gt;PropertyDataFetcher&lt;/em&gt; usando en Java la convención de los &lt;em&gt;java beans&lt;/em&gt; o la clave de un mapa. En el caso de que cierto dato no esté almacenado en el objeto sino en un repositorio externo es necesario usar un &lt;em&gt;resolver&lt;/em&gt; para devolver esa propiedad en la consulta.&lt;/p&gt;

&lt;p&gt;Por ejemplo, supongamos que en el ejemplo de la librería en el caso de los libros le añadimos un nuevo dato para el ISBN que está almacenado en un sistema externo, en otro repositorio. La nueva definición del esquema quedaría de la siguiente forma, basta con añadir la nueva propiedad al tipo &lt;em&gt;Book&lt;/em&gt; y su tipo que será &lt;em&gt;String&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/34760803d8daad87514b967a6de0cf0c.js?file=library.graphqls&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para que una consulta que recupere el ISBN funcione correctamente es necesario implementar un &lt;em&gt;resolver&lt;/em&gt; creando una clase que implemente la interfaz &lt;em&gt;GraphQLResolver&amp;lt;Book&amp;gt;&lt;/em&gt; en la que se incluya un método &lt;em&gt;get&lt;/em&gt; por cada propiedad del tipo &lt;em&gt;Book&lt;/em&gt; que esté alamcenada en otro repositorio. Estos métodos &lt;em&gt;get&lt;/em&gt; reciben como parámetro el objeto &lt;em&gt;Book&lt;/em&gt; a partir del cual como contexto es posible tener los datos del libro del que hay que recuperar el ISBN, posiblemente utilizando su identificativo. En el ejemplo simplemente se devuelve un dato aleatorio pero perfectamente en caso necesario se podría usar un repositorio que lo recupere del sistema de información que lo almacena.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/34760803d8daad87514b967a6de0cf0c.js?file=BookResolver.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/34760803d8daad87514b967a6de0cf0c.js?file=curl.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;A la hora de definir el servicio de GraphQL hay que proporcionar el &lt;em&gt;resolver&lt;/em&gt; personalizado.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/34760803d8daad87514b967a6de0cf0c.js?file=Main.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Los &lt;em&gt;resolvers&lt;/em&gt; permiten almacenar la información en dos bases de datos distintas, una podría ser almacenar una información una base de datos relacional, otra información en una base de datos NoSQL, dos bases de datos relacionales distintas o inlcuso proporcionado por una API distinta. En cualquier caso para el usuario de la API y del servicio es transparente como esté almacenada la información.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/GraphQL&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://graphql-java.readthedocs.io/en/v5/schema.html&#34;&gt;Creating a schema&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/graphql-java/graphql-java/blob/master/src/main/java/graphql/schema/DataFetchingEnvironment.java&#34;&gt;DataFetchingEnvironment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/graphql-java/graphql-java/blob/master/src/main/java/graphql/schema/DataFetcher.java&#34;&gt;DataFetcher&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/11/devolver-mensajes-de-error-descriptivos-en-graphql/</id>
        <title>Devolver mensajes de error descriptivos en GraphQL</title>        
        <updated>2017-11-12T11:30:00+01:00</updated>
        <published>2017-11-12T11:30:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/11/devolver-mensajes-de-error-descriptivos-en-graphql/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/graphql.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;GraphQL&#34; title=&#34;GraphQL&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Por defecto &lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt; devuelve errores con mensajes descriptivos para los errores del cliente como son los errores de sintaxis en la sentencia de consulta o mutación, en el caso de que el campo solicitado no exista o no se ha indicado ninguno. En el caso de Java si se lanza una excepción en la clase repositorio que guarda los datos o en la lógica de negocio y no se captura GraphQL indicará que se ha producido un error interno en el servidor. Esto no es muy descriptivo y es mejor indicar errores más útiles para el usuario de la API como podría ser que no se tienen permisos para realizar la modificación o el error que se ha producido al validar los datos y por los que la operación no se ha completado.&lt;/p&gt;

&lt;p&gt;Los errores en GraphQL usando el lenguaje Java se gestionan implementando en una clase la interfaz &lt;a href=&#34;https://github.com/graphql-java/graphql-java/blob/master/src/main/java/graphql/GraphQLError.java&#34;&gt;GrapQLError&lt;/a&gt;, este podría ser en caso de una excepción que además de heredar de &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/Exception.html&#34;&gt;Exception&lt;/a&gt; implemente la interfaz &lt;em&gt;GraphQLError&lt;/em&gt;. Sin embargo, GraphQL cuando una clase hereda de &lt;em&gt;Exception&lt;/em&gt; lo considera un error interno del servidor y para no dar información interna del servicio a los clientes como mensaje indica únicamente &lt;em&gt;Internal Server Error(s) while executing query&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/403fbd324011c33f4e53a0b6b4992950.js?file=curl-default-errors.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para que GraphQL muestre el error personalizado deseado lanzando excepciones hay que adaptar esa excepción y que implementa &lt;em&gt;GraphQLError&lt;/em&gt; con una clase que únicamente implemente la interfaz &lt;em&gt;GraphQLError&lt;/em&gt; pero no herede de &lt;em&gt;Exception&lt;/em&gt;. Esta sería una clase adaptador necesaria.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/403fbd324011c33f4e53a0b6b4992950.js?file=GraphQLErrorAdapter.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para adaptar las clases excepción hay que cambiar el comportamiento de la clase &lt;em&gt;GraphQLErrorHandler&lt;/em&gt; de modo que transforme las excepciones a la clase &lt;em&gt;GraphQLError&lt;/em&gt; propia. Esta clase se indica al construir el objeto &lt;em&gt;SimpleGraphQLServlet&lt;/em&gt; y &lt;em&gt;ServletRegistrationBean&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/403fbd324011c33f4e53a0b6b4992950.js?file=Main.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;En el caso de este ejemplo solo un usuario de nombre &lt;em&gt;admin&lt;/em&gt; tiene permitido hacer modificaciones en la colección de libros guardados en la clase repositorio &lt;em&gt;LibraryRepository&lt;/em&gt;. Por otro lado, cuando se añade un libro se hace una validación de los datos comprobando que el autor del libro a añadir exista en la librería. Estos son las peticiones válidas.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/403fbd324011c33f4e53a0b6b4992950.js?file=curl.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Y estas las inválidas que devuelve los mensajes propios más descriptivos de los errores o validaciones realizadas en el servidor de más utilidad para un usuario del servicio.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/403fbd324011c33f4e53a0b6b4992950.js?file=curl-custom-errors.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;La interfaz &lt;em&gt;GraphQLError&lt;/em&gt; posee el método &lt;em&gt;getMessage()&lt;/em&gt; para devolver la descripción del mensaje pero con el método &lt;em&gt;getExtensions()&lt;/em&gt; es posible incluir cualquier dato en forma de clave-valor que deseemos como un código de error o cualquier otra información deseada. El caso de la excepción &lt;em&gt;PermissionException&lt;/em&gt; devuelve dos datos adicionales &lt;em&gt;foo&lt;/em&gt; y &lt;em&gt;fizz&lt;/em&gt;, en un caso real se implementaría una lógica más útil para devolver estos datos adicionales posiblemente proporcionándolos en el constructor u obteniéndolos con la referencia a algún objeto.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/403fbd324011c33f4e53a0b6b4992950.js?file=PermissionException.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/GraphQL&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/11/ejemplo-de-graphql-para-una-interfaz-de-un-servicio-con-spring-boot-y-java/&#34;&gt;Ejemplo de GraphQL para una interfaz de un servicio con Spring Boot y Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://graphql-java.readthedocs.io/en/v5/execution.html&#34;&gt;Execution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/graphql-java/graphql-java/blob/master/src/main/java/graphql/GraphQLError.java&#34;&gt;GraphQLError.java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/11/ejemplo-de-graphql-para-una-interfaz-de-un-servicio-con-spring-boot-y-java/</id>
        <title>Ejemplo de GraphQL para una interfaz de un servicio con Spring Boot y Java</title>        
        <updated>2017-12-02T13:00:00+01:00</updated>
        <published>2017-11-01T12:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/11/ejemplo-de-graphql-para-una-interfaz-de-un-servicio-con-spring-boot-y-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;GraphQL es una alternativa a una interfaz REST con las ventajas de poder realizar varias consultas en una misma petición y devolviendo únicamente los datos que requiera el cliente. Es una especificación y hay una implementación para los lenguajes de programación más populares entre ellos Java. Este artículo es una introducción con un ejemplo completo que muestra cómo se hacen consultas y modificaciones en los datos.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/graphql.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;GraphQL&#34; title=&#34;GraphQL&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Con anterioridad las aplicaciones que lo necesitaban ofrecían una interfaz como un servicio mediante &lt;em&gt;web services&lt;/em&gt;, sin embargo, esta tecnología era complicada por usar XML y no de fácil utilización en clientes JavaScript. La evolución que a día de hoy sigue siendo mayoritaria son las interfaces &lt;a href=&#34;https://es.wikipedia.org/wiki/Representational_State_Transfer&#34;&gt;REST&lt;/a&gt; que emplean la semántica de los verbos del protocolo HTTP para realizar operaciones de búsqueda, creación, modificación y eliminación y normalmente empleando JSON como formato para intercambiar los datos. Sin embargo, REST no está exento de algunos problemas como la necesidad de realizar varias peticiones a cada uno de los recursos que ofrece si se necesitan datos de varios de ellos, otro es que los datos ofrecidos por los servicios REST está prefijados en tiempo de desarrollo no adaptándose a lo que necesita el cliente. En cierta medida estas dos cosas se pueden implementar en la interfaz REST con algunos parámetros pero requiere codificarlo explícitamente.&lt;/p&gt;

&lt;p&gt;Más recientemente ha aparecido otra forma de implementar una interfaz de un servicio con &lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt; considerándose una &lt;a href=&#34;https://www.howtographql.com/basics/1-graphql-is-the-better-rest/&#34;&gt;alternativa mejor a REST&lt;/a&gt; que solventa los dos problemas de las interfaces REST anteriores. REST ofrece en varios &lt;em&gt;endpoints&lt;/em&gt; los recursos que pueden ser accedidos mediante los verbos HTTP (&lt;em&gt;GET&lt;/em&gt;, &lt;em&gt;PUT&lt;/em&gt;, &lt;em&gt;POST&lt;/em&gt;, &lt;em&gt;DELETE&lt;/em&gt;), en GraphQL por el contrario hay un único &lt;em&gt;endpoint&lt;/em&gt;, los puntos de entrada al grafo y los tipos que se relacionan entre si que son consultados para obtener los datos con el lenguaje de consulta que ofrece GraphQL.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.howtographql.com/basics/0-introduction/&#34;&gt;Basics Tutorial - Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.howtographql.com/basics/1-graphql-is-the-better-rest/&#34;&gt;GraphQL is the better REST&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.howtographql.com/basics/2-core-concepts/&#34;&gt;Core Concepts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.howtographql.com/basics/3-big-picture/&#34;&gt;Big Picture (Architecture)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En GraphQL se define un &lt;a href=&#34;http://graphql.org/learn/schema/&#34;&gt;esquema&lt;/a&gt; con la definición de los tipos en la API, se diferencia la obtención de los datos que es realizada por las &lt;a href=&#34;http://graphql.org/learn/queries/&#34;&gt;&lt;em&gt;queries&lt;/em&gt;&lt;/a&gt; y de las modificaciones que es realizada por los &lt;a href=&#34;http://graphql.org/learn/queries/#mutations&#34;&gt;&lt;em&gt;mutators&lt;/em&gt;&lt;/a&gt;, el esquema se puede definir en un archivo de texto como en este ejemplo o de forma programática con código que es necesario para algunas personalizaciones. Otras tareas que pueden ser necesarias en una API son &lt;a href=&#34;https://www.howtographql.com/graphql-java/5-authentication/&#34;&gt;autenticación&lt;/a&gt; que es posible capturando los datos del contexto provenientes en los datos o como cabeceras de la petición posiblemente en forma de &lt;em&gt;token&lt;/em&gt; de &lt;a href=&#34;https://oauth.net/&#34;&gt;OAuth&lt;/a&gt; y la autorización en la lógica del servicio en base al sujeto autenticado. Se puede &lt;a href=&#34;http://graphql.org/learn/schema/#scalar-types&#34;&gt;usar datos propios con &lt;em&gt;scalar&lt;/em&gt;&lt;/a&gt; para los cuales se ha de proporcionar una clase que realice la transformación implementando una clase GraphQLScalarType. Posee &lt;a href=&#34;http://graphql.org/learn/introspection/&#34;&gt;funcionalidades de introspección&lt;/a&gt; y también &lt;a href=&#34;https://www.howtographql.com/graphql-java/9-filtering/&#34;&gt;filtrado&lt;/a&gt;, &lt;a href=&#34;https://www.howtographql.com/graphql-java/10-pagination/&#34;&gt;paginación&lt;/a&gt;, &lt;a href=&#34;https://www.howtographql.com/graphql-java/7-error-handling/&#34;&gt;gestión de errores&lt;/a&gt; y &lt;a href=&#34;http://graphql.org/learn/caching/&#34;&gt;cacheo&lt;/a&gt; aunque esto último es menos efectivo en GraphQL al depender de los datos a devolver que solicite el cliente.&lt;/p&gt;

&lt;p&gt;Para usar GraphQL hay que definir un &lt;em&gt;schema&lt;/em&gt; que incluye los tipos, sus propiedades y tipos. También se pueden usar &lt;a href=&#34;http://graphql.org/learn/caching/&#34;&gt;fragmentos&lt;/a&gt; para reutilizar partes de la definición de los tipos. Cada &lt;em&gt;type&lt;/em&gt; representa una entidad que definen las propiedades que posee ya sean datos escalares o referencias a otras entidades formando de esta manera grafos de objetos, los tipos de las variables que poseen una exclamación al final quiere decir que son opcionales, por defecto todos los datos son distinto de nulo. Las listas se definen con corchetes y el tipo entre ellos. Este es el IDL del esquema del ejemplo.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=library.graphqls&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una definido el esquema hay que desarrollar los &lt;em&gt;resolvers&lt;/em&gt; que son encargados de obtener los datos seguramente de una base de datos externa ya sea una base de datos SQL o NoSQL en este caso utilizando una clase que implementa el patrón repositorio y que abstrae del sistema de persistencia donde se almacenan los datos.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=Query.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=LibraryRepository.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=Book.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=Author.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Los &lt;em&gt;mutators&lt;/em&gt; son los encargados de procesar las peticiones de modificación.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=Mutation.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Usando una aplicación de &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; para ofrecer el servicio hay que realizar la contribución adecuada al contenedor de dependencias, en Java GraphQL se define como un &lt;a href=&#34;https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html&#34;&gt;&lt;em&gt;servlet&lt;/em&gt;&lt;/a&gt; al cual hay que proporcionarle la configuración de los &lt;em&gt;resolvers&lt;/em&gt;, &lt;em&gt;mutators&lt;/em&gt;, procesador de contexto que en este caso se utiliza para la autenticación y definición del esquema entre otras posibles cosas.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=AuthContext.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;El lenguaje de consulta GraphQL permite consultar el grafo de objetos y recuperar los datos deseados. En el siguiente ejemplo se obtienen los libros, los autores y los libros con los datos de sus autores de una clase que implementa el patrón &lt;em&gt;repository&lt;/em&gt;. En el ejemplo los datos del repositorio están definidos en la propia clase de forma estática pero como su función es abstraer de donde se obtienen los datos el cambio sería sencillo para que los obtuviese de una base de datos SQL o NoSQL ya que los cambios estarían encapsulados principalmente en esa clase. Los datos son devueltos en formato JSON.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=curl-1.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una de las ventajas de GraphQL sobre REST es que es posible realizar una única petición lo que en REST podrían ser varias. Por ejemplo, la siguiente consulta obtiene en una única consulta todos los libros, todos los autores y el autor con identificativo 1 de la biblioteca, esto mejora el rendimiento ya que en REST se hubiesen requerido varias peticiones una para obtener libros, otra para los autores y otra para el autor 1. La otra ventaja sobre REST es que se devuelven únicamente los datos que el cliente solicita y no una lista prefijada por el desarrollador de la interfaz.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=curl-2.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Las consultas puede hacerse mediante una petición &lt;em&gt;GET&lt;/em&gt; o &lt;em&gt;POST&lt;/em&gt; de HTTP.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=curl-3.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Las peticiones de modificación se envían mediante &lt;em&gt;POST&lt;/em&gt;. Este es el caso para añadir un libro a la biblioteca y los casos de que el autor del libro no sea válido o que el usuario que añade el libro no tenga permisos. En el ejemplo los errores no son descriptivos de lo que realmente ha sucedido, habría que hacer el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/11/devolver-mensajes-de-error-descriptivos-en-graphql/&#34;&gt;tratamiento de errores adecuado para que los mensajes fuesen más descriptivos&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=curl-4.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=PermissionException.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=ValidationException.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;La forma explicada en las guías de GraphQL para Java es que el &lt;em&gt;mutator&lt;/em&gt; reciba los datos y este delegue la funcionalidad en una clase que implemente el patrón &lt;em&gt;repository&lt;/em&gt; que abstrae del sistema de almacenamiento (base de datos SQL, NoSQL o cualquier otro), además, este patrón &lt;em&gt;repository&lt;/em&gt; o clase de lógica de negocio se recomienda que implemente la funcionalidad necesaria para aplicar la autorización. En el ejemplo aunque de forma sencilla solo en usuario &lt;em&gt;admin&lt;/em&gt; tiene permitido añadir libros, en un proyecto es posible realizar la autenticación usando &lt;a href=&#34;http://www.keycloak.org/&#34;&gt;Keycloak&lt;/a&gt; como sistema de OAuth, usar el &lt;em&gt;token&lt;/em&gt; de OAuth para implementar la autorización y un &lt;em&gt;framework&lt;/em&gt; de seguridad como &lt;a href=&#34;http://shiro.apache.org/&#34;&gt;Apache Shiro&lt;/a&gt; para aplicar los permisos a las funcionalidades.&lt;/p&gt;

&lt;p&gt;Los artículos &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/09/autenticacion-con-oauth-y-keycloak-en-un-servicio-rest-con-jax-rs-y-spring-boot/&#34;&gt;Autenticación con OAuth y Keycloak en un servicio REST con JAX-RS y Spring Boot&lt;/a&gt; y &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/10/integrar-autenticacion-oauth-con-keycloak-shiro-apache-tapestry-y-spring-boot/&#34;&gt;Integrar autenticación OAuth con Keycloak, Shiro, Apache Tapestry y Spring Boot&lt;/a&gt; pueden servir como base para añadir autenticación OAuth a un servicio GraphQL con Keycloak.&lt;/p&gt;

&lt;p&gt;Finalmente, el archivo de construcción de &lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt; del ejemplo con las dependencias necesarias. &lt;a href=&#34;https://github.com/graphql-java/graphql-java&#34;&gt;graphql-java&lt;/a&gt; contiene la implementación para Java de GraphQL, &lt;a href=&#34;https://github.com/graphql-java/graphql-java-servlet&#34;&gt;graphql-java-servlet&lt;/a&gt; la implementación de GraphQL mediante un &lt;em&gt;servlet&lt;/em&gt; y &lt;a href=&#34;https://github.com/graphql-java/graphql-java-tools&#34;&gt;graphql-java-tools&lt;/a&gt; son varias utilidades que facilitan en gran medida el desarrollo de un servicio para GraphQL como la construcción del esquema mediante su definición IDL o crear &lt;em&gt;resolvers&lt;/em&gt; fácilmente.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/4276fa433729ff8187219939d3218a00.js?file=build.gradle&#34;&gt;&lt;/script&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/GraphQL&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://graphql-java.readthedocs.io/en/v5/&#34;&gt;Welcome to graphql-java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/graphql-java/graphql-java&#34;&gt;GraphQL Java implementation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.howtographql.com/graphql-java/2-queries/&#34;&gt;Queries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/graphql-java/graphql-java-tools&#34;&gt;A schema-first tool for graphql-java inspired by graphql-tools for JS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.graph.cool&#34;&gt;GraphQL Backend Development Framework&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.genbetadev.com/desarrollo-aplicaciones-moviles/por-que-deberiamos-abandonar-rest-y-empezar-a-usar-graphql-en-nuestras-apis&#34;&gt;¿Por qué deberíamos abandonar REST y empezar a usar GraphQL en nuestras APIs?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.paradigmadigital.com/dev/graphql-todos-uno-uno-todos/&#34;&gt;GraphQL: ¡todos para uno y uno para todos!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.adictosaltrabajo.com/tutoriales/introduccion-a-graphql/&#34;&gt;Introducción a GraphQL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
</feed>
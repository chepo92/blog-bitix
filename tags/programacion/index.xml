<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://picodotdev.github.io/blog-bitix/tags/programacion/</id>
    <title type="text">Blog Bitix</title>
    <subtitle>Recent content on Blog Bitix</subtitle>
    <updated>2018-06-01T17:00:00+02:00</updated>
    <author><name>pico.dev</name></author>
    <generator>Hugo</generator>
    <icon>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</icon>
    <logo>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</logo>
    <rights>https://creativecommons.org/licenses/by-sa/4.0/</rights>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/06/dependencias-sobre-librerias-de-lado-de-cliente-con-webjars-en-una-aplicacion-web-java/</id>
        <title>Dependencias sobre librerías de lado de cliente con Webjars en una aplicación web Java</title>        
        <updated>2018-06-01T17:00:00+02:00</updated>
        <published>2018-06-01T17:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/06/dependencias-sobre-librerias-de-lado-de-cliente-con-webjars-en-una-aplicacion-web-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/webjars.png&#34; class=&#34;right &#34; width=&#34;250&#34; alt=&#34;Webjars&#34; title=&#34;Webjars&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Una aplicación web se compone de código de lado de servidor, en el caso de utilizar el lenguaje de programación Java de código Java normalmente utilizando algún de los muchos &lt;em&gt;framework&lt;/em&gt; web, por otra parte se compone de código de lado de cliente con una gran variedad de librerías de JavaScript como &lt;a href=&#34;https://jquery.com/&#34;&gt;jQuery&lt;/a&gt;, &lt;a href=&#34;https://facebook.github.io/react/&#34;&gt;React&lt;/a&gt;, &lt;a href=&#34;http://underscorejs.org/&#34;&gt;Underscore&lt;/a&gt; o &lt;a href=&#34;http://getbootstrap.com/&#34;&gt;Bootstrap&lt;/a&gt; para los estilos. En las aplicaciones Java las librerías de lado de servidor se gestionan como dependencias del proyecto y con herramientas como &lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt; se puede automatizar el descargar la librería de repositorios como &lt;a href=&#34;https://search.maven.org/&#34;&gt;Maven Central&lt;/a&gt; y la versión que se necesite así como hacer sencillo actualizar a una nueva. En el caso de las librerías de lado del cliente con &lt;a href=&#34;https://www.webjars.org/&#34;&gt;Webjars&lt;/a&gt; se consiguen los mismos beneficios.&lt;/p&gt;

&lt;p&gt;Los &lt;em&gt;webjars&lt;/em&gt; son librerías de extensión &lt;em&gt;jar&lt;/em&gt; con los recursos de lado del cliente empaquetados en ellos que en el momento de ser requeridos pueden ser devueltos como un recurso estático por la aplicación, incluyen los archivos JavaScript sin minimizar y minimizados, los archivos &lt;em&gt;map&lt;/em&gt; para depuración si minimizados están ofuscados, recursos de estilos CSS o imágenes. Se gestionan como cualquier otra dependencia del proyecto Java lo que proporciona las mismas ventajas de obtener las dependencias de forma automática y hace fácil actualizar a una nueva versión. Por si fuera poco es muy sencillo utilizar &lt;em&gt;webjars&lt;/em&gt;, para los &lt;em&gt;frameworks&lt;/em&gt; más populares se ofrece una pequeña guía de uso en la &lt;a href=&#34;https://www.webjars.org/documentation&#34;&gt;documentación&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Las librerías más populares de JavaScript o CSS están empaquetadas como &lt;em&gt;webjars&lt;/em&gt; en las diferentes versiones y han sido publicadas de forma que es posible añadir la dependencia en la versión concreta que necesite la aplicación. Dado que los &lt;em&gt;webjars&lt;/em&gt; se gestionan como una dependencia Java si estos a su vez tiene alguna dependencia sobre otra librería está se incluyen en el proyecto de forma transitiva. El contenido del &lt;em&gt;webjar&lt;/em&gt; para &lt;em&gt;jQuery&lt;/em&gt; es el siguiente.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/6a355258c390e165cebc46871ce54309.js?file=jquery-webjar.out&#34;&gt;&lt;/script&gt;

&lt;p&gt;En el caso del &lt;em&gt;framework&lt;/em&gt; web &lt;a href=&#34;https://tapestry.apache.org/&#34;&gt;Apache Tapestry&lt;/a&gt; basado en componentes para el desarrollo de aplicaciones web Java tan solo hay que incluir la dependencia en el proyecto y un poco de configuración en el módulo de la aplicación para el contenedor de dependencias como se indica en la &lt;a href=&#34;https://www.webjars.org/documentation#tapestry&#34;&gt;guía de uso&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/6a355258c390e165cebc46871ce54309.js?file=AppModule.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/6a355258c390e165cebc46871ce54309.js?file=build.gradle&#34;&gt;&lt;/script&gt;

&lt;p&gt;Inspeccionando el código fuente de la página devuelta se observa que en el caso de Tapestry la URL generada al solicitar en un &lt;em&gt;webjar&lt;/em&gt; es del estilo &lt;em&gt;https://localhost:8443/assets/webjars/z941c28a3/requirejs/2.3.5/require.js&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    
  
  
  
  
  
  

  
  
  

  
  
  















&lt;figure&gt;
    
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/06/dependencias-sobre-librerias-de-lado-de-cliente-con-webjars-en-una-aplicacion-web-java/images/tapestry-webjars_hu48db32848ea69c233c28d50d292a5a09_470668_2560x1440_fit_box_2.png&#34; title=&#34;Apache Tapestry con Webjars&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/06/dependencias-sobre-librerias-de-lado-de-cliente-con-webjars-en-una-aplicacion-web-java/images/tapestry-webjars_hu48db32848ea69c233c28d50d292a5a09_470668_650x450_fit_box_2.png&#34; width=&#34;650&#34; height=&#34;392&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Apache Tapestry con Webjars&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;

&lt;p&gt;Los &lt;em&gt;webjars&lt;/em&gt; muy útiles para gestionar las librerías de lado cliente que hacen innecesario descargar manualmente las dependencias, automatizan la descarga, hacen muy sencillo actualizar a nuevas versiones y es muy fácil de usar al no requerir mucha confiración ni ser invasiva. Además, al estar como una dependencia en el archivo de construcción del proyecto queda indicado de forma explícita que el proyecto utiliza y necesita esa librería. Para mi son una herramienta imprescindible.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/PlugInTapestry&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2014/12/portada-PugInTapestry-thumb.png&#34; alt=&#34;Portada libro: PlugIn Tapestry&#34; title=&#34;Portada libro: PlugIn Tapestry&#34; style=&#34;float: left; margin-right: 1.5em;&#34;&gt;
    &lt;h3&gt;Libro PlugIn Tapestry&lt;/h3&gt;
    &lt;p&gt;Si te interesa Apache Tapestry descarga gratis el libro de más de 300 páginas que he escrito sobre este &lt;i&gt;framework&lt;/i&gt; en el formato que prefieras, &lt;a href=&#34;http://picodotdev.github.io/blog-bitix/2014/02/libro-sobre-desarrollo-de-aplicaciones-con-apache-tapestry/&#34;&gt;PlugIn Tapestry: Desarrollo de aplicaciones y páginas web con Apache Tapestry&lt;/a&gt;, y el código de ejemplo asociado. En el libro comento detalladamente muchos aspectos que son necesarios en una aplicación web como persistencia, pruebas unitarias y de integración, inicio rápido, seguridad, formularios, internacionalización (i18n) y localización (l10n), AJAX, ... y como abordarlos usando Apache Tapestry.&lt;/p&gt;
    &lt;br style=&#34;clear: both;&#34;&gt;
    &lt;div class=&#34;buttons&#34;&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/custom/PlugInTapestry.pdf&#34; class=&#34;btn btn-lg btn-success&#34;&gt;PDF&lt;/a&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/custom/PlugInTapestry.epub&#34; class=&#34;btn btn-lg btn-success&#34;&gt;EPUB&lt;/a&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/custom/PlugInTapestry.mobi&#34; class=&#34;btn btn-lg btn-success&#34;&gt;MOBI&lt;/a&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/custom/PlugInTapestry.zip&#34; class=&#34;btn btn-lg btn-success&#34;&gt;HTML&lt;/a&gt;
    &lt;/div&gt;
    &lt;div class=&#34;buttons&#34;&gt;
        &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/PlugInTapestry&#34; class=&#34;btn btn-lg btn-success&#34;&gt;Código fuente ejemplos&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.baeldung.com/maven-webjars&#34;&gt;Introduction to WebJars&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
                <category term="tapestry"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/05/empaquetar-una-aplicacion-java-en-un-archivo-jar-ejecutable-incluyendo-sus-dependencias/</id>
        <title>Empaquetar una aplicación Java en un archivo jar ejecutable incluyendo sus dependencias</title>        
        <updated>2018-05-26T18:15:00+02:00</updated>
        <published>2018-05-26T12:15:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/05/empaquetar-una-aplicacion-java-en-un-archivo-jar-ejecutable-incluyendo-sus-dependencias/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Las aplicaciones Java se distribuyen en uno o varios archivos &lt;em&gt;jar&lt;/em&gt;. Si queremos facilitar la distribución de la aplicación con un único archivo &lt;em&gt;jar&lt;/em&gt; existe la posibilidad de reempaquetar el &lt;em&gt;jar&lt;/em&gt; de la aplicación y sus dependencias en tiempo de ejecución en un nuevo archivo &lt;em&gt;jar&lt;/em&gt; que lo contenga todo, a este nuevo &lt;em&gt;jar&lt;/em&gt; se le conoce como &lt;em&gt;uberjar&lt;/em&gt; o &lt;em&gt;fatjar&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;La forma de distribuir el código compilado a &lt;em&gt;bytecode&lt;/em&gt; en Java es a través de archivos de extensión &lt;em&gt;jar&lt;/em&gt;. Los archivos &lt;em&gt;jar&lt;/em&gt; no son más que archivos comprimidos den formato &lt;em&gt;zip&lt;/em&gt;. Si se les cambia de extensión y se descomprimen se extrae su contenido seguramente con una buena cantidad de archivos de extensión &lt;em&gt;class&lt;/em&gt; que es la extensión para los archivos Java compilados a &lt;em&gt;bytecode&lt;/em&gt; y que la máquina virtual interpreta para su ejecución. Las librerías que use la aplicación también se deben distribuir junto a esta para que funcione, por lo que la aplicación se distribuirá en forma de una colección de archivos &lt;em&gt;jar&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Una aplicación distribuida en forma de múltiples archivos archivos &lt;em&gt;jar&lt;/em&gt; se ejecuta con una línea de comandos como la siguiente en la que el parámetro &lt;em&gt;-cp&lt;/em&gt; indica las ubicaciones donde se buscarán librerías &lt;em&gt;jar&lt;/em&gt; y archivos &lt;em&gt;class&lt;/em&gt; si se distribuyen de forma individual, el segundo parámetro indica la clase que contiene el método &lt;em&gt;main&lt;/em&gt; que inicia la aplicación. Previamente hay que compilar el proyecto con &lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9f599ab10340e025d87a14bdde97941b.js?file=gradlew-assemble.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;En este caso se trata de una aplicación que emite un arte en formato &lt;em&gt;ascii&lt;/em&gt; en la terminal donde para cada linea se usa un color diferente mediante la librería &lt;a href=&#34;https://github.com/fusesource/jansi&#34;&gt;Jansi&lt;/a&gt; que la aplicación tiene como dependencia.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9f599ab10340e025d87a14bdde97941b.js?file=java-cp.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    
  
  
  
  
  
  

  
  
  

  
  
  















&lt;figure&gt;
    
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/05/empaquetar-una-aplicacion-java-en-un-archivo-jar-ejecutable-incluyendo-sus-dependencias/images/java-uberjar_hu4417091eb637a5f89cf2c0f6a4d596d3_73966_2560x1440_fit_box_2.png&#34; title=&#34;Aplicación de ejemplo&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/05/empaquetar-una-aplicacion-java-en-un-archivo-jar-ejecutable-incluyendo-sus-dependencias/images/java-uberjar_hu4417091eb637a5f89cf2c0f6a4d596d3_73966_650x450_fit_box_2.png&#34; width=&#34;650&#34; height=&#34;143&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Aplicación de ejemplo&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;

&lt;p&gt;Cuando la aplicación está contenida en un archivo &lt;em&gt;jar&lt;/em&gt; y se ejecuta con la opción &lt;em&gt;-jar&lt;/em&gt; se ignora el parámetro &lt;em&gt;-cp&lt;/em&gt; y no se indica la clase &lt;em&gt;main&lt;/em&gt; del punto de entrada de la aplicación. En el caso de las aplicaciones distribuidas en un archivo &lt;em&gt;jar&lt;/em&gt; tanto la clase &lt;em&gt;main&lt;/em&gt; como las dependencias se indican en un archivo de manifiesto incluido en el propio archivo &lt;em&gt;jar&lt;/em&gt;. El archivo se ubica en &lt;em&gt;META-INF/MANIFEST.MF&lt;/em&gt; dentro del &lt;em&gt;jar&lt;/em&gt;, es un archivo de texto donde se indican varias propiedades en forma de atributo y valor, una en cada linea. Un ejemplo de archivo de manifiesto sería el siguiente:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9f599ab10340e025d87a14bdde97941b.js?file=MANIFEST.MF&#34;&gt;&lt;/script&gt;

&lt;p&gt;La propiedad &lt;em&gt;Manifest-Version&lt;/em&gt; y &lt;em&gt;Created-By&lt;/em&gt; son informativas de la versión del archivo de manifiesto y el autor de la librería &lt;em&gt;jar&lt;/em&gt;. La propiedad &lt;em&gt;Main-Class&lt;/em&gt; indica la clase &lt;em&gt;main&lt;/em&gt; de la librería o aplicación y la propiedad &lt;em&gt;Class-Path&lt;/em&gt; es una lista separada por espacios de librerías adicionales. Las propiedades &lt;em&gt;Main-Class&lt;/em&gt; y &lt;em&gt;Class-Path&lt;/em&gt; son los parámetros que indicamos como parámetros en el comando &lt;em&gt;java&lt;/em&gt; anterior. Con el archivo &lt;em&gt;jar&lt;/em&gt;, su manifiesto y las librerías la aplicación Java se inicia de forma un poco más sencilla que antes al no tener que indicar ni la clase &lt;em&gt;main&lt;/em&gt; ni el &lt;em&gt;classpath&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9f599ab10340e025d87a14bdde97941b.js?file=java-jar.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Como en este caso, si Java no se encuentra la dependencia de Jansi y se produce la siguiente excepción que indica que no se ha encontrado una clase necesaria.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9f599ab10340e025d87a14bdde97941b.js?file=Exception.out&#34;&gt;&lt;/script&gt;

&lt;p&gt;Sin embargo, para distribuir la aplicación aún hay que distribuir varios archivos &lt;em&gt;jar&lt;/em&gt;, el de la aplicación y los &lt;em&gt;jar&lt;/em&gt; de las librerías que necesite la aplicación. En este caso solo es un &lt;em&gt;jar&lt;/em&gt; adicional ya que la aplicación solo tiene una dependencia y esta transitivamente no tiene ninguna otra pero en una aplicación más compleja el número de dependencias puede llegar a la centena.&lt;/p&gt;

&lt;p&gt;Para hacer la distribución más sencilla hay una posibilidad que usan algunos programadores de Java que es reempaquetar todas las clases del &lt;em&gt;jar&lt;/em&gt; de la aplicación y de las librerías en un nuevo &lt;em&gt;jar&lt;/em&gt;, a esta opción de reempaquetar las clases se le conoce como &lt;em&gt;uberjar&lt;/em&gt; o &lt;em&gt;fatjar&lt;/em&gt;. En la herramienta de construcción Gradle existe un &lt;em&gt;plugin&lt;/em&gt; para realizar esta tarea de creación del &lt;em&gt;uberjar&lt;/em&gt; pero también se puede hacer definiendo una tarea sin necesidad del &lt;em&gt;plugin&lt;/em&gt;. El archivo de Gradle adaptado para producir un &lt;em&gt;uberjar&lt;/em&gt; de forma automatizada es el siguiente. La tarea importante en el caso del ejemplo es &lt;em&gt;uberJar&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9f599ab10340e025d87a14bdde97941b.js?file=build.gradle&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con el siguiente comando la ejecución de la aplicación empaquetada como &lt;em&gt;uberjar&lt;/em&gt; produce el mismo resultado. Con el &lt;em&gt;uberjar&lt;/em&gt; en el archivo de manifiesto no es necesario incluir el atributo &lt;em&gt;Class-Path&lt;/em&gt; ya que todas las clases necesarias tanto de la aplicación como de las dependencias ha sido empaquetadas en el &lt;em&gt;jar&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9f599ab10340e025d87a14bdde97941b.js?file=java-jar-uberjar.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/9f599ab10340e025d87a14bdde97941b.js?file=System.out&#34;&gt;&lt;/script&gt;

&lt;p&gt;Hay un &lt;a href=&#34;http://imperceptiblethoughts.com/shadow/&#34;&gt;&lt;em&gt;plugin&lt;/em&gt; de Gradle para generar &lt;em&gt;uberjars&lt;/em&gt;&lt;/a&gt; que ofrece varias opciones para filtrar los archivos que se incluyen en el &lt;em&gt;fatjar&lt;/em&gt;, fusionar los archivos de servicios que permiten extender funcionalidades y otras tareas para realizar generar el distribuible con &lt;em&gt;distShadowZip&lt;/em&gt; y &lt;em&gt;distShadowTar&lt;/em&gt;. &lt;a href=&#34;https://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; ofrece algo similar con la tarea &lt;em&gt;bootRepackage&lt;/em&gt; pero si no se trata de una aplicación que use Spring Boot lo anterior sirve para cualquier otra aplicación Java como sería el caso de una &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/10/introduccion-a-javafx-aplicaciones-de-escritorio-en-java/&#34;&gt;aplicación de escritorio que utiliza JavaFX&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Que la aplicación sea un único &lt;em&gt;jar&lt;/em&gt; tiene la ventaja que el distribuible es más sencillo y facilita desplegarlo en un entorno de producción, en el caso de usar &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; también es más adecuado un único archivo.&lt;/p&gt;

&lt;p&gt;Entre la documentación hay unas muy buenas &lt;a href=&#34;http://docs.oracle.com/javase/tutorial/index.html&#34;&gt;guías prácticas sobre Java&lt;/a&gt;, una de ellas sobre el &lt;a href=&#34;http://docs.oracle.com/javase/tutorial/deployment/jar/index.html&#34;&gt;empaqueado de apliaciones en archivos &lt;em&gt;jar&lt;/em&gt;&lt;/a&gt;. La información que se encuentra en estas guías y tutoriales es muy valiosa para cualquier programador que use el lenguaje Java.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaUberjar&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew assemble &amp;amp;&amp;amp; java -jar build/libs/JavaUberjar-uberjar.jar&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.baeldung.com/gradle-fat-jar&#34;&gt;Creating a Fat Jar in Gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://imperceptiblethoughts.com/shadow/&#34;&gt;Shadow Plugin User Guide &amp;amp; Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mkyong.com/gradle/gradle-create-a-jar-file-with-dependencies/&#34;&gt;Gradle – Create a Jar file with dependencies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javacodegeeks.com/2012/11/packing-your-java-application-as-one-or-fat-jar.html&#34;&gt;Packing your Java application as one (or fat) JAR&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/05/recuperar-datos-eficientemente-en-graphql-usando-batching/</id>
        <title>Recuperar datos eficientemente en GraphQL usando batching</title>        
        <updated>2018-05-20T19:00:00+02:00</updated>
        <published>2018-05-20T19:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/05/recuperar-datos-eficientemente-en-graphql-usando-batching/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/graphql.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;GraphQL&#34; title=&#34;GraphQL&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Dada una consulta con los datos a recuperar &lt;a href=&#34;http://graphql.org/&#34;&gt;GraphQL&lt;/a&gt; hace una llamada al correspondiente &lt;em&gt;resolver&lt;/em&gt; o &lt;em&gt;data fecher&lt;/em&gt; para obtener el valor de cada propiedad. Cuando se tratan de propiedades en un &lt;em&gt;java bean&lt;/em&gt; esto no supone ningún problema en cuanto a rendimiento pero cuando obtener el valor de una propiedad es costoso la consulta resulta ineficiente.&lt;/p&gt;

&lt;p&gt;Por ejemplo, siguiendo el ejemplo que he utilizado en anteriores &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/graphql/&#34;&gt;artículos sobre GraphQL&lt;/a&gt; de una librería en la que hay un tipo para representar un libro con una propiedad con sus comentarios, con una consulta que permite recuperar los libros para cada uno de ellos se llama al &lt;em&gt;resolver&lt;/em&gt; que recupera los comentarios. En este ejemplo no ya que están los datos en memoria y no se usa una base de datos pero si recuperar los comentarios de cada libro supusiera una consulta SQL en una base de datos relacional (o tráfico de red en una base de datos NoSQL u otro servicio) y la lista de libros devuelta fuese grande cada vez que se realizará esta consulta el número de sentencias SQL a ejecutar sería grande y el tiempo de respuesta pobre y con una carga mayor para el servidor de base de datos.&lt;/p&gt;

&lt;p&gt;Para hacer eficientemente este caso en GraphQL existe la funcionalidad de &lt;em&gt;batching&lt;/em&gt; con la que un &lt;em&gt;resolver&lt;/em&gt; o &lt;em&gt;data fecher&lt;/em&gt; puede recuperar los comentarios de todos los libros en una misma petición. Para esto GraphQL proporciona al &lt;em&gt;resolver&lt;/em&gt; en vez de cada libro individual la lista de todos los libros para los cuales hay recuperar los comentarios.&lt;/p&gt;

&lt;p&gt;Esta es la teoría ya que en el momento de escribir este artículo en la &lt;a href=&#34;https://github.com/graphql-java/graphql-java-tools&#34;&gt;librería de utilidades que hace más sencillo usar GraphQL en Java&lt;/a&gt; se implementó una &lt;a href=&#34;https://github.com/graphql-java/graphql-java-tools/issues/12&#34;&gt;petición de mejora para añadir &lt;em&gt;batching&lt;/em&gt;&lt;/a&gt; a los &lt;em&gt;resolvers&lt;/em&gt;, en su momento se añadió la funcionalidad pero no de forma correcta como me di cuenta a escribir y probar el ejemplo de esta serie de artículos de modo que les creé esta &lt;a href=&#34;https://github.com/graphql-java/graphql-java-tools/issues/93&#34;&gt;petición para corregir el soporte de &lt;em&gt;batching&lt;/em&gt;&lt;/a&gt;. Tres días depués de haber creado la petición en GitHub alguien envío un &lt;em&gt;pull request&lt;/em&gt; pero no ha sido hasta después de casi seis meses que finalmente se ha aceptado, fusionado y publicado en la versión 5.1.0.&lt;/p&gt;

&lt;p&gt;La firma del método del &lt;em&gt;resolver&lt;/em&gt; para recuperar los comentarios de un libro sin usar &lt;em&gt;batching&lt;/em&gt; y usando &lt;em&gt;batching&lt;/em&gt; son los siguientes respectivamente. Estos al igual que cualquier otro método del &lt;em&gt;resolver&lt;/em&gt; puede recibir parámetros con los que implementar la funcionalidad que se desee, en este caso para limitar el número de resultados devueltos y para devolverlos a partir de uno  dado.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/fa91df2d0203a0e2137c461ff387719f.js?file=BookResolver.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con la lista completa de libros de la que hay que recuperar los comentarios ya sería posible lanzar una única consulta SQL a una base de datos relacional en vez de una por cada libro. El método que emplea &lt;em&gt;batching&lt;/em&gt; ha de estar anotado con la anotación &lt;em&gt;@Batched&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;La consulta de GraphQL a realizar para recuperar los tres primeros comentarios de cada libro y los resultados que devuelve son los siguientes. La consulta parece un tanto compleja porque la propiedad de los comentarios implementa paginación pero básicamente se recupera de cada libro su título y los comentarios.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/fa91df2d0203a0e2137c461ff387719f.js?file=curl.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/fa91df2d0203a0e2137c461ff387719f.js?file=System.out&#34;&gt;&lt;/script&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/GraphQL&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradew run&lt;/code&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/05/depurar-codigo-javascript-con-la-instruccion-debugger/</id>
        <title>Depurar código JavaScript con la instrucción debugger</title>        
        <updated>2018-05-19T12:00:00+02:00</updated>
        <published>2018-05-18T19:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/05/depurar-codigo-javascript-con-la-instruccion-debugger/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/javascript.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;JavaScript&#34; title=&#34;JavaScript&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Los navegadores web utilizan la palabra clave sentencia &lt;em&gt;debugger;&lt;/em&gt; como punto de ruptura para iniciar el depurado de un código JavaScript. En vez de poner el punto de ruptura desde el navegador utilizando la herrmienta de depuración para desarrolladores con esta instrucción se puede poner en el código fuente donde se desee, de esta forma se evita buscar entre los múltiples recursos que haya cargados en la página e ir a la línea en la que se desea iniciar la depuración poniendo un punto de ruptura.&lt;/p&gt;

&lt;p&gt;Suponiendo que se desea poner un punto de ruptura en un código JavaScript hay que editar el archivo JavaScript de código fuente e incluir la sentencia &lt;em&gt;debugger;&lt;/em&gt; como en el siguiente caso. Cuando el navegador ejecute esa sentencia iniciará, tiendo las herramientas de depuración abiertas, el depurador.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f0b4d4eba1b8428724f2d2a63b0a496b.js?file=Debugger.html&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    
  
  
  
  
  
  

  
  
  

  
  
  















&lt;figure&gt;
    
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/05/depurar-codigo-javascript-con-la-instruccion-debugger/images/javascript-debugger_hu846d34e90b5e643f744d4823c28f732f_278539_2560x1440_fit_box_2.png&#34; title=&#34;JavaScript Debugger&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/2018/05/depurar-codigo-javascript-con-la-instruccion-debugger/images/javascript-debugger_hu846d34e90b5e643f744d4823c28f732f_278539_300x200_fit_box_2.png&#34; width=&#34;300&#34; height=&#34;175&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;JavaScript Debugger&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;

&lt;p&gt;Con la herramienta de depuración abierta se pueden poner expresiones de inspección, nuevos puntos de ruptura e ir paso a paso en la ejecución del código JavaScript. Esta sentencia para iniciar la depuración es lo mismo que añadir un punto de ruptura inspeccionando los recursos de JavaScript de la página pero quizá resulta más cómodo.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger&#34;&gt;MDN debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="javascript"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/05/gestion-de-errores-con-either-o-try-en-vez-de-con-codigo-de-error-null-pptional-checked-exception-o-unchecked-exception/</id>
        <title>Gestión de errores con Either o Try en vez de con código de error, null, Optional, checked exception o unchecked exception</title>        
        <updated>2018-05-11T20:00:00+02:00</updated>
        <published>2018-05-11T20:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/05/gestion-de-errores-con-either-o-try-en-vez-de-con-codigo-de-error-null-pptional-checked-exception-o-unchecked-exception/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;A lo largo del tiempo han surgido varias formas de gestionar las excepciones. En C hace muchos años eran con códigos de error, en Java se incorporaron en el lenguaje las excepciones &lt;em&gt;checked&lt;/em&gt; o &lt;em&gt;uncheked&lt;/em&gt; o la nueva clase Optional en Java cada una con sus ventajas y y algunas deficiencias. Más recientemente usando un tipo tal que &lt;em&gt;Either&lt;L,R&gt;&lt;/em&gt; son otra forma para el tratamiento de errores sobre las opciones anteriores.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Una parte importante para el correcto funcionamiento de un programa corresponde a la gestión de errores que pueden producirse en su ejecución. Si se trata de un programa que se comunica vía interfaz de red ha de estar preparado ante la situación que la conexión se pierda o se produzcan errores en la transmisión porque por ejemplo se ha desconectado el cable de red o la WiFi no es estable. Si se trata de un programa que guarda datos en el almacenamiento persistente también pueden producirse errores como que el archivo ya existe, el directorio no existe o el espacio del disco se ha agotado. Los posibles casos de error que pueden producirse en un programa son muchos y variados.&lt;/p&gt;

&lt;p&gt;En épocas más antiguas una forma de gestionar los errores era y sigue siendo con códigos de error donde la función o el código de salida de un programa retorna un 0 si no se ha producido ningún error o un número distinto de cero si se ha producido algún error, con un código de salida diferente por cada error. Dado que no hay obligación de gestionar adecuadamente el código de salida a veces no se hace con el consiguiente posible mal funcionamiento del programa. Otra forma de código de error es retornar un valor &lt;em&gt;null&lt;/em&gt; en un método o función pero que no tratado adecuadamente producirá una excepción de tipo &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/NullPointerException.html&#34;&gt;NullPointerExcetion&lt;/a&gt;. Con la introducción de la clase &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html&#34;&gt;Optional&lt;/a&gt; entre otras &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;novedades de Java 8&lt;/a&gt; los punteros nulos se gestionan más adecuadamente pero en los casos en los que se devuelve un puntero &lt;em&gt;null&lt;/em&gt; no se proporciona información de cuál ha sido la condición de error que se ha producido.&lt;/p&gt;

&lt;p&gt;Para obligar a gestionar adecuadamente las condiciones de error e informar de que posibles condiciones de error se pueden producir se incorporaron en algunos lenguajes las excepciones como en Java. Las excepciones &lt;em&gt;checked&lt;/em&gt;, aquellas que son declaradas y de obligado tratamiento, garantizan que sean tratadas de alguna forma pero algo molestas con las sentencias &lt;em&gt;try-catch-exception&lt;/em&gt;. Las excepciones &lt;em&gt;unchecked&lt;/em&gt;, aquellas que no es necesario declararlas y no de obligado tratamiento, son arriesgadas ya que al igual que los códigos de error no obliga a darles un tratamiento además de que no se declaran que excepciones es posible que sean lanzadas.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/06b00278af3fe06943f6892acedb4b13.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/06b00278af3fe06943f6892acedb4b13.js?file=System.out&#34;&gt;&lt;/script&gt;

&lt;p&gt;En algunos lenguajes con capacidades funcionales se ha propuesto una nueva forma para la gestión de condiciones de error, en Java y con la librería &lt;a href=&#34;https://www.vavr.io/&#34;&gt;Vavr&lt;/a&gt; se proporciona la clase &lt;a href=&#34;http://static.javadoc.io/io.vavr/vavr/0.9.2/io/vavr/control/Either.html&#34;&gt;Either&lt;/a&gt; que es un tipo con la definición de tipo genérico &lt;em&gt;Either&amp;lt;L,R&amp;gt;&lt;/em&gt;. Que un método devuelva &lt;em&gt;Either&lt;BigDecmal, Exception&gt;&lt;/em&gt; indica que puede devolver en el caso del ejemplo un &lt;em&gt;Integer&lt;/em&gt; en el caso correcto o una excepción en el caso de error. Un potencial fallo de esta opción es que no hay obligación de usar un &lt;em&gt;try-catch&lt;/em&gt; pero si se quiere usar el valor devuelto en caso correcto se ha de tener en cuenta el potencial caso de que lo haya es valor derecho. La clase &lt;em&gt;Either&lt;/em&gt; proporciona métodos para tratar adecuadamente en caso de que esté presente el valor izquierdo o el valor derecho.&lt;/p&gt;

&lt;p&gt;La clase &lt;em&gt;Either&lt;/em&gt; tiene múltiples métodos para comprobar si el valor que tiene es un valor del tipo izquierdo, derecho, obtener el valor izquierdo, derecho y múltiples métodos que hereda de &lt;a href=&#34;http://static.javadoc.io/io.vavr/vavr/0.9.2/io/vavr/Value.html&#34;&gt;Value&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;En vez de retornar un &lt;em&gt;Either&lt;/em&gt; en un método usando Vavr se puede utilizar la clase &lt;a href=&#34;https://static.javadoc.io/io.vavr/vavr/0.9.2/io/vavr/control/Try.html&#34;&gt;Try&lt;/a&gt; como otra forma de gestionar las excepciones. Con &lt;em&gt;Try&lt;/em&gt; el método no es necesario que devuelva un &lt;em&gt;Either&lt;/em&gt; de modo que retorne el valor en el caso correcto y lance una exepción en caso de error. El &lt;em&gt;Try&lt;/em&gt; puede convertirse a un &lt;em&gt;Either&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaException&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/10/las-excepciones-del-lenguaje-java/&#34;&gt;Las excepciones del lenguaje Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ashtonkemerling.com/blog/2017/01/26/java-without-if/&#34;&gt;Java Without If&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.vavr.io/vavr-docs/#_either&#34;&gt;Either Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/05/plantillas-con-etiquetas-no-balanceadas-en-apache-tapestry/</id>
        <title>Plantillas con etiquetas no balanceadas en Apache Tapestry</title>        
        <updated>2018-05-01T10:30:00+02:00</updated>
        <published>2018-05-01T10:30:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/05/plantillas-con-etiquetas-no-balanceadas-en-apache-tapestry/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Apache Tapestry es uno de los mejores &lt;em&gt;frameworks&lt;/em&gt; web para Java que he usado, sin embargo, también tiene algún incordio o curiosidad. Una de ellas es que las plantillas han de ser XML bien formado y en este caso que comento en el que necesitaríamos una plantilla con etiquetas desbalanceadas nos obliga a buscar una solución, esta es la que uso.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/apache-tapestry-5.svg&#34; class=&#34;right &#34; width=&#34;400&#34; alt=&#34;Apache Tapestry&#34; title=&#34;Apache Tapestry&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Las plantillas en &lt;a href=&#34;https://tapestry.apache.org/&#34;&gt;Apache Tapestry&lt;/a&gt; son XHTML, esto quere decir que al ser &lt;a href=&#34;http://es.wikipedia.org/wiki/Validaci%C3%B3n_XML#Documento_Bien_Formado&#34;&gt;archivos xml han de estar bien formados&lt;/a&gt; con sus etiquetas bien balanceadas y anidadas. Esto tiene la ventaja de que Tapestry nos avisará cuando se intente generar código HTML mal formado con el contenido de plantilla, una especie de compilación que si no es correcta no pasará desapercibida como en otros &lt;em&gt;frameworks&lt;/em&gt; y que puede generar otro tipo de errores. Sin embargo, también tiene una desventaja y es que si necesitamos generar una etiqueta de inicio dentro de un componente &lt;em&gt;if&lt;/em&gt; la plantilla no será válida.&lt;/p&gt;

&lt;p&gt;Supongamos que queremos generar un contenido a tres columnas de una serie de elementos, en cada tercer elemento de la fila tendremos que cerrar la fila anterior y abrir una nueva. El ejemplo de lo que no se puede hacer es el siguiente:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/72a843db91d1bc57442ed771f835adf0.js?file=template-1.tml&#34;&gt;&lt;/script&gt;

&lt;p&gt;En este ejemplo las etiquetas &lt;em&gt;div&lt;/em&gt; de apertura y cierre hacen que el XML de la plantilla no esté bien balanceado. No se si habrá otra forma mejor pero esta es el rodeo que uso para tener una plantilla bien balanceada y generar el contenido HTML necesario. En el código Java del componente creo un método que devuelve un mapa de trozos de HTML que no podría incluir en la propia plantilla, cada trozo de HTML tiene una clave asociada por la que identificarlo, en este caso &lt;em&gt;open&lt;/em&gt; y &lt;em&gt;close&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/72a843db91d1bc57442ed771f835adf0.js?file=Component.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Usando estos métodos en la plantilla el código de la plantilla &lt;em&gt;tml&lt;/em&gt; ya bien formado quedaría de la siguiente manera, usando el componente &lt;a href=&#34;http://tapestry.apache.org/current/apidocs/org/apache/tapestry5/corelib/components/OutputRaw.html&#34;&gt;OutputRaw&lt;/a&gt; se emite el trozo HTML de apertura o cierre:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/72a843db91d1bc57442ed771f835adf0.js?file=template-2.tml&#34;&gt;&lt;/script&gt;

&lt;p&gt;Esta pequeña «ñapa» que no es muy habitual en las plantillas pero que en algún caso puede ser necesario emplear es una forma de hacer las plantillas &lt;em&gt;tml&lt;/em&gt; bien formadas en circunstancias donde incluyéndolo en la plantilla no lo sería.&lt;/p&gt;

&lt;p&gt;Prefiero que Tapestry me valide que el XML de la plantilla esté bien formado evitando que se pudiera generar HTML con etiquetas no balanceadas y me obligue a hacer este rodeo que la posibilidad de generar HTML con etiquetas mal balanceadas que los navegadores aceptan pero que en algún caso podría provocar una desmaquetación, aunque en los casos que se aplique esta solución hay que tener especial cuidado ya que como no se realiza ninguna validación al emitir etiquetas de forma «cruda» el HTML generado podría estar mal balanceado.&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2014/12/portada-PugInTapestry-thumb.png&#34; alt=&#34;Portada libro: PlugIn Tapestry&#34; title=&#34;Portada libro: PlugIn Tapestry&#34; style=&#34;float: left; margin-right: 1.5em;&#34;&gt;
    &lt;h3&gt;Libro PlugIn Tapestry&lt;/h3&gt;
    &lt;p&gt;Si te interesa Apache Tapestry descarga gratis el libro de más de 300 páginas que he escrito sobre este &lt;i&gt;framework&lt;/i&gt; en el formato que prefieras, &lt;a href=&#34;http://picodotdev.github.io/blog-bitix/2014/02/libro-sobre-desarrollo-de-aplicaciones-con-apache-tapestry/&#34;&gt;PlugIn Tapestry: Desarrollo de aplicaciones y páginas web con Apache Tapestry&lt;/a&gt;, y el código de ejemplo asociado. En el libro comento detalladamente muchos aspectos que son necesarios en una aplicación web como persistencia, pruebas unitarias y de integración, inicio rápido, seguridad, formularios, internacionalización (i18n) y localización (l10n), AJAX, ... y como abordarlos usando Apache Tapestry.&lt;/p&gt;
    &lt;br style=&#34;clear: both;&#34;&gt;
    &lt;div class=&#34;buttons&#34;&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/custom/PlugInTapestry.pdf&#34; class=&#34;btn btn-lg btn-success&#34;&gt;PDF&lt;/a&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/custom/PlugInTapestry.epub&#34; class=&#34;btn btn-lg btn-success&#34;&gt;EPUB&lt;/a&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/custom/PlugInTapestry.mobi&#34; class=&#34;btn btn-lg btn-success&#34;&gt;MOBI&lt;/a&gt;
        &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/custom/PlugInTapestry.zip&#34; class=&#34;btn btn-lg btn-success&#34;&gt;HTML&lt;/a&gt;
    &lt;/div&gt;
    &lt;div class=&#34;buttons&#34;&gt;
        &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/PlugInTapestry&#34; class=&#34;btn btn-lg btn-success&#34;&gt;Código fuente ejemplos&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
                <category term="tapestry"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/04/la-clase-optional-de-java-para-evitar-la-excepcion-nullpointerexception/</id>
        <title>La clase Optional de Java para evitar la excepción NullPointerException</title>        
        <updated>2018-04-28T00:00:00+02:00</updated>
        <published>2018-04-28T00:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/04/la-clase-optional-de-java-para-evitar-la-excepcion-nullpointerexception/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Con la clase &lt;em&gt;Optional&lt;/em&gt; añadida en el JDK en la versión 8 del lenguaje Java se puede evitar una de las excepciones más comunes que se produce cuando se hace uso de una referencia nula a un objeto.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Una de las excepciones que más se producen en un programa hecho con el lenguaje Java es la conocida &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/NullPointerException.html&#34;&gt;NullPointerExpcetion&lt;/a&gt; que ocurre cuando se hace uso de una variable que referencia a un objeto pero que el contenido de la variable es &lt;em&gt;null&lt;/em&gt;, sin valor o sin contener una referencia a un objeto de modo que la llamada al método no es posible. La excepción &lt;em&gt;NullPointerException&lt;/em&gt; extiende de &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/RuntimeException.html&#34;&gt;RuntimeException&lt;/a&gt; por lo que es una &lt;em&gt;unchecked exception&lt;/em&gt; y por ello no es necesario capturarla o lanzarla, cuando se produce hay un error en el programa.&lt;/p&gt;

&lt;p&gt;Entre las &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;novedades que Java 8 incluyó en el lenguaje y JDK&lt;/a&gt; está la inclusión de la clase &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html&#34;&gt;Optional&lt;/a&gt; con la que haciendo uso de ella se pueden evitar los &lt;em&gt;NullPointerException&lt;/em&gt;. Un objeto de tipo &lt;em&gt;Optional&lt;/em&gt; contiene o no una referencia a otro tipo de objeto. Por ejemplo, una variable de tipo &lt;em&gt;Optional&amp;lt;String&amp;gt;&lt;/em&gt; contiene una referencia a un objeto &lt;em&gt;Optional&lt;/em&gt; que a su vez contiene o no una referencia a una cadena &lt;em&gt;String&lt;/em&gt;. El uso de la variable &lt;em&gt;Optional&lt;/em&gt; no producirá un &lt;em&gt;NullPointerException&lt;/em&gt; y con sus métodos es posible saber si contiene o no una referencia al tipo usado en el genérico. Con el método &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html#isPresent()&#34;&gt;isPresent()&lt;/a&gt; es posible saber si el &lt;em&gt;Optional&lt;/em&gt; contiene una referencia, con &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html#orElse(T)&#34;&gt;orElse()&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html#orElseGet(java.util.function.Supplier)&#34;&gt;orElseGet()&lt;/a&gt; se obtiene la referencia que indiquemos en caso de que no tenga una referencia y con los métodos estáticos a modo de constructores &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html#of(T)&#34;&gt;of()&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html#ofNullable(T)&#34;&gt;ofNullable()&lt;/a&gt; se obtiene respectivamente una instancia de &lt;em&gt;Optional&lt;/em&gt; con la referencia indicada que no puede ser nula o un &lt;em&gt;Optional&lt;/em&gt; que podría contener una referencia nula.&lt;/p&gt;

&lt;p&gt;Usar un objeto &lt;em&gt;Optional&lt;/em&gt; advierte al programador de que la referencia que contiene puede ser nula y usada correctamente evita los &lt;em&gt;NullPointerException&lt;/em&gt; aunque usarla indiscriminadamente hace del código más incómodo de escribir y leer, en variables locales es prescindible su uso pero útil en algunos valores de retorno o parámetros de métodos.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9552591792afa8d6d44d11d25a380f6d.js?file=jshell.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Hay algunos métodos más en la clase &lt;em&gt;Optional&lt;/em&gt; con algunas funcionalidades adicionales que hace uso de las nuevas capacidades funcionales del lenguaje como convertir un &lt;em&gt;Optional&lt;/em&gt; a un &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/stream/Stream.html&#34;&gt;Stream&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/10/las-excepciones-del-lenguaje-java/&#34;&gt;Las excepciones del lenguaje Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/one-dollar-solution-to-avoid-null-pointer-exceptio&#34;&gt;The $1 Solution to Avoid the Null Pointer Exception&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/04/la-sentencia-try-with-resources-de-java/</id>
        <title>La sentencia try-with-resources de Java</title>        
        <updated>2018-04-21T14:30:00+02:00</updated>
        <published>2018-04-21T14:30:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/04/la-sentencia-try-with-resources-de-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Una de las novedades que incorporó Java 7 es la sentencia &lt;em&gt;try-with-resources&lt;/em&gt; con el objetivo de cerrar los recursos de forma automática en la sentencia &lt;em&gt;try-catch-finally&lt;/em&gt; y hacer más simple el código. Aquellas varaibles cuyas clases implementan la interfaz &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/AutoCloseable.html&#34;&gt;AutoCloseable&lt;/a&gt; pueden declararse en el bloque de inicialización de la sentencia &lt;em&gt;try-with-resources&lt;/em&gt; y sus métodos &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/AutoCloseable.html#close()&#34;&gt;close()&lt;/a&gt; serán llamados después del bloque &lt;em&gt;finally&lt;/em&gt; como si su código estuviese de forma explícita.&lt;/p&gt;

&lt;p&gt;Un ejemplo de código que lee una línea de un fichero usando la sentencia &lt;em&gt;try-with-resources&lt;/em&gt; es la siguiente de Java 7. Como se observa no es necesario llamar de forma explícita al método &lt;em&gt;close&lt;/em&gt; para liberar los recursos de la instancia de la clase &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/io/BufferedReader.html&#34;&gt;BufferedReader&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9779dde2d563dcf7e8bb114f44966003.js?file=Java7.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Anteriormente a Java 7 esto se debía hacer de la siguiente manera con unas pocas lineas más de código algo menos legibles.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9779dde2d563dcf7e8bb114f44966003.js?file=Java6.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;El código es similar pero no es equivalente. Observesé que require declarar la variable &lt;em&gt;br&lt;/em&gt; fuera del ámbito de la sentencia &lt;em&gt;try-catch-finally&lt;/em&gt; donde se usa. Además, si se produce una excepción en el bloque &lt;em&gt;try&lt;/em&gt; y posteriormente en el bloque &lt;em&gt;finally&lt;/em&gt; en Java 6 la excepción del bloque &lt;em&gt;try&lt;/em&gt; se enmascara y la que se lanza es la del bloque &lt;em&gt;finally&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;La excepción que se lanza en el bloque &lt;em&gt;try&lt;/em&gt; y usando el método &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&#34;&gt;Throwable.addSuppressed()&lt;/a&gt; que se añadió en la API en Java 7 junto con el método &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/Throwable.html#getSuppressed()&#34;&gt;Throwable.getSuppressed()&lt;/a&gt; se obtienen las excepciones enmascaradas o suprimidas en la sentencia &lt;em&gt;try-with-resources&lt;/em&gt;. El orden de ejecución de los bloques de una sentencia &lt;em&gt;try-with-resources&lt;/em&gt; es el indicado en los números emitidos con el método &lt;em&gt;println&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9779dde2d563dcf7e8bb114f44966003.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/9779dde2d563dcf7e8bb114f44966003.js?file=System.out&#34;&gt;&lt;/script&gt;

&lt;p&gt;La mayoría de clases relacionadas con entrada y salida implementan la interfaz &lt;em&gt;AutoCloseable&lt;/em&gt; como las relacionadas con el sistema de ficheros y flujos de red como &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/io/InputStream.html&#34;&gt;InputStream&lt;/a&gt;, también las relacionadas con la conexión de base de datos mediante JDBC con &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/sql/Connection.html&#34;&gt;Connection&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html&#34;&gt;The try-with-resources Statement&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-exception-handling/try-with-resources.html&#34;&gt;Try-with-resources in Java 7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/a/27033358&#34;&gt;What is a suppressed exception?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/04/la-controversia-sobre-las-excepciones-checked-y-unchecked/</id>
        <title>La controversia sobre las excepciones checked y unchecked</title>        
        <updated>2018-04-20T17:00:00+02:00</updated>
        <published>2018-04-20T17:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/04/la-controversia-sobre-las-excepciones-checked-y-unchecked/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Las excepciones son una forma de gestionar las condiciones de error que se dan en los programas. En el lenguaje C se utiliza el valor de retorno de la función para determinar la condición de error que se ha producido, el problema es que comprobar el valor de retorno puede ignorarse y la gestión de errores está mezclada con la tarea del programa.&lt;/p&gt;

&lt;p&gt;El lenguaje Java utiliza un &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/10/las-excepciones-del-lenguaje-java/&#34;&gt;mecanismo de excepciones&lt;/a&gt;, las excepciones son objetos que se lanzan cuando se produce una condición de error. Todas las excepciones en Java heredan de &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/Throwable.html&#34;&gt;Throwable&lt;/a&gt; subdividiéndose en &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/Error.html&#34;&gt;Error&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/Exception.html&#34;&gt;Exception&lt;/a&gt;, las primeras son condiciones de error del sistema y las segundas condiciones de error del programa. A su vez las &lt;em&gt;Exception&lt;/em&gt; pueden ser &lt;em&gt;checked&lt;/em&gt; si heredan de esta y son aquellas que el compilador fuerza a que sean capturadas no pudiendo ignorarse, han de capturarse en una construcción &lt;em&gt;try catch&lt;/em&gt; o declarar que el método puede lanzar la excepción no capturada. Las excepciones &lt;em&gt;uncheked&lt;/em&gt; heredan de &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/RuntimeException.html&#34;&gt;RuntimeException&lt;/a&gt; que heredan a su vez de &lt;em&gt;Exception&lt;/em&gt; pero tienen la particularidad de que no es necesario capturarlas ni declararlas como que se pueden lanzar debido a que se consideran condiciones de error en la programación como un acceso a un &lt;em&gt;array&lt;/em&gt; fuera de rango que produce un &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/ArrayIndexOutOfBoundsException.html&#34;&gt;ArrayIndexOutOfBounds&lt;/a&gt;, el conocido &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/NullPointerException.html&#34;&gt;NullPointerException&lt;/a&gt; cuando se utiliza una referencia nula, otro es &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/ArithmeticException.html&#34;&gt;ArithmeticException&lt;/a&gt; que se produce al dividir por 0.&lt;/p&gt;

&lt;p&gt;Algunas ventajas de las excepciones son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Separar el código que gestiona los errores del código con el caso principal del programa.&lt;/li&gt;
&lt;li&gt;Propagar errores hacia arriba en la pila de llamadas.&lt;/li&gt;
&lt;li&gt;Agrupar y diferenciar entre diferentes tipos de errores.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hay una cierta polémica sobre si las excepciones &lt;em&gt;checked&lt;/em&gt; son una buena idea. Entre los motivos que se alegan en contra de su uso están que cambiar la firma de un método añadiendo una nueva excepción como lanzable hace que el código que usase ese método podría ocasionar errores de compilación y que hace necesario el tratarla o declararla en la cadena de métodos hasta que sea tratada. Otro motivo es que a mayor nivel en la jerarquía de llamada en los métodos se necesitarán manejar una lista amplia de excepciones.&lt;/p&gt;

&lt;p&gt;En el lado contrario las excepciones se consideran que son buenas porque conocer las condiciones de error o excepción que puede lanzar el método forma parte del contrato del método y es necesario para realizar un correcto manejo de errores. Las excepciones &lt;em&gt;checked&lt;/em&gt; pueden parecer un incordio pero son necesarias para hacer un correcto manejo de errores y evitar que el programa falle por no tratar las condiciones de error de las que advertirían. Por otro lado no deberían silenciarse con un bloque &lt;em&gt;catch&lt;/em&gt; vacío sin una buena razón. En las excepciones &lt;em&gt;checked&lt;/em&gt; el compilador es capaz de advertir si alguna excepción no ha sido capturada o lanzada.&lt;/p&gt;

&lt;p&gt;Como regla general las excepciones &lt;em&gt;checked&lt;/em&gt; se usan cuando el programa es capaz de recuperarse del error y tratarlo adecuadamente, las &lt;em&gt;uncheked&lt;/em&gt; cuando se trata de un error de programación o no se puede hacer nada para recuperarse.&lt;/p&gt;

&lt;p&gt;En el siguiente código se observa como capturar, lanzar y declarar excepciones en las firmas de los métodos en Java en una construcción &lt;em&gt;try catch finally&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c0fc9936712783e76b22088e5b8f2b2e.js?file=Bank.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/c0fc9936712783e76b22088e5b8f2b2e.js?file=Main.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;En el aparatado referncia incluyo unos buenos enlaces que amplian y detallan más apropiadamente la controversia sobre las excepciones &lt;em&gt;checked&lt;/em&gt; y &lt;em&gt;unchecked&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html&#34;&gt;Exceptions tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html&#34;&gt;Unchecked Exceptions — The Controversy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&#34;&gt;Advantages of Exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/124143/why-are-exceptions-not-checked-in-net#126122&#34;&gt;Why are Exceptions not Checked in .NET?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.artima.com/intv/handcuffs.html&#34;&gt;The Trouble with Checked Exceptions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/04/introduccion-a-nio-2-el-sistema-de-entrada-salida-de-java/</id>
        <title>Introducción a NIO.2, el sistema de entrada/salida de Java</title>        
        <updated>2018-04-07T14:00:00+02:00</updated>
        <published>2018-04-07T10:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/04/introduccion-a-nio-2-el-sistema-de-entrada-salida-de-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Una de las tareas más importante que realizan algunas aplicaciones es el manejo de la entrada y salida ya sea al sistema de ficheros o a la red. Desde las versiones iniciales de Java se ha mejorado soporte añadiendo programación asíncrona de E/S, permitir obtener información de atributos propios del sistema de archivos, reconocimiento de enlaces simbólicos y facilitado de algunas operaciones básicas.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En las primeras versiones de Java el sistema de entrada/salida proporcionado en el paquete &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/io/package-summary.html&#34;&gt;&lt;em&gt;java.io&lt;/em&gt;&lt;/a&gt; era básico. En la versión 1.4 de Java se añadió un nuevo sistema de entrada/salida llamado NIO para suplir algunas de sus deficiencias que posteriormente en Java 7 se mejoró aún más con NIO.2. Entre las mejoras se incluyen permitir navegación de directorios sencillo, soporte para reconocer enlaces simbólicos, leer atributos de ficheros como permisos e información como última fecha de modificación, soporte de entrada/salida asíncrona y soporte para operaciones básicas sobre ficheros como copiar y mover ficheros.&lt;/p&gt;

&lt;p&gt;Las clases principales de esta nueva API para el manejo de rutas, ficheros y operaciones de entrada/salida son las siguientes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Path.html&#34;&gt;Path&lt;/a&gt;: es una abstracción sobre una ruta de un sistema de ficheros. No tiene porque existir en el sistema de ficheros pero si si cuando se hacen algunas operaciones como la lectura del fichero que representa. Puede usarse como reemplazo completo de &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/io/File.html&#34;&gt;java.io.File&lt;/a&gt; pero si fuera necesario con los métodos &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/io/File.html#toPath()&#34;&gt;File.toPath()&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Path.html#toFile()&#34;&gt;Path.toFile()&lt;/a&gt; se ofrece compatibilidad entre ambas representaciones.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html&#34;&gt;Files&lt;/a&gt;: es una clase de utilidad con operaciones básicas sobre ficheros.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/FileSystems.html&#34;&gt;FileSystems&lt;/a&gt;: otra clase de utilidad como punto de entrada para obtener referencias a sistemas de archivos.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Con la clase &lt;em&gt;Path&lt;/em&gt; se pueden hacer operaciones sobre rutas como obtener la ruta absoluta de un &lt;em&gt;Path&lt;/em&gt; relativo o el &lt;em&gt;Path&lt;/em&gt; relativo de una ruta absoluta, de cuanto elementos se compone la ruta, obtener el &lt;em&gt;Path&lt;/em&gt; padre o una parte de una ruta. Otros métodos interesantes son &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Path.html#relativize(java.nio.file.Path)&#34;&gt;relativize()&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Path.html#normalize()&#34;&gt;normalize()&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Path.html#toAbsolutePath()&#34;&gt;toAbsolutePath()&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Path.html#resolve(java.nio.file.Path)&#34;&gt;resolve()&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Path.html#startsWith(java.nio.file.Path)&#34;&gt;startsWith()&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Path.html#endsWith(java.nio.file.Path)&#34;&gt;endsWith()&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/3bb11076a051490963a68625b9c1b388.js?file=Main-1.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/3bb11076a051490963a68625b9c1b388.js?file=info.out&#34;&gt;&lt;/script&gt;

&lt;p&gt;Utilizando estas clases expondré algunos ejemplos siendo el primero recorrer el listado de archivos o también se podría hacer el listado de forma recursiva de un directorio e imprimir la información de cada archivo como nombre, si es un enlace simbólico, permisos propietario, fecha de última modificación y tamaño utilizando los siguiente métodos similar a lo que hace el comando &lt;em&gt;ls&lt;/em&gt; de GNU/Linux:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#walkFileTree(java.nio.file.Path,java.nio.file.FileVisitor)&#34;&gt;Files.walkFileTree()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#isSymbolicLink(java.nio.file.Path)&#34;&gt;Files.isSymbolicLink()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#readAttributes(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)&#34;&gt;Files.readAttributes()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/attribute/PosixFilePermissions.html&#34;&gt;PosixFilePermissions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/FileVisitor.html&#34;&gt;FileVisitor&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/SimpleFileVisitor.html&#34;&gt;SimpleFileVisitor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Al igual que es posible leer los permisos también es posible establecerlos con el método &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#setPosixFilePermissions(java.nio.file.Path,java.util.Set)&#34;&gt;Files.setPosixFilePermissions()&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/3bb11076a051490963a68625b9c1b388.js?file=Main-2.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/3bb11076a051490963a68625b9c1b388.js?file=ls.out&#34;&gt;&lt;/script&gt;

&lt;p&gt;Las operaciones de crear directorios o archivos, copiar archivos, moverlos y eliminarlos son muy comunes de modo que la clase &lt;em&gt;Files&lt;/em&gt; ofrece varios métodos que con una única línea permite hacer estas operaciones de forma sencilla. El siguiente ejemplo crea un archivo, lo copia, lo mueve y finalmente lo elimina.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/3bb11076a051490963a68625b9c1b388.js?file=Main-3.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para leer el contenido de archivos la clase &lt;em&gt;Files&lt;/em&gt; ofrece los métodos &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#newBufferedReader(java.nio.file.Path)&#34;&gt;newBufferedReader()&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#newBufferedWriter(java.nio.file.Path,java.nio.charset.Charset,java.nio.file.OpenOption...)&#34;&gt;newBufferedWrite()&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#newInputStream(java.nio.file.Path,java.nio.file.OpenOption...)&#34;&gt;newInputStream()&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#newOutputStream(java.nio.file.Path,java.nio.file.OpenOption...)&#34;&gt;newOutputStream()&lt;/a&gt; junto con otros como &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#readAllLines(java.nio.file.Path,java.nio.charset.Charset)&#34;&gt;readAllLines()&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#readAllBytes(java.nio.file.Path)&#34;&gt;readAllBytes()&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/3bb11076a051490963a68625b9c1b388.js?file=Main-4.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;En cuanto a la programación de entrada/salida asíncrona se ofrecen dos paradigmas uno basado en la clase &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/Future.html&#34;&gt;Future&lt;/a&gt; y otro en funciones de rellamada o &lt;em&gt;callbacks&lt;/em&gt;. La programación asíncrona evita bloquear el hilo que ejecuta el código y aprovecha mejor los procesadores multinúcleo con lo que se mejora el rendimiento de las aplicaciones. Para los ficheros se usa la clase &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/channels/AsynchronousFileChannel.html&#34;&gt;AsynchronousFileChannel&lt;/a&gt; y para flujos de red &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/channels/AsynchronousSocketChannel.html&#34;&gt;AsynchronousSocketChannel&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/3bb11076a051490963a68625b9c1b388.js?file=Main-5.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/3bb11076a051490963a68625b9c1b388.js?file=Main-6.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Si se desea profundizar más en NIO y NIO.2 el libro &lt;a href=&#34;https://amzn.to/2JsEIao&#34;&gt;The Well-Grounded Java Developer&lt;/a&gt; dedica un capítulo introductorio en el que me he basado para realizar este artículo, el libro &lt;a href=&#34;https://amzn.to/2q7qMdN&#34;&gt;Java I/O, NIO and NIO.2&lt;/a&gt; está completamente dedicado al nuevo sistema de entrada/salida de Java y el tutorial &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/io/index.html&#34;&gt;Java Basic I/O&lt;/a&gt; también está muy bien como introducción.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1617290068&amp;linkId=61507308185711a0af4b5ed5ab70b62b&#34;&gt;&lt;/iframe&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1484215664&amp;linkId=d748ea086bd02aa68dd0b27945514558&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;En el artículo &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/09/monitorizar-archivos-con-java/&#34;&gt;monitorizar archivos con Java&lt;/a&gt; muestro como recibir eventos cuando se añade, elimina o modifica algún archivo de los observados usando la clase &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/nio/file/WatchService.html&#34;&gt;WatchService&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaNIO&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javamagazine.mozaicreader.com/JulyAug2016/Twitter#&amp;amp;pageSet=0&amp;amp;page=0&amp;amp;contentItem=0&#34;&gt;Artículo NIO.2, Java Magazine Jul/Ago 2016&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/03/que-es-y-como-funciona-el-type-erasure-en-java/</id>
        <title>Qué es y cómo funciona el type erasure en Java</title>        
        <updated>2018-03-31T10:30:00+02:00</updated>
        <published>2018-03-31T10:30:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/03/que-es-y-como-funciona-el-type-erasure-en-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Los tipos genéricos en Java se implementaron usando &lt;em&gt;type erasure&lt;/em&gt; por simplicidad en la implementación, no incurrir en penalizaciones de rendimiento o memoria y por mantener la compatibilidad con versiones anteriores de Java. Son varios los conceptos que están asociados a la implementación de los tipos genéricos en Java que es recomendable conocer como &lt;em&gt;type erasure&lt;/em&gt;  y métodos &lt;em&gt;bridge&lt;/em&gt; de este artículo pero también &lt;em&gt;heap pollution&lt;/em&gt;, &lt;em&gt;non-reifiable&lt;/em&gt;, &lt;em&gt;wildcards&lt;/em&gt; y &lt;em&gt;bound type parameters&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En la introducción de los &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/04/tutorial-sobre-los-tipos-genericos-de-java/&#34;&gt;tipos genéricos en Java&lt;/a&gt; con la versión 1.5 se decidió implementarlo usando &lt;em&gt;type erasuse&lt;/em&gt; que consiste en que en tiempo de ejecución se pierde la información de los tipos genéricos y para la máquina virtual no son distintos de un tipo no genérico, es un proceso que realiza el compilador. Esto tiene sus ventajas y algunas desventajas pero hay dos buenos motivos por los que en Java se decidió implementar los tipos genéricos usando &lt;em&gt;type erasuse&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Un motivo es que los tipos al ser en tiempo de ejecución exactamente iguales que los no genéricos de versiones anteriores se mantiene la compatibilidad hacia atrás tanto a nivel de código como a nivel binario lo que significa en un caso que el código fuente no es necesario que sea modificado y en otro que no es necesario recompilarlo y esto es importante para usar nuevas versiones de Java sin ningún tipo de modificación y para que programas antiguos sigan funcionando. El segundo motivo es que el mismo tipo sirve para todas las posibles instancias del tipo genérico, de forma que es eficiente y no se incurre en ninguna penalización de rendimiento o memoria.&lt;/p&gt;

&lt;p&gt;La desventaja del &lt;em&gt;type erasure&lt;/em&gt; es que en tiempo de ejecución no se pueden hacer algunas optimizaciones, en computación y uso de memoria. Sin embargo, evaluando las ventajas y desventajas los desarrolladores de Java siempre han dado gran importancia en la compatibilidad hacia atrás y por ello prefirieron implementar los &lt;em&gt;generics&lt;/em&gt; usando &lt;em&gt;type erasure&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El proceso de eliminar los tipos de los genéricos se realiza eliminando todos los parámetros de los tipos parametrizados siendo reemplazados con su restricción (&lt;em&gt;bound&lt;/em&gt;), con el tipo &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html&#34;&gt;Object&lt;/a&gt; o con con su restricción, si tiene múltiples restricciones se usa la primera.&lt;/p&gt;

&lt;p&gt;En Java dos métodos distintos no pueden tener la misma firma, dado que los &lt;em&gt;generics&lt;/em&gt; han sido implementados con &lt;em&gt;type erasure&lt;/em&gt; también se ha de cumplir que dos métodos no pueden tener la misma firma una vez aplicado el &lt;em&gt;erasure&lt;/em&gt;. Para no perder las validaciones de tipos el compilador inserta los &lt;em&gt;cast&lt;/em&gt; necesarios. El código fuente de una clase genérica sería el siguiente, que el compilador transformaría siguiendo las reglas del &lt;em&gt;type erasure&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/fe9adde28f19c10787720a7db6a4a840.js?file=Generic.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/fe9adde28f19c10787720a7db6a4a840.js?file=Erased.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Al mismo tiempo que el compilador inserta los &lt;em&gt;cast&lt;/em&gt; necesarios para mantener la validación de tipos inserta métodos &lt;em&gt;bridge&lt;/em&gt; para mantener el polimorfismo en las clases que extienden de tipos genéricos. Si se extiende la clase &lt;em&gt;Node&lt;/em&gt; anterior y se aplica &lt;em&gt;type erasure&lt;/em&gt; la firma del método &lt;em&gt;setData&lt;/em&gt; de &lt;em&gt;IntegerNode&lt;/em&gt; no coincide con el de la clase &lt;em&gt;Node&lt;/em&gt;. Para solventar este problema el compilador inserta un método &lt;em&gt;bridge&lt;/em&gt; para el método &lt;em&gt;setData&lt;/em&gt; con un parámetro &lt;em&gt;Object&lt;/em&gt; que se encarga de hacer de puente y llamar al método &lt;em&gt;setData&lt;/em&gt; que recibe un &lt;em&gt;Integer&lt;/em&gt; aplicando un &lt;em&gt;cast&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/erasure.html&#34;&gt;Type Erasure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/05/que-es-el-concepto-de-heap-pollution-en-java/&#34;&gt;Qué es el concepto de Heap Pollution en Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quora.com/What-are-the-pros-and-cons-of-having-Generics-as-erasure-or-reifiable?share=1&#34;&gt;What are the pros and cons of having Generics as erasure or reifiable?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/03/la-herramienta-jlink-para-generar-runtimes-de-java-incluyendo-exclusivamente-los-modulos-que-usa-una-aplicacion/</id>
        <title>La herramienta jlink para generar runtimes de Java incluyendo exclusivamente los módulos que usa una aplicación</title>        
        <updated>2018-03-24T23:30:00+01:00</updated>
        <published>2018-03-24T23:30:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/03/la-herramienta-jlink-para-generar-runtimes-de-java-incluyendo-exclusivamente-los-modulos-que-usa-una-aplicacion/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En versiones anteriores de Java 9 había un único &lt;em&gt;runtime&lt;/em&gt; para ejecutar cualquier aplicación que debía ser instalado previamente para la ejecución de la aplicación. Aunque la aplicación no usase &lt;em&gt;Swing&lt;/em&gt; por ser una aplicación web o cosas como &lt;a href=&#34;https://es.wikipedia.org/wiki/CORBA&#34;&gt;CORBA&lt;/a&gt; ya en desuso aún estaban disponibles en el &lt;em&gt;runtime&lt;/em&gt; por motivos de no romper la compatibilidad con versiones anteriores.&lt;/p&gt;

&lt;p&gt;Esto hacía que las aplicaciones no fuesen lo más eficiente posible y aumenta el tamaño necesario ahora de las imágenes de contenedores como &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; estas tuviesen un tamaño mayor del imprescindible, además de hacer que el tiempo de arranque sea algo mayor e incluir clases que aumentan la superficie de ataque ante un fallo de seguridad. Entre las &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;novedades de Java 8&lt;/a&gt; se añadieron los &lt;a href=&#34;http://www.oracle.com/technetwork/java/embedded/resources/tech/compact-profiles-overview-2157132.html&#34;&gt;&lt;em&gt;compact profiles&lt;/em&gt;&lt;/a&gt; que eran subconjuntos más reducidos del &lt;em&gt;runtime&lt;/em&gt; pero eran conjuntos prefijados, las aplicaciones debían usar el mínimo que necesitasen si querían usar alguno. La solución de Java 8 fue una solución intermedia, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/09/novedades-y-nuevas-caracteristicas-de-java-9-los-modulos/&#34;&gt;los módulos de Java 9&lt;/a&gt; han sido la solución completa.&lt;/p&gt;

&lt;p&gt;Con la incorporación de la modularidad a Java 9 se posibilita generar &lt;em&gt;runtimes&lt;/em&gt; con exclusivamente los módulos que necesite la aplicación, si la aplicación solo necesita el módulo &lt;em&gt;java.base&lt;/em&gt; por ser muy sencilla se puede generar un &lt;em&gt;runtime&lt;/em&gt; con solo este módulo. Los módulos son una mejora conveniente para la tendencia en el desarrollo de aplicaciones en forma de microservicios y ejecución con contenedores. La herramienta que posibilita generar &lt;em&gt;runtimes&lt;/em&gt; personalizados con &lt;a href=&#34;https://docs.oracle.com/javase/9/tools/jlink.htm&#34;&gt;jlink&lt;/a&gt; que pueden ser ejecutandos sin instalar previamente ningún JDK en el sistema y posibilitando que cada aplicación pueda usar su propio &lt;em&gt;runtime&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Usando como ejemplo el caso de la &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/10/ejemplo-con-el-cliente-http-2-de-java/&#34;&gt;aplicación con el cliente de HTTP/2&lt;/a&gt; que tiene como dependencias únicamente el módulo &lt;em&gt;jdk.incubator.httpclient&lt;/em&gt; de forma explícita y &lt;em&gt;java.base&lt;/em&gt; de forma implícita en su definición de módulo la forma de generar un runtime específico para esta aplicación con &lt;em&gt;jlink&lt;/em&gt; es la siguiente que utiliza el archivo con las dependencias de módulos declarados en el archivo &lt;em&gt;module-info.java&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/2e113967c3823da21308e8f2a9adbd4f.js?file=module-info.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Usando la linea de comandos o con una tarea de &lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt; se genera el &lt;em&gt;runtime&lt;/em&gt; para la aplicación con &lt;em&gt;jlink&lt;/em&gt;. El módulo ha de compilarse previamente. Con la opción &lt;em&gt;&amp;ndash;launcher&lt;/em&gt; se crea un &lt;em&gt;script&lt;/em&gt; para lanzar la aplicación con la clase que contiene el método &lt;em&gt;main&lt;/em&gt; indicada como punto de entrada, la opción &lt;em&gt;&amp;ndash;output&lt;/em&gt; indica donde se genera el contenido del &lt;em&gt;runtime&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/2e113967c3823da21308e8f2a9adbd4f.js?file=jlink.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;El espacio total del &lt;em&gt;runtime&lt;/em&gt; en este caso de es de solo 38 MiB. Comparados con los casi 200 MiB que ocupa el &lt;a href=&#34;http://openjdk.java.net/&#34;&gt;OpenJDK&lt;/a&gt; comprimido que incluye todos los módulos, aproximadamente 500 MiB instalado y alrededor de entre 600 y 900 MiB dependiendo de la imagen base de Docker que se use se aprecia que el ahorro de espacio es considerable lo que redunda en tiempos de transferencia por red menores y un inicio más rápido de las aplicaciones.&lt;/p&gt;

&lt;p&gt;El contenido del &lt;em&gt;runtime&lt;/em&gt; y de su estructura de directorios es la indicada a continuación. Listando los módulos incluidos en este &lt;em&gt;runtime&lt;/em&gt; en vez de todos los del JDK se observa que solo están incluidos los necesarios por la aplicación.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/2e113967c3823da21308e8f2a9adbd4f.js?file=info.sh&#34;&gt;&lt;/script&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/2e113967c3823da21308e8f2a9adbd4f.js?file=build.gradle&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una vez generado el &lt;em&gt;runtime&lt;/em&gt; su uso es el siguiente:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/2e113967c3823da21308e8f2a9adbd4f.js?file=run.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;En el vídeo &lt;a href=&#34;https://www.oracle.com/java/java9-screencasts.html?bcid=5582437011001&amp;amp;playerType=single-social&amp;amp;size=events&#34;&gt;Java in a World of Containers&lt;/a&gt; se comenta otra serie de características y opciones incluidas en Java para hacer de esta plataforma más consciente de las condiciones de ejecución propias de los contenedores.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaHttp2&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradew jlink&lt;/code&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/03/novedades-de-java-10/</id>
        <title>Novedades de Java 10</title>        
        <updated>2018-03-27T17:00:00+01:00</updated>
        <published>2018-03-23T20:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/03/novedades-de-java-10/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Oracle y los ingenieros a cargo del desarrollo de Java están haciendo en mi opinión un buen trabajo que se han materializado en las versiones Java 8 con las &lt;em&gt;lambdas&lt;/em&gt;, en Java 9 con los módulos y en Java 10 con la mejora en la inferencia de tipos. Todo ello está haciendo que la plataforma evolucione más rápido y significativamente que lo que hasta hace unos años estábamos acostumbrados.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;El 20 de marzo de 2018 se publicó la que es la versión 10 de Java siguiendo el nuevo calendario de publicar una nueva versión cada seis meses, Java 9 fue publicado en septiembre del año anterior. Con este nuevo calendario no pasarán tantos años entre cada nueva versión que era la queja de algunos desarrolladores y el motivo de que la plataforma Java no evolucionar tan rápidamente como algunos desarrolladores desean, quizá ahora la queja sea al contrario que se publican demasiadas versiones y no da tiempo a asimilar los cambios. Para dar cabida a ambas necesidades y garantizar un soporte prolongado cada año y medio será declarada una versión como de soporte a plazo largo o &lt;em&gt;LTS&lt;/em&gt; para que las empresas tengan seguridad en las aplicaciones que desarrollen.&lt;/p&gt;

&lt;p&gt;Lo mejor de este nuevo calendario de publicaciones cada seis meses es que las empresas y programadores tienen predictibilidad de cuándo se lanzará la siguiente versión aunque las nuevas características que tenga no está predeterminado ya no pasarán varios años entre versiones visibilizando que la plataforma evoluciona continuamente en pequeños saltos cada poco tiempo en vez de saltos grandes cada mucho tiempo que son más disruptivos y hace más difícil la adopción.&lt;/p&gt;

&lt;p&gt;Es un principio no añadir características según lo que está de moda sino pensando en décadas futuras. Java 10 tiene una lista más reducida de cambios que Java 9 pero importantes y significativos. Java es el último en unirse a la fiesta de la inferencia de tipos pero ha sido de forma intencionada ya que el coste de implementarla de forma incorrecta supone un alto coste que hay que mantener en adelante. Otras ideas que ha sido implementadas el lenguajes de programación funcional y están listas para su uso masivo tomarán su propio camino en futuras versiones de Java por ejemplo &lt;em&gt;pattern matching&lt;/em&gt; y &lt;em&gt;value types&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;La lista más relevante de novedades de Java 10 es la siguiente:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;286: &lt;a href=&#34;http://openjdk.java.net/jeps/286&#34;&gt;Local-Variable Type Inference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;296: &lt;a href=&#34;http://openjdk.java.net/jeps/296&#34;&gt;Consolidate the JDK Forest into a Single Repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;304: &lt;a href=&#34;http://openjdk.java.net/jeps/304&#34;&gt;Garbage-Collector Interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;307: &lt;a href=&#34;http://openjdk.java.net/jeps/307&#34;&gt;Parallel Full GC for G1&lt;/a&gt;, se ha mejorado el recolector de basura G1 añadiendo soporte para paralelismo y mejorado las pausas en los peores escenarios.&lt;/li&gt;
&lt;li&gt;310: &lt;a href=&#34;http://openjdk.java.net/jeps/310&#34;&gt;Application Class-Data Sharing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;312: &lt;a href=&#34;http://openjdk.java.net/jeps/312&#34;&gt;Thread-Local Handshakes&lt;/a&gt;, mejora interna en la sincronización y pausas en los &lt;em&gt;threads&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;313: &lt;a href=&#34;http://openjdk.java.net/jeps/313&#34;&gt;Remove the Native-Header Generation Tool (javah)&lt;/a&gt;, se elimina la funcionalidad de &lt;em&gt;javah&lt;/em&gt; al haber sido sustituida y mejorada por funcionalidad añadida en &lt;em&gt;javac&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;314: &lt;a href=&#34;http://openjdk.java.net/jeps/314&#34;&gt;Additional Unicode Language-Tag Extensions&lt;/a&gt;, se añade alguna nueva extensión de Unicode.&lt;/li&gt;
&lt;li&gt;316: &lt;a href=&#34;http://openjdk.java.net/jeps/316&#34;&gt;Heap Allocation on Alternative Memory Devices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;317: &lt;a href=&#34;http://openjdk.java.net/jeps/317&#34;&gt;Experimental Java-Based JIT Compiler&lt;/a&gt;, se añade en forma experimental el compilador JIT Graal implementado en Java en la plataforma Linux.&lt;/li&gt;
&lt;li&gt;319: &lt;a href=&#34;http://openjdk.java.net/jeps/319&#34;&gt;Root Certificates&lt;/a&gt;, se han añadido varios certificados raíz al &lt;em&gt;keystore&lt;/em&gt; incluído para permitir que las conexiones TLS funcionen por defecto.&lt;/li&gt;
&lt;li&gt;322: &lt;a href=&#34;http://openjdk.java.net/jeps/322&#34;&gt;Time-Based Release Versioning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;inferencia-de-tipos-para-variables-locales&#34;&gt;Inferencia de tipos para variables locales&lt;/h3&gt;

&lt;p&gt;De las novedades la inferencia de tipos para variables locales es la más destacada en cuanto a cambios en el lenguaje con la adición de la nueva palabra reservada &lt;em&gt;var&lt;/em&gt;, esto ayuda a no tener que repetir varias veces los tipos en la construcción de un objeto. En las &lt;em&gt;lambdas&lt;/em&gt; los parámetros no es necesario declararlos infiriéndose de la interfaz que implementan. La inferencia de tipos es la idea que permite al compilador obtener el tipo estático sin que sea necesario escribirlo de forma explícita.&lt;/p&gt;

&lt;p&gt;Java no es el único o primer lenguaje en incluir la inferencia de tipos para variables. Ha sido usado en otros lenguajes durante décadas. En realidad la inferencia de tipos incluida en Java 10 con &lt;em&gt;var&lt;/em&gt; es muy limitada y restringida de manera intencionada. Si no fuese así el &lt;a href=&#34;https://en.wikipedia.org/wiki/Hindley-Milner_type_system&#34;&gt;algoritmo Hindley-Milner&lt;/a&gt; usado para la inferencia de tipos usado en la mayoría de lenguajes que toma un tiempo exponencial en el peor de los casos potencialmente disminuiría la velocidad de &lt;em&gt;javac&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;La inferencia de tipos para variables locales hace que el código no sea tan verboso sin perder en gran medida la legibilidad ya que solo es para las variables locales. El siguiente ejemplo muestra la evolución de la inferencia de tipos desde Java 5 pasando por Java 8 donde se incluyeron algunas mejoras y el que puede utilizarse a partir de Java 10.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/d4ff7ac7eecda8504ee0834593d70929.js?file=JavaTypeInference.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Los tipos en la parte izquierda pueden parecer redundantes y obvios. Tradicionalmente la filosofía de Java es declarar de forma estática los tipos para todo incluyendo las expresiones más simples. Ciertamente definir los tipos para propiedades y en las firmas de los métodos impone un contrato que es necesario respetar y esto ayuda en el mantenimiento asi como a su entendimiento. Sin embargo, declarar los tipos para expresiones intermedias puede parecer menos útil e incómodo.&lt;/p&gt;

&lt;p&gt;En el artículo &lt;a href=&#34;https://developer.oracle.com/java/jdk-10-local-variable-type-inference&#34;&gt;Java 10 Local Variable Type Inference&lt;/a&gt; y vídeo de Youtube &lt;a href=&#34;https://www.youtube.com/watch?v=Le1DbpRZdRQ&#34;&gt;First contact with &amp;lsquo;var&amp;rsquo; in Java 10&lt;/a&gt; hay una explicación más detallada de esta nueva característica y se aprecia claramente en los siguientes ejemplos que muestran la evolución de la inferencia de tipos.&lt;/p&gt;

&lt;p&gt;No solo hay una mejora de legibilidad aquí, también hay una ventaja en términos de evolución y mantenimiento de código. Si tomamos el mismo código con tipos explícitos para la variable &lt;em&gt;userChannels&lt;/em&gt; y reemplazamos el tipo del canal representado con un &lt;em&gt;String&lt;/em&gt; con un objeto de dominio &lt;em&gt;Channel&lt;/em&gt; que pudiese tener información adicional acerca del canal entonces necesitaríamos reescribir los tipos de todo el código que dependa de este nuevo tipo.&lt;/p&gt;

&lt;p&gt;La inferencia de tipos definitivamente reduce la cantidad de tiempo para escribir código Java pero mejor es la mejora en legibilidad del código. Los desarrolladores dedican mucho más tiempo a leer código fuente que el que dedican a escribirlo de manera que definitivamente hay que optimizar para la facilidad de lectura sobre la facilidad de escritura. Aunque &lt;em&gt;var&lt;/em&gt; no siempre es una mejora en cuanto a legibilidad ya que se pierde la información del tipo su uso se guía por el principio de no tanto para optimizar la escritura o lectura sino generalizando más para la facilidad de mantenimiento, escribir algunos tipos genéricos no triviales es complicado aún con la ayuda de asistencia de un entorno integrado de desarrollo.&lt;/p&gt;

&lt;p&gt;No está permitido en retornos, parámetros, propiedades, variables sin inicializar, ni asignar &lt;em&gt;null&lt;/em&gt; pero en Java 11 el uso de &lt;em&gt;var&lt;/em&gt; se permitirá en los parámetros de una expresión &lt;em&gt;lambda&lt;/em&gt; que será útil porque permite un parámetro formal cuyo tipo es inferido pero que además en el que se pueden usar anotaciones.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/d4ff7ac7eecda8504ee0834593d70929.js?file=JavaLambdaVarAnnotation.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con la inferencia de tipos los nombres de las variables cobran mayor importancia dado que &lt;em&gt;var&lt;/em&gt; elimina la posibilidad al lector del código adivinar la intención de una variable a partir del tipo. Ya es difícil asignar nombres adecuados ahora supondrá mayor importancia.&lt;/p&gt;

&lt;p&gt;El tipo en las variables locales no es tan importante ya que normalmente los nombres de las variables son el del tipo. Con &lt;em&gt;var&lt;/em&gt; se evita repetición entre el tipo y el nombre de la variable, la brevedad de &lt;em&gt;var&lt;/em&gt; hace destacar el nombre de la variable y proporciona mayor claridad además de tener que escribir menos código repetitivo.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/d4ff7ac7eecda8504ee0834593d70929.js?file=NamesAlign.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con &lt;em&gt;var&lt;/em&gt; se evita la longitud variable de los tipos y la no alineación de los nombres de las variables, permite quitar los nombres largos de algunos tipos que son comunes en las aplicaciones empresariales como cosas como &lt;em&gt;DefaultListenerFactory&lt;/em&gt; con vocablos que se van añadiendo uno detras de otro hasta formar un largo nombre.&lt;/p&gt;

&lt;p&gt;Utilizar &lt;em&gt;var&lt;/em&gt; no tiene por que suponer una perdida de legibilidad del código, un buen nombre de variable da más información que el tipo. Por ejemplo, &lt;em&gt;List&amp;lt;User&amp;gt;&lt;/em&gt; parece ser una lista de usuarios, utilizando el nombre de la variable &lt;em&gt;admins&lt;/em&gt; obtendríamos que son una parte más concreta de usuarios en el contexto local en el que se está usando. Por lo que no tener el tipo no es dramático si es suplido con un buen nombre de variable que capture su contenido correctamente.&lt;/p&gt;

&lt;p&gt;La palabra reservada &lt;em&gt;var&lt;/em&gt; no hace de Java un lenguaje dinámico, sigue siendo estático y fuertemente tipado. Solo que ahora los tipos no hace falta declararlos explícitamente y es el compilador el que se encarga de inferirlos según el contexto. En tiempo de ejecución nada cambia, el rendimiento sigue siendo el mismo y solo es una característica en tiempo de compilación.&lt;/p&gt;

&lt;p&gt;La existencia de &lt;em&gt;var&lt;/em&gt; no significa que haya de usarse de forma indiscriminada para todas las variables locales sino juiciosamente. En este caso quizá es preferible declarar el tipo por no ser obvio lo que retorna el método &lt;em&gt;getCities()&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/d4ff7ac7eecda8504ee0834593d70929.js?file=TypeVsVar.java&#34;&gt;&lt;/script&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://openjdk.java.net/projects/amber/LVTIstyle.html&#34;&gt;Style Guidelines for Local Variable Type Inference in Java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los entornos integrados de desarrollo tardarán un tiempo en implementar la inferencia de tipos para variables locales hasta que lancen nuevas versiones.&lt;/p&gt;

&lt;h3 id=&#34;otras-novedades&#34;&gt;Otras novedades&lt;/h3&gt;

&lt;p&gt;El tiempo para iniciar el interprete REPL de &lt;a href=&#34;https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm&#34;&gt;JShell&lt;/a&gt; ha sido reducido significativamente especialmente en casos donde se inicia con un archivo que incluye varios &lt;em&gt;snippets&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se han añadido mejoras en la herramienta de documentación de las clases Javadoc como soporte para varias hojas de estilo, agrupar métodos redefinidos que no cambian la especificación o nueva etiqueta &lt;em&gt;summary&lt;/em&gt; como resumen de la API.&lt;/p&gt;

&lt;p&gt;Se han añadido varios métodos para crear copias no modificables con &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/List.html#copyOf(java.util.Collection)&#34;&gt;List.copyOf()&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/Set.html#copyOf(java.util.Collection)&#34;&gt;Set.copyOf()&lt;/a&gt;, and &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/Map.html#copyOf(java.util.Map)&#34;&gt;Map.copyOf()&lt;/a&gt;. Se han añadido nuevos métodos a la clase &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/stream/Collectors.html&#34;&gt;Collectors&lt;/a&gt; para devolver una lista no modificable con &lt;em&gt;toUnmodifiableList&lt;/em&gt;, &lt;em&gt;toUnmodifiableSet&lt;/em&gt;, and &lt;em&gt;toUnmodifiableMap&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se añade el método &lt;a href=&#34;https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html#orElseThrow()&#34;&gt;Optional.orElseThrow()&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Algunas &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/10-relnote-issues-4108729.html#Removed&#34;&gt;otras características ya obsoletas se han eliminado&lt;/a&gt; y &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/10-relnote-issues-4108729.html#Deprecated&#34;&gt;otras se han marcado como &lt;em&gt;deprecated&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;el-posible-futuro-jdk-11&#34;&gt;El posible futuro JDK 11+&lt;/h3&gt;

&lt;p&gt;Está planificado en seis meses después de Java 10 y con soporte extendido, el soporte de Java 10 durará tan solo hasta 2018.09, el de Java 11 al ser una &lt;em&gt;LTS&lt;/em&gt; durará un periodo de 8 años hasta el 2026.09.&lt;/p&gt;

&lt;p&gt;En el nuevo modelo las nuevas características no se añaden hasta que están preparadas. Tentativamente las &lt;a href=&#34;http://openjdk.java.net/projects/jdk/11/&#34;&gt;características de JDK 11&lt;/a&gt; no están completamente determinadas pero se están evaluando grandes proyectos como &lt;a href=&#34;http://openjdk.java.net/projects/valhalla/&#34;&gt;Valhalla&lt;/a&gt; para hacer más eficiente el tratamiento de datos que no requieran la indentidad de objetos con los denominados &lt;a href=&#34;http://openjdk.java.net/jeps/169&#34;&gt;Value Types&lt;/a&gt; útil para la programación funcional con datos puros optimizados para computaciones en paralelo. El proyecto &lt;a href=&#34;http://openjdk.java.net/projects/loom/&#34;&gt;Loom&lt;/a&gt; que posibilita una versión más ligera aún que los &lt;em&gt;threads&lt;/em&gt; o hilos con &lt;em&gt;fibers&lt;/em&gt; o fibras, &lt;em&gt;continuations&lt;/em&gt; o &lt;em&gt;coroutine&lt;/em&gt; y &lt;a href=&#34;https://en.wikipedia.org/wiki/Tail_call&#34;&gt;Tail Call&lt;/a&gt;. El proyecto &lt;a href=&#34;http://openjdk.java.net/projects/panama/&#34;&gt;Panama&lt;/a&gt; hará más fácil trabajar con código nativo o el proyecto &lt;a href=&#34;http://openjdk.java.net/projects/zgc/&#34;&gt;ZGC&lt;/a&gt; para crear un recolector de basura que pueda manejar gigabytes y terabytes con pausas menores a 10ms. O el proyecto &lt;a href=&#34;http://openjdk.java.net/projects/amber/&#34;&gt;Amber&lt;/a&gt; con unas pequeñas mejoras pero muy cómodas para el programador como la de los literales &lt;em&gt;strings raw&lt;/em&gt;. En la &lt;a href=&#34;http://openjdk.java.net/&#34;&gt;página del OpenJDK&lt;/a&gt; hay más proyectos que en un futuro quizá sean implementados y publicados en alguna versión.&lt;/p&gt;

&lt;p&gt;En la sección final de referencia incluyo varios artículos y vídeos de los que he obtenido la información para hacer este resumen de las novedades de Java 10. Algunos son muy interesantes y amplían en gran medida lo comentado y lo que posiblemente llegue en un futuro.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Le1DbpRZdRQ&#34;&gt;First contact with &amp;lsquo;var&amp;rsquo; in Java 10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/84mCmmzksGI?t=47m43s&#34;&gt;Keynotes: Oracle Code Chicago&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.oracle.com/java/java10&#34;&gt;Introducing Java SE 10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.oracle.com/java/jdk-10-local-variable-type-inference&#34;&gt;Java 10 Local Variable Type Inference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.eclipse.org/content/java-10-support-oxygen&#34;&gt;Java 10 Support for Oxygen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jdk.java.net/10/&#34;&gt;JDK 10 General-Availability Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/10-relnote-issues-4108729.html&#34;&gt;JDK 10 Release Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oracle.com/corporate/pressrelease/Java-10-032018.html&#34;&gt;Oracle Java SE 10 Release Arrives&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoworld.com/article/3230507/java/java-jdk-10-what-new-features-to-expect-in-the-next-java.html&#34;&gt;JDK 10: What’s new in Java 10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.forbes.com/sites/oracle/2018/03/20/what-java-10-and-javas-new-6-month-release-cadence-mean-for-developers/&#34;&gt;What Java 10 And Java&amp;rsquo;s New 6-Month Release Cadence Mean For Developers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html&#34;&gt;Project Loom: Fibers and Continuations for the Java Virtual Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.azul.com/the-incredible-shrinking-java-platform/&#34;&gt;The Incredible Shrinking Java Platform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/java/eol-135779.html&#34;&gt;Oracle Java SE Support Roadmap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.opsian.com/blog/java-on-docker/&#34;&gt;Java on Docker will no longer suck: improvements coming in Java 10&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/03/el-problema-de-concurrencia-del-agente-y-los-fumadores-resuelto-en-java/</id>
        <title>El problema de concurrencia del agente y los fumadores resuelto en Java</title>        
        <updated>2018-03-05T19:00:00+01:00</updated>
        <published>2018-03-05T19:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/03/el-problema-de-concurrencia-del-agente-y-los-fumadores-resuelto-en-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Junto con los ejemplos de &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2018/02/el-problema-de-concurrencia-de-la-cena-de-los-filosofos-resuelto-con-java/&#34;&gt;la cena de los filósofos&lt;/a&gt; y &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/07/iniciacion-a-la-programacion-concurrente-en-java/&#34;&gt;la barbería&lt;/a&gt; el de los fumadores es otro ejemplo clásico que se estudia en las asignaturas de sistemas operativos. Estos ejemplos necesitan de mecanismos de sincronización y concurrencia para su correcto funcionamiento al haber varios procesos y recursos compartidos que los procesos intentan utilizar de forma concurrente pero que no se debe permitir utilizando notificaciones entre procesos o &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/07/iniciacion-a-la-programacion-concurrente-en-java/&#34;&gt;algunas primitivas de sincronización, concurrencia e hilos que posee Java&lt;/a&gt; como &lt;em&gt;mutex&lt;/em&gt;, &lt;em&gt;locks&lt;/em&gt; o semáforos.&lt;/p&gt;

&lt;p&gt;El caso de los fumadores consiste en un grupo de fumadores que para fumar necesitan los ingredientes que les faltan para hacer un cigarrillo y fumárselo, poseen un ingrediente en cantidades ilimitadas pero les faltan otros dos. El agente posee cantidades ilimitadas de todos los ingredientes que son papel, tabaco y cerillas pero solo deja en una mesa dos de estos ingredientes a la vez. Cada fumador posee un ingrediente distinto de los tres necesarios y según los ingredientes que deje el agente uno de los fumadores podrá fumar con los dos ingredientes que el agente deja.&lt;/p&gt;

&lt;p&gt;El agente y los fumadores representan en la realidad a procesos y los ingredientes a los recursos de un sistema. La dificultad radica en sincronizar los agentes y fumadores para que el agente cuando deje ingredientes en la mesa el fumador correcto fume cuando.&lt;/p&gt;

&lt;p&gt;A primera vista podríamos intentar que cada uno de los fumadores tomase cada uno de los ingredientes que le falta y se pusiese a fumar representando un ingrediente como un semáforo, sin embargo, esta solución puede producir un bloqueo si uno de los otros fumadores que no pueden fumar según los ingredientes que ha dejado el agente le quitan al que podría fumar uno de los ingredientes que necesita. Por ejemplo, un caso de bloqueo sería el caso de que el agente deje en la mesa los ingredientes de tabaco y cerillas el fumador que podría fumar sería el 1 pero si el fumador 2 es más rápido y se ejecuta antes tomando el tabaco el fumador 1 se quedaría esperando a tomar tabaco y el fumador 2 también por no haber dejado el agente papel sino cerillas.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/bb2b37bba770d2d09d97d92ff82bfd1a.js?file=SmokersDeadlock.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para la solución hay que optar por otra estrategia, en el ejemplo de código he creado tres clases que representa a cada una de las entidades, una clase &lt;em&gt;Agent&lt;/em&gt;, una clase &lt;em&gt;Smoker&lt;/em&gt; y una clase &lt;em&gt;Table&lt;/em&gt;, adicionalmente una clase &lt;em&gt;Pusher&lt;/em&gt; que se encargará de despertar al &lt;em&gt;Smoker&lt;/em&gt; correcto según los ingredientes de la mesa. Todas las clases implementan la interfaz &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/Runnable.html&#34;&gt;Runnable&lt;/a&gt; para convertir cada una de las instancias en un hilo de ejecución. Cuando un agente deja ingredientes en la mesa se notifica a todos los incitadores  o &lt;em&gt;pushers&lt;/em&gt; para indicarles que hay ingredientes listos, el &lt;em&gt;pusher&lt;/em&gt; adquiere el ingrediente que tiene asignado para tomar y comprueba cual es el único ingrediente que falta en la mesa, si no lo sabe porque falten varios ingredientes indica que en la mesa está su ingrediente y deja el trabajo de despertar al fumador al siguiente &lt;em&gt;pusher&lt;/em&gt;. El &lt;em&gt;pusher&lt;/em&gt; que sepa que dos ingredientes hay en la mesa despierta al fumador que puede fumar con el ingrediente que tiene y los dos que hay en la mesa. El fumador se pone a fumar y cuando termina se indica al agente que genere otros dos ingredientes.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/bb2b37bba770d2d09d97d92ff82bfd1a.js?file=Component.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/bb2b37bba770d2d09d97d92ff82bfd1a.js?file=Table.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/bb2b37bba770d2d09d97d92ff82bfd1a.js?file=Smoker.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/bb2b37bba770d2d09d97d92ff82bfd1a.js?file=Agent.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/bb2b37bba770d2d09d97d92ff82bfd1a.js?file=Pusher.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/bb2b37bba770d2d09d97d92ff82bfd1a.js?file=Main.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/167230.js&#34; id=&#34;asciicast-167230&#34; async&gt;&lt;/script&gt;
        &lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/167230&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/167230.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
        
        &lt;figcaption&gt;Ejemplo de concurrencia del agente y los fumadores&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;En el siguiente &lt;a href=&#34;https://cse.yeditepe.edu.tr/~kserdaroglu/spring2014/cse331/labnotes/WEEK%205%20-%20SEMAPHORES/mysemaphoreexamplesMOE.pdf&#34;&gt;documento con varios de los problemas de concurrencia y sincronización&lt;/a&gt; está muy bien explicado la solución a este problema de los fumadores y de los otros casos. En algunos otros sitios este caso lo convierten en un problema de sincronización en vez de uno de concurrencia.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaConcurrency&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cigarette_smokers_problem&#34;&gt;Cigarette smokers problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/07/iniciacion-a-la-programacion-concurrente-en-java/&#34;&gt;Introducción sobre la programación concurrente en Java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2018/02/el-problema-de-concurrencia-de-la-cena-de-los-filosofos-resuelto-con-java/</id>
        <title>El problema de concurrencia de la cena de los filósofos resuelto con Java</title>        
        <updated>2018-02-25T10:00:00+01:00</updated>
        <published>2018-02-25T10:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2018/02/el-problema-de-concurrencia-de-la-cena-de-los-filosofos-resuelto-con-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right &#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En un &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/07/iniciacion-a-la-programacion-concurrente-en-java/&#34;&gt;artículo de introducción sobre la programación concurrente en Java&lt;/a&gt; explicaba cuales eran la facilidades que proporciona este lenguaje para la programación concurrente en múltiples hilos. En él exponía dos ejemplos clásicos que se estudian en las asignaturas de sistemas operativos, uno de ellos era el de &lt;a href=&#34;https://es.wikipedia.org/wiki/Problema_de_la_cena_de_los_fil%C3%B3sofos&#34;&gt;la cena de los filósofos&lt;/a&gt; donde varios filósofos sentados en una tabla durante una cena se dedican a pensar y cuando tienen hambre comen usando para ello dos tenedores que comparten con sus compañeros que se sientan a la izquierda y derecha.&lt;/p&gt;

&lt;p&gt;Dado que dos filósofos no puede utilizar el mismo tenedor a la vez hay que implementar sincronización a la hora de utilizarlos. En la realidad un filósofo representa a un proceso y un tenedor representa a un recurso compartido de uso exclusivo.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    
&lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2018/302/dining-philosophers.png&#34; title=&#34;La cena de los filósofos&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2018/302/dining-philosophers-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;La cena de los filósofos&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;

&lt;p&gt;La solución del ejemplo que ponía en el artículo anterior no era completamente correcto ya que un filósofo si tiene mala suerte podría quedarse sin  comer o sin comer durante mucho tiempo, debido a que en esa implementación el filósofo intentaba coger los tenedores y si no podía desistía si alguno de sus compañeros los estuviese utilizando. Las reglas que ha de cumplir una solución a un problema de concurrencia para considerarse válida son:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Exclusión mutua: Si un proceso se está ejecutando en su sección crítica ningún otro proceso se puede estar ejecutando en la suya.&lt;/li&gt;
&lt;li&gt;Progreso: Si ningún proceso se está ejecutando en su sección crítica y hay otros procesos que desean entrar en las suyas, entonces solo aquellos procesos que no se está ejecutando en su sección restante pueden participar en la decisión  del cuál será el siguiente en entrar en la sección crítica, y esta selección no puede postergarse indefinidamente.&lt;/li&gt;
&lt;li&gt;Espera limitada: Debe haber un límite en el número de veces que se permite que los demás procesos entren en su sección crítica después de que un proceso haya efectuado una solicitud para entrar en la suya y antes de que se conceda esa solicitud.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;En la implementación de este ejemplo evitaré que un filósofo pueda quedarse sin comer. La razón de que un filósofo desistiera de coger uno de los tenedores que necesita si uno de sus compañeros ya lo tuviese era para evitar un bloqueo circular en el caso de que todos los filósofos al mismo tiempo cogiesen su tenedor izquierdo, en esta situación ninguno de ellos podría coger su tenedor derecho y se quedarían todos esperando indefinidamente, se produciría un bloqueo indefinido o &lt;em&gt;deadlock&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para evitar un bloqueo indefinido una de las siguientes reglas no se ha de cumplir:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Exclusión mutua: Por lo menos un recurso debe retenerse en modo no compartido; es decir, sólo un proceso a la vez puede usar el recurso. Si otro proceso solicita el recurso, deberá esperar hasta que se haya liberado.&lt;/li&gt;
&lt;li&gt;Retención y espera: Debe haber un proceso que retenga por lo menos un recurso y espere adquirir otros recursos retenidos por otros procesos.&lt;/li&gt;
&lt;li&gt;No apropiación: Los recursos no se pueden quitar; es decir, un recurso solo puede ser liberado voluntariamente por el proceso que lo retiene, después de que haya cumplido su tarea.&lt;/li&gt;
&lt;li&gt;Espera circular: Debe haber un conjunto { P0, P1, &amp;hellip;, Pn } de procesos en espera tales que P0 espera un recurso retenido por P1, P1 espera un recurso retenido por P2, &amp;hellip; Pn-1 espera un recurso retenido por On, y Pn espera un recurso retenido por P0.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;En esta implementación he optado por hacer que el último filósofo en vez de ser diestro sea zurdo de modo que primero intente coger el tenedor izquierdo y luego el derecho, con este simple cambio la espera circular ya no puede producirse y con ello el bloqueo indefinido.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/e732e19b68e6f1fd6b0e586dc1a5aaf7.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/e732e19b68e6f1fd6b0e586dc1a5aaf7.js?file=Table.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/e732e19b68e6f1fd6b0e586dc1a5aaf7.js?file=Fork.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/e732e19b68e6f1fd6b0e586dc1a5aaf7.js?file=Philosopher.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/165278.js&#34; id=&#34;asciicast-165278&#34; async&gt;&lt;/script&gt;
        &lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/165278&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/165278.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
        
        &lt;figcaption&gt;Ejemplo de concurrencia de los filósofos&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaConcurrency&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew run&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bruceeckel.github.io/2016/12/29/dining-philosophers-in-java-8/&#34;&gt;Dining Philosophers in Java 8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
</feed>

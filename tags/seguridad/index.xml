<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://picodotdev.github.io/blog-bitix/tags/seguridad/</id>
    <title type="text">Blog Bitix</title>
    <subtitle>Recent content on Blog Bitix</subtitle>
    <updated>2017-06-17T13:00:00+02:00</updated>
    <author><name>pico.dev</name></author>
    <generator>Hugo</generator>
    <icon>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</icon>
    <logo>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</logo>
    <rights>https://creativecommons.org/licenses/by-sa/4.0/</rights>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/06/autenticacion-mutua-de-cliente-y-servidor-con-certificados/</id>
        <title>Autenticación mutua de cliente y servidor con certificados</title>        
        <updated>2017-06-17T13:00:00+02:00</updated>
        <published>2017-06-17T13:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/06/autenticacion-mutua-de-cliente-y-servidor-con-certificados/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/openssl.svg&#34; class=&#34;right&#34; width=&#34;400&#34; alt=&#34;OpenSSL&#34; title=&#34;OpenSSL&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Los certificados no solo sirven para autenticar a un servidor o acceder solo a aquellos en los que confiamos. El servidor también puede autenticar a los clientes mediante un certificado como alternativa a usar un usuario y contraseña ya sea una autenticación &lt;em&gt;BASIC&lt;/em&gt; o un formulario personalizado. Al igual que en el cliente usa el certificado de la autoridad de certificación en la que confía para validar el que presenta el servidor, el servidor puede requerir que el cliente también proporcione un certificado que el servidor valida según las autoridades de certificación en las que confía, en ambos casos el servidor o cliente usan su clave privada para iniciar la conexión segura con el &lt;em&gt;handsake&lt;/em&gt; del &lt;a href=&#34;https://es.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;protocolo TLS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Para el ejemplo usaré un servidor web &lt;a href=&#34;https://nginx.org/&#34;&gt;nginx&lt;/a&gt; ejecutado como un contenedor de &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; configurado de tal manera que requiere autenticación para el cliente con certificados.&lt;/p&gt;

&lt;p&gt;Inicialmente deberemos generar tres parejas de claves privadas y públicas, una para nuestra propia autoridad de certificación, una clave para el servidor y otra para el cliente. Al mismo tiempo generaré otras tres parejas de claves privadas y públicas para comprobar que cuando se proporciona un certificado incorrecto la autenticación falla.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=openssl-genrsa.sh&#34;&gt;&lt;/script&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=ca.crt&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=ca.key&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=ca.pub&#34;&gt;&lt;/script&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=openssl-genrsa-unknown.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;El siguiente paso es generar los certificados y firmar con la clave y certificado de la autoridad de certificado los certificados del servidor y cliente. Como paso previo a que la autoridad de certificación emita los certificados del servidor y cliente hay que generar una petición de firma de certificado, los archivos &lt;em&gt;.csr&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=openssl-req.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=openssl-req-unknown.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con la misma herramienta de &lt;a href=&#34;https://www.openssl.org/&#34;&gt;OpenSSL&lt;/a&gt; es posible comprobar si un certificado es válido para una autoridad de certificación en la que se confía, para ello se usa el certificado raiz de la autoridad.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=openssl-verify.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=openssl-verify-unknown.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para hacer que el servidor nginx requiera autenticación mediante certificados para el cliente hay que añadir un poco de configuración mediante las directivas &lt;em&gt;ssl&lt;/em&gt; donde se indica el certificado del servidor, la clave privada del servidor, el certificado de la autoridad de certificación contra la que se validarán los certificados de los clientes y finalmente la directiva que establece que se ha de verificar a los clientes mediante certificados.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=nginx.conf&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con el siguiente archivo descriptor de &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker Compose&lt;/a&gt; y comando se inicia el servidor web nginx.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=docker-compose.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=docker-compose.yml&#34;&gt;&lt;/script&gt;

&lt;p&gt;Iniciado el servidor web ya se pueden realizar peticiones y el servidor y el cliente se autenticarán mutuamente. El servidor devolverá el código HTML de la página de bienvenida por defecto con las cabeceras del protocolo HTTP después de realizar el &lt;em&gt;handsake&lt;/em&gt; donde se valida el certificado del servidor.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=curl.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Si se intenta realizar una petición sin certificado de cliente o con un certificado de cliente en el que no confié el servidor (que no esté firmado por la autoridad de certificación en la que confía) se devolverá un código de estado 400 que indica que la petición se ha rechazado. También el cliente advertirá si la autoridad de certificación en la que confía no valida el certificado del servidor con un error 400 y título &lt;em&gt;400 The SSL certificate error&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=curl-unknown.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;El siguiente &lt;em&gt;script&lt;/em&gt; escrito en lenguaje &lt;a href=&#34;http://www.groovy-lang.org/&#34;&gt;Groovy&lt;/a&gt; muestra como desde un programa para la plataforma Java se realiza autenticación mutua y que error da cuando alguno de los certificados es inválido ya sea el del cliente o el del servidor. Generando previamente los &lt;em&gt;keystores&lt;/em&gt; de la autoridad de certificado y del cliente introduciendo como clave en el ejemplo &lt;em&gt;password&lt;/em&gt; cuando se solicita.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=keytool.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=MutualCertAuth.groovy&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=groovy.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;En caso de que al usar un &lt;em&gt;keytore&lt;/em&gt; con un certificado de una autoridad que no valida el certificado del servidor se producirán un error, también cuando el certificado del cliente no sea válido para el servidor.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/16c98598bc1a2e63509f9c70960419b3.js?file=groovy-unknown.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/docker/&#34;&gt;Serie de artículos sobre Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/04/guardar-contrasenas-usando-salted-password-hashing-y-otras-formas-correctas/&#34;&gt;Guardar contraseñas usando «Salted Password Hashing» y otras formas correctas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
                <category term="seguridad"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2016/06/como-redirigir-peticiones-de-http-a-https-en-nginx-apache-tomcat-jetty-y-wildfly/</id>
        <title>Cómo redirigir peticiones de HTTP a HTTPS en Nginx, Apache, Tomcat, Jetty y WildFly</title>        
        <updated>2016-06-18T13:00:00+02:00</updated>
        <published>2016-06-18T13:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/06/como-redirigir-peticiones-de-http-a-https-en-nginx-apache-tomcat-jetty-y-wildfly/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Usar el protocolo seguro HTTPS proporciona confidencialidad en la comunicación entre el navegador del usuario y el servidor, es una forma de mejorar la seguridad y privacidad. Por ello el buscador de Google lo tiene en cuenta como un parámetro que afecta al SEO siendo mejor usar el protocolo seguro. Sin embargo, el usuario puede estar accediendo por el protocolo no seguro a la página web al poner la dirección en la barra de direcciones o hay enlaces hacia nuestro sitio en otros que hacen uso del protocolo HTTP. Si queremos que nuestro sitio sea accedido únicamente usando el protocolo seguro deberemos hacer una redirección en el servidor.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/nginx.png&#34; class=&#34;right&#34; alt=&#34;Nginx&#34; title=&#34;Nginx&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/apache-httpd.png&#34; class=&#34;right&#34; alt=&#34;Apache HTTPD&#34; title=&#34;Apache HTTPD&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Si tenemos una aplicación o una bitácora que hasta el momento era accedido por el protocolo no cifrado &lt;abbr title=&#34;Hypertext Transfer Protocol&#34;&gt;HTTP&lt;/abbr&gt; ahora que Google tiene en cuenta para el &lt;abbr title=&#34;Search engine optimization&#34;&gt;SEO&lt;/abbr&gt; que usar el protocolo seguro es un parámetro que tiene en cuenta el algoritmo de posicionamiento en el buscador quizá queramos redirigir todo el tráfico de HTTP al protocolo cifrado &lt;abbr title=&#34;Hypertext Transfer Protocol Secure&#34;&gt;HTTPS&lt;/abbr&gt;.&lt;/p&gt;

&lt;p&gt;Para usar HTTPS deberemos primero &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/configurar-ssl-en-un-servidor-tomcat-jboss-wildfly-lighttpd-nginx-apache/&#34;&gt;configurar el protocolo TLS/SSL en el servidor web o de aplicaciones&lt;/a&gt; usando un certificado SSL que podemos obtener ahora con &lt;a href=&#34;https://letsencrypt.org/&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt; de forma gratuita  o &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/generar-y-convertir-claves-y-certificados-con-openssl/&#34;&gt;generar un certificado&lt;/a&gt; nosotros y que sea firmado por una autoridad de confianza. Una vez que el servidor es capaz de servir el tráfico por el protocolo HTTPS estamos en condiciones de realizar la redirección al protocolo cifrado HTTPS en el puerto 443 cuando sea accedido por el protocolo no cifrado HTTP en el puerto 80.&lt;/p&gt;

&lt;p&gt;Dependiendo del servidor web o de aplicaciones que usemos la configuración será distinta, incluso lo podemos hacer a nivel de aplicación con la ayuda del &lt;em&gt;framework&lt;/em&gt; web si este ofrece algún soporte para ello. A continuación incluiré la configuración necesaria para los servidores web y de aplicaciones más populares como son &lt;a href=&#34;https://nginx.org/&#34;&gt;Nginx&lt;/a&gt;, &lt;a href=&#34;https://httpd.apache.org/&#34;&gt;Apache HTTPD&lt;/a&gt;, &lt;a href=&#34;http://tomcat.apache.org/&#34;&gt;Tomcat&lt;/a&gt;, &lt;a href=&#34;http://eclipse.org/jetty/&#34;&gt;Jetty&lt;/a&gt; y &lt;a href=&#34;http://wildfly.org/&#34;&gt;WildFly&lt;/a&gt; y finalmente el caso haciendo la redirección a nivel de aplicación con el &lt;em&gt;framework&lt;/em&gt; &lt;a href=&#34;http://tapestry.apache.org&#34;&gt;Apache Tapestry&lt;/a&gt; para desarrollar aplicaciones web con el lenguaje Java.&lt;/p&gt;

&lt;h3 id=&#34;nginx&#34;&gt;Nginx&lt;/h3&gt;

&lt;p&gt;Usando &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; nos resultará más sencillo hacer la prueba que teniendo que instalar el paquete de Nginx en nuestra distribución. Puedes consultar &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/docker/&#34;&gt;varios artículos sobre Docker&lt;/a&gt; que he escrito a modo introducción y para empezar a usarlo.&lt;/p&gt;

&lt;p&gt;En la sección del servidor que escucha en el puerto HTTP (80) realizamos la redirección permanente con el código de estado 301 hacia el protocolo HTTPS. En la sección del servidor que escucha en el pueto HTTPS (443) accitva el uso de TLS/SSL usando varias directivas y sirve los documentos de &lt;em&gt;/usr/share/nginx/html&lt;/em&gt; en la ruta &lt;em&gt;/&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/505856d7e0a9574541c303d09fd63be1.js?file=nginx.conf&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/505856d7e0a9574541c303d09fd63be1.js?file=docker-nginx.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/151/nginx-https.png&#34; title=&#34;Redirección de HTTP a HTTPS en Nginx&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/151/nginx-https-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Redirección de HTTP a HTTPS en Nginx&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;apache-httpd&#34;&gt;Apache HTTPD&lt;/h3&gt;

&lt;p&gt;La configuración para Apache HTTPD es similar simplemente cambian las directivas según su propia configuración. Se activan los módulos para usar TLS/SSL y el que permite hacer reescrituras de las URL.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/505856d7e0a9574541c303d09fd63be1.js?file=httpd.conf&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/505856d7e0a9574541c303d09fd63be1.js?file=docker-httpd.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/151/apache-httpd-https.png&#34; title=&#34;Redirección de HTTP a HTTPS en Apache HTTPD&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/151/apache-httpd-https-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Redirección de HTTP a HTTPS en Apache HTTPD&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;tomcat-jetty-y-wildfly&#34;&gt;Tomcat, Jetty y WildFly&lt;/h3&gt;

&lt;p&gt;Es muy habitual que los servidores de aplicaciones como Tomcat, Jetty o WildFly sean accedidos no directamente por el navegador del usuario sino a través de un servidor web como Nginx o Apache haciendo de &lt;em&gt;proxy&lt;/em&gt;. Cuando hay un servidor web que actúa de &lt;em&gt;proxy&lt;/em&gt; para el servidor de aplicaciones es posible decidir que el establecimiento de la conexión cifrada TLS/SSL del protocolo HTTPS se realice en el servidor web y la comunicación cifrada termine al mismo tiempo en él, la comunicación entre el servidor web y el servidor de aplicaciones se realizaría usando el protocolo HTTP. Esto descarga del servidor de aplicaciones la tarea algo costosa del establecimiento de la conexión cifrada y tener que cifrar el tráfico.&lt;/p&gt;

&lt;p&gt;Para el caso de Tomcat, Jetty y WildFly habiendo configurado la posibilidad de usar el protocolo seguro la configuración para hacer la redirección es la misma para los tres, habría que añadir al archivo descriptor &lt;em&gt;web.xml&lt;/em&gt; de la aplicación el siguiente fragmento XML. Esto hace que el servidor fuerce la conexión segura para los recursos indicados, en este caso todos al usar el patrón &lt;em&gt;/*&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/505856d7e0a9574541c303d09fd63be1.js?file=web.xml&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;redirección-a-nivel-de-aplicación&#34;&gt;Redirección a nivel de aplicación&lt;/h3&gt;

&lt;p&gt;Con algún mecanismo propio que empleemos al programar la aplicación (en Java por ejemplo con un filtro) o el &lt;em&gt;framework&lt;/em&gt; web que usemos para desarrollar la aplicación web quizá nos ofrezca algún mecanismo para redirigir las peticiones al puerto seguro cuando sea accedida por el puerto inseguro, por ejemplo, para que la redirección la haga la aplicación en vez del servidor con el &lt;em&gt;framework&lt;/em&gt; Apache Tapestry basta añadir la siguiente configuración en el módulo de la aplicación.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/505856d7e0a9574541c303d09fd63be1.js?file=AppModule.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/RedirigirHTTPaHTTPS&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./docker-nginx.sh o ./docker-httpd.sh&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.apache.org/httpd/RedirectSSL&#34;&gt;Redirect Request to SSL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://confluence.atlassian.com/stashkb/redirect-http-requests-to-https-333810132.html&#34;&gt;Redirect HTTP Requests to HTTPS (in Tomcat)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.eclipse.org/jetty/documentation/current/configuring-ssl.html&#34;&gt;Configuring SSL/TLS (in Jetty)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="seguridad"/>
            
                <category term="software"/>
            
                <category term="software-libre"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2016/03/como-firmar-correos-electronicos-con-gpg-y-javamail/</id>
        <title>Cómo firmar correos electrónicos con GPG y JavaMail</title>        
        <updated>2016-03-19T10:00:00+01:00</updated>
        <published>2016-03-19T10:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/03/como-firmar-correos-electronicos-con-gpg-y-javamail/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;El correo electrónico es un medio muy utilizado para realizar ataques de &lt;em&gt;phising&lt;/em&gt;, algunos son muy burdos pero seguramente algunos usuarios sin muchos conocimientos caen víctimas de ellos y aún los usuarios con conocimientos también pueden serlo si están bien realizados y muestran un correo electrónico exactamente igual que el que intentan suplantar. Los usuarios son las víctimas pero si los sitios web que envían los correos electrónicos legítimos los firmasen digitalmente sería una garantía más para proteger a sus usuarios, pudiendo detectar de otra forma el &lt;em&gt;spam&lt;/em&gt; y &lt;em&gt;phising&lt;/em&gt;. En este artículo muestro a modo de ejemplo como firmar un correo electrónico con GPG y JavaMail e igualmente podría utilizarse para cifrarlo, aunque usar DKIM sería lo más apropiado.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.png&#34; class=&#34;right&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/gnupg.png&#34; class=&#34;right&#34; alt=&#34;GnuPG&#34; title=&#34;GnuPG&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Los sitios de comercio electrónico y muchas páginas web utilizan el &lt;a href=&#34;https://es.wikipedia.org/wiki/Hypertext_Transfer_Protocol_Secure&#34;&gt;protocolo seguro HTTPS&lt;/a&gt; para cifrar los datos intercambiados entre cliente y servidor impidiendo a una tercera persona conocer qué información se está transmitiendo, además impide que puedan ser alterados sin su conocimiento. Es habitual usar HTTPS y certificados en las páginas de compra en las que hay que introducir datos personales junto con la tarjeta de crédito también en las cuentas de usuario como forma de proporcionar seguridad y proteger la información personal. Generando y usando &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/configurar-ssl-en-un-servidor-tomcat-jboss-wildfly-lighttpd-nginx-apache/&#34;&gt;certificados TLS/SSL en el servidor&lt;/a&gt; el sitio y el usuario evitan caer en un ataque de &lt;em&gt;phising&lt;/em&gt; en la que una tercera persona con intenciones maliciosas intenta suplantar la identidad del sitio web.&lt;/p&gt;

&lt;p&gt;Pero los &lt;a href=&#34;https://es.wikipedia.org/wiki/Phishing&#34;&gt;ataques de &lt;em&gt;phising&lt;/em&gt;&lt;/a&gt; también son realizados a través del correo electrónico, mensajes en los que se incluyen enlaces hacia páginas que suplantan a un sitio. Algunos usuarios quizá no se den cuenta de la suplantación al hacer clic en los enlaces maliciosos. Los motores de búsqueda mantendrán a los usuarios a salvo de enlaces maliciosos en las páginas de resultados que les lleven a páginas de &lt;em&gt;phising&lt;/em&gt;, pero no del correo electrónico que si no es detectado como &lt;em&gt;spam&lt;/em&gt; llegará a la bandeja de entrada de los usuarios. El correo electrónico es una vía para llevar a los usuarios hacia esas páginas de &lt;em&gt;phising&lt;/em&gt;. Para evitar este posible peligro no todos los sitios web y de comercio electrónico son los que firman sus mensajes como forma de verificar la autenticidad de los mismos así como evitar que pueda ser modificados sin conocimiento.&lt;/p&gt;

&lt;p&gt;Con &lt;a href=&#34;https://www.gnupg.org/&#34;&gt;GPG&lt;/a&gt; y &lt;a href=&#34;https://en.wikipedia.org/wiki/JavaMail&#34;&gt;JavaMail&lt;/a&gt; podemos firmar los mensajes electrónicos que enviemos desde una aplicación Java. La firma de un correo electrónico consiste baśicamente en firmar el contenido del mensaje y adjuntar la firma como un documento adjunto con un &lt;em&gt;mimetype&lt;/em&gt; de &lt;em&gt;application/pgp-signature&lt;/em&gt;. Lo primero que deberemos hacer es &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/generar-y-convertir-claves-y-certificados-con-openssl/&#34;&gt;generar un par de claves de cifrado asimétrico usando GPG&lt;/a&gt;. Si los mensajes los vamos a enviar usando un cuenta de &lt;a href=&#34;https://mail.google.com/&#34;&gt;gmail&lt;/a&gt; y tenemos activada la verificación en dos pasos debemos genera una contraseña de aplicación desde &lt;a href=&#34;https://myaccount.google.com/&#34;&gt;Mi cuenta de Google&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Además de cómo firmar un correo electrónico el siguiente ejemplo muestra &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/03/como-ejecutar-un-proceso-del-sistema-con-java/&#34;&gt;cómo ejecutar un proceso del sistema en Java&lt;/a&gt; que nos proporciona acceso a todas las utilidades GNU, scripts de &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt; u otros comandos que tenga instalados, también muestra &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2011/02/enviar-correos-mediante-java-mail.html&#34;&gt;cómo enviar un correo electrónico en un programa Java&lt;/a&gt; que ya comenté pero ahora con un ejemplo ejecutable y enviando un archivo adjunto.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c4ce75423a67e4ee6b38.js?file=Main.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;En este ejemplo solo se firma el contenido del mensaje quedando fuera de la firma el asunto, fecha, otros adjuntos y destinatarios del mensaje pero podría utilizarse lo mismo para firmar estos otros datos. Enviado el correo electrónico podemos verificar la firma con el siguiente comando de GPG.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c4ce75423a67e4ee6b38.js?file=gpg-verify.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/c4ce75423a67e4ee6b38.js?file=email.txt&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/c4ce75423a67e4ee6b38.js?file=signature.asc.txt&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/c4ce75423a67e4ee6b38.js?file=email-original.txt&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/133/gpg-verify.png&#34; title=&#34;Verificación de la firma GPG del correo electrónico&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/133/gpg-verify.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Verificación de la firma GPG del correo electrónico&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;En el anillo de claves de GPG la clave que usemos para firmar no ha de tener &lt;em&gt;passphrase&lt;/em&gt; de lo contrario cuando se ejecute el comando GPG la solicitará en una ventana emergente. Aunque con las opciones &lt;code&gt;&amp;ndash;passphrase&lt;/code&gt; y &lt;code&gt;&amp;ndash;batch&lt;/code&gt; no debería solicitarla no he conseguido evitarlo.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaMailGPG&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew --daemon run -Pargs=&amp;#34;[contraseña de aplicación de cuenta gmail]&amp;#34;&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;Las suplantaciones mediante correo electrónico son y seguirán siendo habituales si no son detectadas como &lt;em&gt;spam&lt;/em&gt;. Después de escribir este artículo usar &lt;a href=&#34;https://es.wikipedia.org/wiki/DomainKeys_Identified_Mail&#34;&gt;&lt;abbr title=&#34;DomainKeys Identified Mail&#34;&gt;DKIM&lt;/abbr&gt;&lt;/a&gt; parece ser la forma adecuada de firmar y cifrar los correos electrónicos y viendo el mensaje original de los que envían &lt;a href=&#34;https://www.google.es/&#34;&gt;Google&lt;/a&gt; y &lt;a href=&#34;http://amzn.to/2flFhHA&#34;&gt;Amazon&lt;/a&gt; es lo que utilizan ellos que algo sabrán de esto. Usar DKIM en los correos electrónicos será tema para otro posible artículo, la &lt;a href=&#34;http://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html&#34;&gt;nube de Amazon ofrece soporte para DKIM&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c4ce75423a67e4ee6b38.js?file=email-dkim.txt&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2013/11/introduccion-la-criptografia-e-inicio-con-gpg.html&#34;&gt;Introducción a la criptografía e inicio con GPG &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2011/02/enviar-correos-mediante-java-mail.html&#34;&gt;Enviar correos electrónicos mediante Java Mail &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/generar-y-convertir-claves-y-certificados-con-openssl/&#34;&gt;Generar y convertir claves y certificados con OpenSSL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/configurar-ssl-en-un-servidor-tomcat-jboss-wildfly-lighttpd-nginx-apache/&#34;&gt;Configurar SSL/TLS en un servidor Tomcat, JBoss, WildFly, Lighttpd, Nginx o Apache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html&#34;&gt;Easy DKIM in Amazon SES&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
                <category term="seguridad"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2016/03/como-eliminar-de-forma-segura-archivos-con-wipe-y-dd-en-gnu-linux/</id>
        <title>Cómo eliminar de forma segura archivos con wipe y dd en GNU/Linux</title>        
        <updated>2016-03-05T12:00:00+01:00</updated>
        <published>2016-03-05T12:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/03/como-eliminar-de-forma-segura-archivos-con-wipe-y-dd-en-gnu-linux/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Eliminar archivos del sistema de ficheros no basta para destruir la información que contuvieran. Con herramientas como &lt;em&gt;Foremost&lt;/em&gt; su contenido puede ser recuperado, por ello cuando desechamos una unidad de almacenamiento (disco duro, memoria USB, targeta SD, SSD) conviene hacer un borrado seguro de la unidad, si trabajamos con información sensible quizá queramos hacer un borrado seguro de los archivos que eliminemos. Con el comando &lt;em&gt;wipe&lt;/em&gt; podemos borrar archivos individuales y con el comando &lt;em&gt;dd&lt;/em&gt; una unidad completa.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/gnu.png&#34; class=&#34;right&#34; alt=&#34;GNU&#34; title=&#34;GNU&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/linux.png&#34; class=&#34;right&#34; alt=&#34;Linux&#34; title=&#34;Linux&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Aunque los eliminemos su contenido permanece en el sistema de archivos que con herramientas como &lt;a href=&#34;https://wiki.archlinux.org/index.php/Foremost&#34;&gt;Foremost&lt;/a&gt; pueden recuperarse. Esto es debido a que cuando se elimina un archivo realmente lo que se hace es liberar el espacio ocupado, el contenido mientras no se sobreescriba por el de otro nuevo archivo sigue estando presente en el dispositivo de almacenamiento. Para eliminar de forma segura tal que no sea posible recuperar ni con herramientas como Foremost un archivo del sistema de almacenamiento hay que hacer un borrado seguro del archivo o de la unidad completa, proceso que consiste en sobreescribir la información con datos aleatorios.&lt;/p&gt;

&lt;p&gt;Esto es necesario o recomendable si trabajamos con información sensible como datos personales, contraseñas, claves, &amp;hellip; o si nos deshacemos de la unidad de almacenamiento USB, tarjeta de memoria, disco duro o SSD. En el artículo &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/como-recuperar-archivos-eliminados-o-de-una-unidad-corrupta-en-gnu-linux/&#34;&gt;Cómo recuperar archivos con Foremost&lt;/a&gt; explico cómo recuperar información que podríamos considerar destruida, en mi experiencia aún habiendo eliminado los archivos usando las facilidades del propio entorno de escritorio se puede recuperar el contenido completo de bastantes de los archivos originales sobre todo si la unidad tiene bastante espacio libre y no ha tenido un uso excesivo.&lt;/p&gt;

&lt;p&gt;En GNU/Linux para eliminar archivos de forma segura disponemos del &lt;a href=&#34;http://linux.die.net/man/1/wipe&#34;&gt;comando &lt;em&gt;wipe&lt;/em&gt;&lt;/a&gt; que en &lt;a href=&#34;https://www.archlinux.org/&#34;&gt;Arch Linux&lt;/a&gt; su &lt;a href=&#34;https://www.archlinux.org/packages/extra/x86_64/wipe/&#34;&gt;paquete&lt;/a&gt; se encuentra en el repositorio Extra. Su uso es el siguiente, la opción &lt;em&gt;-r&lt;/em&gt; hace un borrado recursivo de un directorio por lo que hay que usarla con cuidado y la opción &lt;em&gt;-q&lt;/em&gt; hace un borrado rápido sobreescribiendo únicamente 4 veces el contenido del archivo con datos aleatorios, finalmente se indica la ruta del archivo o directorio a eliminar de forma segura. Con otras opciones se puede afinar el comportamiento de borrado.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/82d1ae97b6f784740de5.js?file=wipe.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para destruir la información de forma completa con datos aleatorios de una unidad de almacenamiento podemos usar el &lt;a href=&#34;http://linux.die.net/man/1/dd&#34;&gt;comando &lt;em&gt;dd&lt;/em&gt;&lt;/a&gt;, deberemos sustituir la &lt;em&gt;X&lt;/em&gt; por el identificador adecuado asignado a la unidad que podemos obtener con el comando &lt;em&gt;blkid&lt;/em&gt;:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/82d1ae97b6f784740de5.js?file=dd.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Como se indica en la &lt;a href=&#34;http://manpages.ubuntu.com/manpages/lucid/man1/wipe.1.html&#34;&gt;documentación de &lt;em&gt;wipe&lt;/em&gt;&lt;/a&gt; todavía puede ser posible recuperar archivos por el sistema de registro o &lt;em&gt;journaling&lt;/em&gt; de los sistemas de archivos modernos en los que algunos datos pueden escribirse en el sistema de registro, también se comenta alguna noción más a tener en cuenta en cuanto a la seguridad.&lt;/p&gt;

&lt;p&gt;Hacer una eliminación segura con el comando &lt;em&gt;wipe&lt;/em&gt; o uno similar dificulta la recuperación de información pero no es infalible. Una solución recomendada es &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-unidad-usb-completamente-con-dm-crypt-y-luks-en-gnu-linux/&#34;&gt;cifrar completamente el sistema de archivos&lt;/a&gt;. Aún no cifrando completamente el sistema de archivos podemos &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-archivos-con-encfs-en-gnu-linux/&#34;&gt;usar &lt;em&gt;encfs&lt;/em&gt; para cifrar determinados archivos&lt;/a&gt; para proteger la información.&lt;/p&gt;

&lt;p&gt;Aunque si queremos asegurarnos de que la información sea verdaderamente irrecuperable de una unidad otro buen método es usar un martillo como saben en alguna organización política.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/como-recuperar-archivos-eliminados-o-de-una-unidad-corrupta-en-gnu-linux/&#34;&gt;Cómo recuperar archivos eliminados o de una unidad corrupta en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-archivos-con-encfs-en-gnu-linux/&#34;&gt;Cifrar archivos con EncFS en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-unidad-usb-completamente-con-dm-crypt-y-luks-en-gnu-linux/&#34;&gt;Cifrar unidad USB completamente con dm-crypt y LUKS en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linux.die.net/man/1/wipe&#34;&gt;Comando &lt;em&gt;wipe&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linux.die.net/man/1/dd&#34;&gt;Comando &lt;em&gt;dd&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Securely_wipe_disk&#34;&gt;Securely wipe disk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Disk_encryption&#34;&gt;Disk encryption&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="seguridad"/>
            
                <category term="software-libre"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2016/02/cifrar-unidad-usb-completamente-con-dm-crypt-y-luks-en-gnu-linux/</id>
        <title>Cifrar unidad USB completamente con dm-crypt y LUKS en GNU/Linux</title>        
        <updated>2016-02-26T18:00:00+01:00</updated>
        <published>2016-02-26T18:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/02/cifrar-unidad-usb-completamente-con-dm-crypt-y-luks-en-gnu-linux/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;¿Has perdido alguna vez una memoria USB? ¿sí, aún no? ¿qué datos contenía? Muy posiblemente son varias las memorias USB que tenemos, por su poco tamaño y cada vez mayor capacidad incluso llevaremos alguna en la cartera siempre con nosotros. Si quieres mantener a salvo los datos en caso de pérdida hay varias opciones, una para esta necesidad es cifrar completamente la unidad con dm-crypt junto con LUKS+Ext4 en GNU/Linux. Suena muy técnico pero es muy sencillo usando la aplicación Discos de GNOME y la seguridad de nuestra información aumentará notablemente.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/gnu.png&#34; class=&#34;right&#34; alt=&#34;GNU&#34; title=&#34;GNU&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/linux.png&#34; class=&#34;right&#34; alt=&#34;Linux&#34; title=&#34;Linux&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Seguro que tienes varias memorias USB o discos duros externos con los que transportar información de un sitio a otro o como copia de seguridad. No sería extraño perder alguna de esas unidades en una biblioteca, universidad, aeropuerto, vía pública, metro, &amp;hellip; con toda la información que contengan como fotos y documentos con información personal accesible por cualquier persona que se encuentre esa unidad. Si queremos evitar este posible caso de que al perder la unidad USB que al final es lo de menos ya que se puede sustituir fácilmente toda la información este accesible podemos cifrar su contenido. Hay varias formas una &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2013/11/introduccion-la-criptografia-e-inicio-con-gpg.html&#34;&gt;cifrando con GPG archivos individuales&lt;/a&gt;, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-archivos-con-encfs-en-gnu-linux/&#34;&gt;cifrando con EncFS ciertas carpetas&lt;/a&gt; y varios archivos a la vez o la unidad completa con &lt;a href=&#34;https://wiki.archlinux.org/index.php/Dm-crypt&#34;&gt;dm-crypt&lt;/a&gt; que será el caso de este artículo.&lt;/p&gt;

&lt;p&gt;Usar GPG es incómodo si necesitamos cifrar múltiples archivos como sería el caso de una memoria USB, EncFS requiere introducir un comando para montar el sistema de archivos cifrado y no obligaremos a que todos los archivos estén cifrados, usando dm-crypt el sistema nos preguntará por la clave de cifrado al conectar la unidad USB y se encargará de hacer el cifrado y descifrado de forma automática y transparente, nosotros trabajaremos con los archivos y sus aplicaciones con normalidad sin ninguna necesidad especial. Además, no es complicado inicializar la unidad USB para que su contenido esté cifrado usando la &lt;a href=&#34;https://es.wikipedia.org/wiki/GNOME_Disks&#34;&gt;aplicación Discos de GNOME&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Deberemos formatear la unidad por lo que previamente deberemos hacer una copia de seguridad de su contenido para no perderlo, en teoría desde Nautilus se puede hacer pero en mis pruebas me indicaba un error que usando la aplicación Discos no se produce.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/030be90a417d74e44477.js?file=error.txt&#34;&gt;&lt;/script&gt;

&lt;p&gt;Iniciada la aplicación Discos e identificada y seleccionada la unidad USB que queremos cifrar usando el botón con el icono de una rueda dentada hacemos clic en la opción formatear partición. Se abrirá un diálogo emergente donde podremos seleccionar el sistema de archivos con el que queremos formatear la unidad, seleccionamos LUKS+Ext4, formato lento e introducimos una contraseña con cierta fortaleza que deberemos recordar (de longitud 8 o más que contenga letras en mayúsculas, minúsculas, números y símbolos como «!&amp;ldquo;·$%&amp;amp;/()=^*,.-;:_»). El formateo lento tardará más o menos tiempo dependiendo de la capacidad de la unidad pero es aconsejable realizarlo para evitar que con &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/como-recuperar-archivos-eliminados-o-de-una-unidad-corrupta-en-gnu-linux/&#34;&gt;herramientas de recuperación de archivos como Foremost&lt;/a&gt; alguien pueda extraer algún tipo de documento usándola a pesar de en teoría haber sido eliminado, otra forma de evitarlo es &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/03/como-eliminar-de-forma-segura-archivos-con-wipe-y-dd-en-gnu-linux/&#34;&gt;eliminar ciertos o todos los archivos de forma segura&lt;/a&gt;. En una unidad sin cifrar es sorprendente la cantidad de archivos que se puede recuperar usando &lt;a href=&#34;https://wiki.archlinux.org/index.php/Foremost&#34;&gt;Foremost&lt;/a&gt; de los que en algún momento estuvieron.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/128/discos.png&#34; title=&#34;Aplicación Discos de GNOME&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/128/discos-thumb.png&#34;&gt;&lt;/a&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/128/opciones-formato.png&#34; title=&#34;Opciones formateo unidad&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/128/opciones-formato-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Formateada la unidad con LUKS+Ext4 al conectarla al equipo o montarla el entorno de escritorio nos preguntará por la contraseña con un diálogo.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/128/contrasena.png&#34; title=&#34;Diálogo solicitud contraseña&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/128/contrasena-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/128/unidad-cifrada.png&#34; title=&#34;Unidad cifrada en Nautilus&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/128/unidad-cifrada.png&#34;&gt;&lt;/a&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/128/unidad-descifrada.png&#34; title=&#34;Unidad BMOVE ROJO descifrada en Nautilus&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/128/unidad-descifrada.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Introducida la contraseña veremos los archivos originales y podremos trabajar con ellos con normalidad como si no estuviesen cifrados. En la &lt;a href=&#34;https://wiki.archlinux.org/&#34;&gt;wiki de Arch Linux&lt;/a&gt; hay varios artículos explicando en que consiste dm-crypt y los comandos que deberíamos usar desde la terminal, los artículos en el apartado de referencia del final de este artículo. Cifrar la unidad completamente con cm-crypt y LUKS+Ext4 es perfectamente compatible con usar EncFS, es decir, podemos usar dm-crypt en la unidad y en ella que ya está cifrada &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-archivos-con-encfs-en-gnu-linux/&#34;&gt;almacenar un sistema de archivos también cifrado con EncFS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Son increíbles las opciones que uno va descubriendo del software libre de GNU/Linux y esta es una con la que haremos nuestras unidades USB y los preciados datos que contienen bastante más seguras y a salvo en caso de pérdida o robo. Y esto es solo una muestra, con dm-crypt es posible hacer muchas más cosas que con curiosidad puedes descubrir en la wiki de Arch Linux.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/como-recuperar-archivos-eliminados-o-de-una-unidad-corrupta-en-gnu-linux/&#34;&gt;Cómo recuperar archivos eliminados o de una unidad corrupta en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-archivos-con-encfs-en-gnu-linux/&#34;&gt;Cifrar archivos con EncFS en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/03/como-eliminar-de-forma-segura-archivos-con-wipe-y-dd-en-gnu-linux/&#34;&gt;Cómo eliminar de forma segura archivos con wipe en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_a_non-root_file_system&#34;&gt;Encrypting a non-root file system&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Dm-crypt&#34;&gt;Dm-crypt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/disk_encryption&#34;&gt;Disk encryption&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Dm-crypt/Drive_preparation&#34;&gt;Drive preparation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Dm-crypt/Device_encryption&#34;&gt;Device encryption&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="seguridad"/>
            
                <category term="software-libre"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2016/02/cifrar-archivos-con-encfs-en-gnu-linux/</id>
        <title>Cifrar archivos con EncFS en GNU/Linux</title>        
        <updated>2016-02-22T21:00:00+01:00</updated>
        <published>2016-02-19T20:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/02/cifrar-archivos-con-encfs-en-gnu-linux/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Hacer copias de seguridad es una buena práctica para evitar perder información en caso de que por ejemplo un disco duro se nos estropee. Cifrar la información o al menos parte de ella como las contraseñas (si las guardamos en un archivo de texto) también es una buena práctica por si perdemos una memoria USB, nos roban en un lugar público o en nuestro domicilio un disco duro o un portátil o los extraviamos en algún viaje. Una forma sencilla para proteger su contenido cifrando múltiples archivos es EncFS.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/gnu.png&#34; class=&#34;right&#34; alt=&#34;GNU&#34; title=&#34;GNU&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/linux.png&#34; class=&#34;right&#34; alt=&#34;Linux&#34; title=&#34;Linux&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Nuestros datos es una de las cosas más importantes que podemos perder o nos pueden robar, más que el dispositivo que los contiene ya que este es fácilmente reemplazable no así los datos. La pérdida de datos puede ser porque se nos ha estropeado el disco duro y ha quedado completamente inaccesible, para evitar la pérdida de datos conviene &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2013/05/copia-de-seguridad-con-rsync.html&#34;&gt;realizar copias de seguridad&lt;/a&gt; regularmente de las que recuperar los datos perdidos en caso de necesidad. También nos puede ocurrir que perdamos una memoria USB o peor aún nos roben en nuestro propio domicilio y nos extraigan entre otras cosas el portátil o un disco duro. Los productos de electrónica son objetivos apreciados por los ladrones por su valor, por su demanda que los hacen fácilmente colocables en el mercado y por su poco volumen.&lt;/p&gt;

&lt;p&gt;En GNU/Linux podemos proteger nuestros datos de múltiples formas de una memoria USB, de un portátil o disco duro externo. Una de ellas es &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-unidad-usb-completamente-con-dm-crypt-y-luks-en-gnu-linux/&#34;&gt;cifrando completamente el sistema de archivos&lt;/a&gt; con lo que todos los datos que contuviese estarán protegidos. Otra forma es &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2013/11/introduccion-la-criptografia-e-inicio-con-gpg.html&#34;&gt;cifrar ciertos archivos con información sensible con GPG&lt;/a&gt; como contraseñas, una solución menos invasiva y más compatible con otros sistemas que cifrar completamente el sistema de archivos, no muy complicada pero en la que debemos cifrar cada archivo individualmente. Para evitar cifrar/descifrar cada archivo individualmente y manualmente con GPG podemos usar &lt;a href=&#34;https://wiki.archlinux.org/index.php/EncFS&#34;&gt;EncFS&lt;/a&gt;. EncFS es un sistema de archivos que podemos montar y cifrará el contenido de todos los archivos que incluyamos en él.&lt;/p&gt;

&lt;p&gt;Con EncFS el contenido de los archivos y sus nombres serán cifrados aunque su tamaño, fechas de modificación y estructura de carpetas seguirá siendo visible. Aunque sin sus nombres originales el tamaño, fechas y estructura de carpetas ya es algo indicativo y por tanto para algunas necesidades no es suficiente la seguridad que proporciona.&lt;/p&gt;

&lt;p&gt;Para usar EncFS debemos instalar su paquete, en &lt;a href=&#34;https://www.archlinux.org/&#34;&gt;Arch Linux&lt;/a&gt; con:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/636558857333a1fdb964.js?file=pacman.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Instalado el paquete y con el comando &lt;em&gt;encfs&lt;/em&gt; indicamos el directorio donde se almacenará el sistema de archivos cifrado y el directorio donde EncFS montará el sistema de archivos sin cifrar, la primera vez que lo usemos nos pedirá la contraseña con la que el sistema de archivos se cifrará que deberemos recordar ya que nos la pedirá cada vez que montemos el sistema de archivos cifrado.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/636558857333a1fdb964.js?file=encfs.sh&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/36852.js&#34; id=&#34;asciicast-36852&#34; async&gt;&lt;/script&gt;
        &lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/36852&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/36852.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
        
        &lt;figcaption&gt;Inicialización y montaje de un sistema de archivos cifrado para su uso con EncFS&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/div&gt;

Montado el sistema de archivos veremos que en el explorador de archivos se ha montado una unidad con el nombre del directorio sin cifrar que hemos indicado, como se aprecia en el caso de Nautilus.

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/126/sistema-archivos-descifrados.png&#34; title=&#34;Sistema de archivos montado y descifrado&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/126/sistema-archivos-descifrados-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

La opción _-f_ sirve para usar EncFS en primer plano, si lo usamos de esta forma se quedará esperando hasta que lo finalicemos con _Ctrl-C_ momento en el que desmontará automáticamente la unidad. Cuando queramos desmontar el sistema de archivos otra opción es el siguiente comando:

&lt;script src=&#34;//gist.github.com/picodotdev/636558857333a1fdb964.js?file=fusermount.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Montado el sistema de archivos en primer o segundo plano podremos trabajar con los archivos normalmente y EncFS irá cifrando su contenido y nombres de archivos de forma transparente en el directorio de archivos cifrados. Añadiendo algún archivo este podría ser el contenido del directorio de archivos cifrados.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/126/sistema-archivos-cifrados.png&#34; title=&#34;Sistema de archivos cifrado&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/126/sistema-archivos-cifrados-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Por supuesto, el contenido de un archivo cifrado será completamente ininteligible consiguiendo nuestro objetivo de que nuestros datos estén a salvo y protegidos.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/126/contenido-archivo-descifrado.png&#34; title=&#34;Contenido de un archivo de texto&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/126/contenido-archivo-descifrado-thumb.png&#34;&gt;&lt;/a&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/126/contenido-archivo-cifrado.png&#34; title=&#34;Contenido del archivo de texto cifrado&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/126/contenido-archivo-cifrado-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;En el &lt;a href=&#34;https://wiki.archlinux.org/index.php/EncFS&#34;&gt;artículo de EncFS de la wiki de Arch Linux&lt;/a&gt; está muy bien explicado con alguna información más sobre esta forma de proteger la preciada información personal que poseemos en diversas formas de documentos, imágenes, fotos, vídeos, música y otros formatos.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/como-recuperar-archivos-eliminados-o-de-una-unidad-corrupta-en-gnu-linux/&#34;&gt;Cómo recuperar archivos eliminados o de una unidad corrupta en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-unidad-usb-completamente-con-dm-crypt-y-luks-en-gnu-linux/&#34;&gt;Cifrar unidad USB completamente con dm-crypt y LUKS en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/03/como-eliminar-de-forma-segura-archivos-con-wipe-y-dd-en-gnu-linux/&#34;&gt;Cómo eliminar de forma segura archivos con wipe en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/EncFS&#34;&gt;Artículo de EncFS de la wiki de Arch Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="seguridad"/>
            
                <category term="software-libre"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2016/02/como-recuperar-archivos-eliminados-o-de-una-unidad-corrupta-en-gnu-linux/</id>
        <title>Cómo recuperar archivos eliminados o de una unidad corrupta en GNU/Linux</title>        
        <updated>2016-02-12T19:30:00+01:00</updated>
        <published>2016-02-12T19:30:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/02/como-recuperar-archivos-eliminados-o-de-una-unidad-corrupta-en-gnu-linux/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Muchos archivos y su contenido son recuperables aún después de eliminados y liberado su espacio ocupado del sistema de archivos. Herramientas como Foremost son capaces de recuperar el contenido de un archivo si no ha sido sobreescrito accediendo a bajo nivel a los datos de la unidad, ya esté corrupta y de algún error al montarla o funcione perfectamente. Pudiendo extraer una imagen de la unidad seremos capaces de recuperar gran cantidad de archivos motivo por el cual al deshacernos de una unidad de almacenamiento es recomendable hacer un borrado seguro para evitar que información personal o confidencial sea obtenida con cualquier propósito.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/gnu.png&#34; class=&#34;right&#34; alt=&#34;GNU&#34; title=&#34;GNU&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/linux.png&#34; class=&#34;right&#34; alt=&#34;Linux&#34; title=&#34;Linux&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Hace un tiempo me ocurrió que una memoria USB por algún motivo no se montaba bien ni en un sistema Windows ni tampoco en un sistema Linux. El &lt;em&gt;pendrive&lt;/em&gt; estaba formateado con el sistema de archivos NTFS y quizá por haberlo desmontado mal se corrompió.&lt;/p&gt;

&lt;p&gt;Por suerte en GNU/Linux disponemos de cantidad de herramientas y programas que nos ayudan en prácticamente cualquier cosa. En este caso de una memoria que no se dejaba montar buscando algún enlace en la &lt;a href=&#34;https://wiki.archlinux.org/&#34;&gt;wiki de Arch Linux&lt;/a&gt; relacionado con la recuperación de datos encontré en poco tiempo el artículo sobre &lt;a href=&#34;https://wiki.archlinux.org/index.php/Foremost&#34;&gt;Foremost&lt;/a&gt;, siendo un programa que puede ayudarnos a recuperar al menos parte de los datos que tuviésemos guardados. Si la unidad no está dañada físicamente y podemos extraer una imagen de la misma Foremost puede acceder a bajo nivel a las estructuras de datos de la imagen de la unidad. Foremost puede trabajar directamente sobre la unidad dañada o con una imagen, esto último es lo recomendable para evitar corromper los datos y dañar más gravemente la unidad al usarla. Si podemos extraer una imagen de la unidad es buen síntoma de que la unidad no ha dejado de funcionar completamente y tal vez se trate solo de un error lógico en la unidad y no físico pudiendo tal vez recuperarla con un formateo.&lt;/p&gt;

&lt;p&gt;El error en concreto al montarlo en mi sistema &lt;a href=&#34;https://www.archlinux.org/&#34;&gt;Arch Linux&lt;/a&gt; era el siguiente:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/d8197f30979b1d2fb75e.js?file=error.log&#34;&gt;&lt;/script&gt;

&lt;p&gt;Podemos extraer una imagen de una unidad con el comando &lt;em&gt;dd&lt;/em&gt;, el parámetro &lt;em&gt;if&lt;/em&gt; será la unidad de entrada y el parámetro &lt;em&gt;of&lt;/em&gt; la imagen que se creará en un archivo:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/d8197f30979b1d2fb75e.js?file=dd.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una vez que disponemos de la imagen en un archivo en un sistema libre de fallos usaremos Foremost para que intente recuperar los archivos que no han sido completamente corrompidos por el error. Indicamos la imagen del archivo extraída con el parámetro &lt;em&gt;-i&lt;/em&gt; y la carpeta donde dejará los archivos recuperados con el parámetro &lt;em&gt;-o&lt;/em&gt; agrupados en directorios por tipo, con el parámetro &lt;em&gt;-t&lt;/em&gt; indicamos los tipos de archivos que queremos recuperar de entre todos los que pueda (doc, docx, pdf, jpg, png, txt, &amp;hellip;).&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/d8197f30979b1d2fb75e.js?file=foremost.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Si tenemos suerte con Foremost recuperaremos gran parte de ellos y evitaremos perderlos para siempre. En la wiki de Arch Linux hay una &lt;a href=&#34;https://wiki.archlinux.org/index.php/file_recovery&#34;&gt;guía con consejos y explicaciones de como proceder en la recuperación de archivos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Una vez que recuperé los archivos y viendo que pude extraer una imagen de la unidad probablemente en mi caso el error sería que se corrompió la unidad quizá por no extraerla de forma segura desde Windows. Por lo tanto la volví a formatear e hice algunas pruebas copiando varios archivos, se copiaron sin dar ningún error así que al final conseguí recuperar incluso la unidad.&lt;/p&gt;

&lt;p&gt;Esto mismo es aplicable a una unidad que funcione correctamente, un archivo y su contenido es recuperable aún después de ser eliminado incluido de la papelera, con más probabilidad si la unidad no tiene muchas escrituras o una buena cantidad de espacio libre ya que por defecto únicamente se elimina de las estructuras del sistema de archivos y el contenido sigue estando presente simplemente no referenciado.&lt;/p&gt;

&lt;p&gt;Para hacer irrecuperable el contenido de un archivo hay que hacer un &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/03/como-eliminar-de-forma-segura-archivos-con-wipe-y-dd-en-gnu-linux/&#34;&gt;borrado seguro de un archivo con el comando &lt;em&gt;wipe&lt;/em&gt; o de una unidad con &lt;em&gt;dd&lt;/em&gt;&lt;/a&gt; que consiste en sobreescribir el contenido del archivo con datos aleatorios, otra alternativa es &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-unidad-usb-completamente-con-dm-crypt-y-luks-en-gnu-linux/&#34;&gt;cifrar el sistema de archivos&lt;/a&gt;. Es recomendable hacerlo cuando sustituyamos y nos deshagamos un disco duro o unidad de almacenamiento porque muchos de los archivos son recuperables incluido después de un formateo rápido de la unidad.&lt;/p&gt;

&lt;p&gt;Te sorprenderá la cantidad de archivos que son recuperados por Foremost: documentos, imágenes, archivos de texto, &amp;hellip;&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-archivos-con-encfs-en-gnu-linux/&#34;&gt;Cifrar archivos con EncFS en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/cifrar-unidad-usb-completamente-con-dm-crypt-y-luks-en-gnu-linux/&#34;&gt;Cifrar unidad USB completamente con dm-crypt y LUKS en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/03/como-eliminar-de-forma-segura-archivos-con-wipe-y-dd-en-gnu-linux/&#34;&gt;Cómo eliminar de forma segura archivos con wipe en GNU/Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Foremost&#34;&gt;Foremost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/file_recovery&#34;&gt;File recovery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linux.die.net/man/1/wipe&#34;&gt;Wipe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Securely_wipe_disk&#34;&gt;Securely Wipe Disk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Disk_encryption&#34;&gt;Disk encryption&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="seguridad"/>
            
                <category term="software-libre"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/04/certificado-ssl-de-empresa-wildcard-y-de-validacion-extendida/</id>
        <title>Certificado SSL, de empresa, «wildcard» y de validación extendida</title>        
        <updated>2015-04-25T12:00:00+02:00</updated>
        <published>2015-04-25T10:07:04+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/04/certificado-ssl-de-empresa-wildcard-y-de-validacion-extendida/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;p&gt;Usar un protocolo seguro garantiza de que los datos intercambiados entre el cliente y el servidor no son leídos ni modificados por una tercera parte además de verificar que la comunicación se está realizando entre las partes que dicen ser. Para usar un &lt;a href=&#34;https://es.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;protocolo seguro como SSL/TLS&lt;/a&gt; debemos disponer de con certificado, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/generar-y-convertir-claves-y-certificados-con-openssl/&#34;&gt;con OpenSSL podemos generar y convertirlo al formato que deseemos&lt;/a&gt;, sin embargo, para que el usuario tenga garantía de que el certificado es válido este se debe estar firmado por una &lt;a href=&#34;https://es.wikipedia.org/wiki/Autoridad_de_certificaci%C3%B3n&#34;&gt;autoridad de certificación&lt;/a&gt; (CA) en la que confíe, generalmente con una de las autoridades de certificación cuyos certificados están preinstalados en el navegador web (en Firefox podemos verlos en &lt;em&gt;Preferencias&amp;gt; Avanzado&amp;gt; Certificados&amp;gt; Ver certificados&lt;/em&gt;), los certificados autofirmados son útiles para hacer pruebas pero no son válidos para los usuarios. En este artículo comentaré que tipos de certificados hay y donde podemos obtener o comprar un certificado digital firmado por una CA que sea de confianza para el usuario.&lt;/p&gt;

&lt;p&gt;Los navegadores suelen indicar que se está usando una comunicación segura cuando en la barra de direcciones se muestra un candado y se está usando el protocolo https. Además, haciendo clic en el candado se pueden ver los detalles del certificado usado por el servidor para la comunicación cifrada.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/77/certificado-validacion-dominio.png&#34; title=&#34;Certificado SSL con validación de dominio&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/77/certificado-validacion-dominio.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/77/certificado.png&#34; title=&#34;Datos de certificado de GitHub&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/77/certificado-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Sin embargo, para proporcionar más seguridad y garantía de que como usuarios nos estamos comunicando con el servidor que creemos sin examinar el certificado algunos certificados permiten mostrar también en la barra de direcciones un recuadro verde con el nombre de la entidad, el recuadro verde que solemos ver también en la barra de direcciones al acceder a algunos dominios y que es proporcionado por certificados de validación extendida.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/77/certificado-validacion-extendida.png&#34; title=&#34;Certificado SSL con validación extendida&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/77/certificado-validacion-extendida.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Por otra parte los certificados SSL se generan para un dominio en concreto con lo que en principio se debería comprar un certificado por cada dominio en el que deseemos usar una comunicación segura. Sin embargo, para evitar comprar múltiples certificados para los diferentes dominios o subdominios podemos comprar un certificado &lt;em&gt;wildcard&lt;/em&gt; que nos servirá para los subdominios (*.ejemplo.com) o un certificado multidominio (ejemplo.com, ejemplo.net, &amp;hellip;) para como su nombre indica varios dominios. En los certificados de empresa se solicitan datos datos adicionales al adquirirlo y en los detalles del certificado aparece el nombre de la empresa (campo Organización (O) como en el caso de GitHub).&lt;/p&gt;

&lt;p&gt;Los certificados &lt;em&gt;wildcard&lt;/em&gt; y que muestran el recuadro verde son más caros pero pueden ser útiles sobre todo para una página de comercio electrónico, el recuadro verde añade más seguridad, seguramente mejore los ratios de conversión y evite &lt;a href=&#34;https://es.wikipedia.org/wiki/Phishing&#34;&gt;suplantaciones de identidad o &lt;em&gt;phising&lt;/em&gt;&lt;/a&gt;. Además, utilizar un protocolo seguro es un nuevo criterio que utiliza el buscador Google en su algoritmo para establecer el posicionamiento en la página de resultados. Con las intrucciones que incorporan los procesadores modernos el cifrado y descifrado de los datos no tiene por que significar un aumento de carga considerable para el servidor ni el cliente ni en dispositivos móviles.&lt;/p&gt;

&lt;p&gt;¿Cómo obtener un certificado SSL firmado por una entidad raíz de certificación? Las entidades de registro de dominios aparte de dominios, &lt;em&gt;hosting&lt;/em&gt; virtual o privado algunos permiten comprar certificados SSL. Uno de los que conozco que permite comprar certificados SSL, de empresa, con recuadro verde o &lt;em&gt;wildcard&lt;/em&gt; es &lt;a href=&#34;http://www.dondominio.com/products/ssl/&#34;&gt;DonDominio&lt;/a&gt;, otro es &lt;a href=&#34;http://www.arsys.es/certificados-seguridad-ssl&#34;&gt;Arsys&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/77/certificados-dondominio.png&#34; title=&#34;Certificados DonDominio&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/77/certificados-dondominio-thumb.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;En el caso de DonDominio dependiendo de la entidad emisora del certficado que deseemos variará el precio, también si queremos que tenga validación extendida o sea &lt;em&gt;wildcard&lt;/em&gt;. En el caso de un certificado SSL simple que valide solo el dominio es de unos 5 €, de validación de empresa unos 28 €, un certificado de validación extendida con recuadro verde desde unos 126 € y un &lt;em&gt;certificado wildcard&lt;/em&gt; de desde unos 75 €. Estos son precios desde, diferentes opciones pueden salir bastante más caras y hay que tener en cuenta que son para una validez de una año, al igual que los dominios hay que renovar su uso.&lt;/p&gt;

&lt;p&gt;Si no necesitamos el recuadro verde ni un certificado &lt;em&gt;wildcard&lt;/em&gt; una opción interesante es obtener uno gratis a través de &lt;a href=&#34;https://letsencrypt.org/&#34;&gt;Lets Encrypt&lt;/a&gt;. Esta nueva entidad de certificación nos permitirá obtener uno sin coste, de forma sencilla y automatizada, detrás de esta entidad están organizaciones como &lt;a href=&#34;http://www.linuxfoundation.org/&#34;&gt;Linux Foundation&lt;/a&gt;, &lt;a href=&#34;https://www.mozilla.org/&#34;&gt;Mozilla&lt;/a&gt; o &lt;a href=&#34;http://www.cisco.com/&#34;&gt;CISCO&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Una vez obtenido el certificado debemos instalarlo en el servidor, en el artículo &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/configurar-ssl-en-un-servidor-tomcat-jboss-wildfly-lighttpd-nginx-apache/&#34;&gt;Configurar SSL en un servidor Tomcat JBoss, Wildfly, Lighttpd, Nginx o Apache&lt;/a&gt; comento como usar un certificado en los principales servidores web y de aplicaciones. Si necesitamos un formato concreto podemos &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/generar-y-convertir-claves-y-certificados-con-openssl/&#34;&gt;convertir el certificado con OpenSSL&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.genbeta.com/seguridad/que-es-un-certificado-ssl-y-por-que-deberia-importarte&#34;&gt;Qué es un certificado SSL y por qué debería importarte&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="programacion"/>
            
                <category term="seguridad"/>
            
                <category term="blog-stack"/>
            
                <category term="planeta-linux"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/04/guardar-contrasenas-usando-salted-password-hashing-y-otras-formas-correctas/</id>
        <title>Guardar contraseñas usando «Salted Password Hashing» y otras formas correctas</title>        
        <updated>2015-04-14T21:00:00+02:00</updated>
        <published>2015-04-10T18:55:04+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2015/04/guardar-contrasenas-usando-salted-password-hashing-y-otras-formas-correctas/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/apache-shiro.png&#34; class=&#34;right&#34; alt=&#34;Apache Shiro&#34; title=&#34;Apache Shiro&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Para cada servicio deberíamos emplear una contraseña de una longitud de al menos 8 caracteres que incluya letras en minúscula, mayúscula, números y símbolos, una herramienta que podemos utilizar para generar contraseñas más seguras con los criterios que indiquemos es &lt;a href=&#34;http://strongpasswordgenerator.com/&#34;&gt;Strong Password Generator&lt;/a&gt;. Sin embargo, recordar cada una de estas contraseñas es muy difícil de modo que es habitual que utilicemos la misma contraseña para varios o todos los servicios y no empleando todos los criterios anteriores. Por otro lado, los desarrolladores no deberíamos guardar en la base de datos las contraseñas que nos entregan los usuarios en texto plano, para evitar guardalas en texto plano hace un tiempo se utilizaba únicamente una función de &lt;em&gt;hashing&lt;/em&gt; unidireccional como MD5 o SHA, de este modo si la base de datos fuese comprometida en teoría no podrían conocer la contraseña original. En este artículo comentaré que aún guardando las contraseñas con una función de &lt;em&gt;hashing&lt;/em&gt; no es suficiente para hacerlas seguras y comentaré una implementación con &lt;a href=&#34;http://shiro.apache.org/&#34;&gt;Apache Shiro&lt;/a&gt; de una de las ideas propuestas.&lt;/p&gt;

&lt;h3 id=&#34;algo-de-teoría-y-algunas-explicaciones&#34;&gt;Algo de teoría y algunas explicaciones&lt;/h3&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; text-align: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.png&#34; class=&#34;right&#34; alt=&#34;Java&#34; title=&#34;Java&#34;&gt;
&lt;/div&gt;

&lt;p&gt;Aunque guardemos las contraseñas con MD5 o alguna variante de SHA hoy en día no es suficiente para que en caso de que alguien obtenga los &lt;em&gt;hashes&lt;/em&gt; de las contraseñas de la base de datos pueda averiguarlas o dar con una que genere el mismo &lt;em&gt;hash&lt;/em&gt;, usando estas funciones se pueden encontrar colisiones en un tiempo razonable y por tanto ya no se consideran seguras. Dada la computación actual de los procesadores y las tarjetas gráficas una contraseña débil puede romperse usando un &lt;a href=&#34;https://es.wikipedia.org/wiki/Ataque_de_fuerza_bruta&#34;&gt;ataque de fuerza bruta&lt;/a&gt; y quizá antes con un &lt;a href=&#34;https://es.wikipedia.org/wiki/Ataque_de_diccionario&#34;&gt;ataque de diccionario&lt;/a&gt; que pruebe las más comunes. Muchos usuarios no tienen contraseñas largas ni utilizan letras en minúscula, mayúscula, números y símbolos, muchos usuarios utilizan contraseñas sencillas para ser recordadas más fácilmente, y aún &lt;em&gt;hasheando&lt;/em&gt; las contraseñas pueden ser averiguadas. También se pueden usar &lt;a href=&#34;https://es.wikipedia.org/wiki/Tabla_arco%C3%ADris&#34;&gt;tablas arcoiris&lt;/a&gt; o &lt;em&gt;rainbow tables&lt;/em&gt; con los &lt;em&gt;hashes&lt;/em&gt; precalculados de las contraseñas de un diccionario con lo que el tiempo empleado para romper una puede requerir poco tiempo de computación.&lt;/p&gt;

&lt;p&gt;También hay que tener en cuenta que muchos usuarios usan la misma contraseña para múltiples servicios por lo que basta que alguien obtenga la contraseña original de un servicio y podrá acceder a otros más interesantes para alguien con malas intenciones por mucha seguridad que tenga esos otros servicios, este es uno de los motivos de la autenticación en dos pasos (que emplea algo que sé, la contraseña, y algo que tengo, como el móvil) y la recomendación de usar una contraseña diferente para cada servicio. Las contraseñas por si solas tiene la seguridad más baja de los diferentes servicios donde se usen.&lt;/p&gt;

&lt;p&gt;Con &lt;em&gt;Salted Password Hashing&lt;/em&gt; el uso de &lt;em&gt;rainbow tables&lt;/em&gt; que aceleren el ataque no serían posibles por la entropía añadida por los &lt;em&gt;salt&lt;/em&gt;. Aún así conociendo el &lt;em&gt;salt&lt;/em&gt; y la función de &lt;em&gt;hash&lt;/em&gt; empleada seguiría siendo posible un ataque de fuerza bruta y de diccionario. Con &lt;em&gt;Salted Password Hashing&lt;/em&gt; se usa en la función de &lt;em&gt;hash&lt;/em&gt; y un dato variable denominado &lt;em&gt;salt&lt;/em&gt; que añade suficiente entropía y es diferente para cada contraseña, en la base de datos se guarda el resultado de la función de &lt;em&gt;hash&lt;/em&gt; junto con el &lt;em&gt;salt&lt;/em&gt;, esto es, el resultado de SHA-512(contraseña+&lt;em&gt;salt&lt;/em&gt;) y también el &lt;em&gt;salt&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;ejemplo-de-salted-password-hashing-usando-apache-shiro&#34;&gt;Ejemplo de &lt;em&gt;Salted Password Hashing&lt;/em&gt; usando Apache Shiro&lt;/h3&gt;

&lt;p&gt;Antes de comentar alguna opción más que dificulte los ataques de fuerza bruta o de diccionario veamos como implementar &lt;em&gt;Salted Password Hashing&lt;/em&gt; empleando Apache Shiro como librería de autenticación y autorización para los usuarios. El ejemplo será simple sin guardar los datos en una base de datos pero suficiente para mostrar que se debe añadir al proyecto para que Shiro compruebe las contraseñas usando una función de &lt;em&gt;hash&lt;/em&gt; y un &lt;em&gt;salt&lt;/em&gt;. Partiré de un ejemplo que hice para el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/libro-sobre-desarrollo-de-aplicaciones-con-apache-tapestry/&#34;&gt;libro PlugIn Tapestry&lt;/a&gt; sobre el desarrollo de aplicaciones web con el &lt;em&gt;framework&lt;/em&gt; &lt;a href=&#34;http://tapestry.apache.org&#34;&gt;Apache Tapestry&lt;/a&gt;. Básicamente deberemos crear un nuevo &lt;em&gt;Realm&lt;/em&gt; que devuelva los datos del usuario, el &lt;em&gt;hash&lt;/em&gt; y el &lt;em&gt;salt&lt;/em&gt;. Una implementación suficiente para el ejemplo sería la siguiente, la parte importante está en el método &lt;em&gt;doGetAuthenticationInfo&lt;/em&gt; y en la inicialización &lt;em&gt;static&lt;/em&gt; de la clase:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c718273bc1a5ec76831b.js?file=Realm.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Las contraseñas &lt;em&gt;hasheadas&lt;/em&gt; tendrán la siguiente forma, podemos guardarlas codificadas en formato hexadecimal o en formato Base64:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c718273bc1a5ec76831b.js?file=hashed-password.txt&#34;&gt;&lt;/script&gt;

&lt;p&gt;En el ejemplo tratándose de una aplicación web usando Apache Tapestry se debe modificar la configuración para que se utilice el nuevo &lt;em&gt;Realm&lt;/em&gt; el antiguo guardaba las contraseñas en texto plano (&lt;em&gt;shiro-users.properties&lt;/em&gt;).&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c718273bc1a5ec76831b.js?file=AppModule.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;El cambio de &lt;em&gt;Realm&lt;/em&gt; para el usuario no supone ninguna modificación y podrá seguir autenticandose con su misma contraseña. En el ejemplo con &lt;em&gt;root&lt;/em&gt; como usuario y &lt;em&gt;password&lt;/em&gt; como contraseña.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/75/formulario-inicio-sesion.png&#34; title=&#34;Formulario de inicio de sesión&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/75/formulario-inicio-sesion.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Este es todo el código que necesitamos para la implementación de contraseñas codificadas con una función de &lt;em&gt;hashing&lt;/em&gt;, en este caso SHA-512, y un &lt;em&gt;salt&lt;/em&gt;, no es mucho y además es bastante simple la implementación con Shiro y en este caso en una aplicación usando el &lt;em&gt;framework&lt;/em&gt; Apache Tapestry. Estas pocas líneas de código pueden aumentar notablemente la seguridad de las contraseñas que guardamos en la base de datos. En el caso de que la base de datos se vea comprometida será más difícil para alguien con malas intenciones obtener las contraseñas originales.&lt;/p&gt;

&lt;p&gt;El siguiente ejemplo de &lt;a href=&#34;https://github.com/tynamo/tynamo-federatedaccounts/tree/master/tynamo-federatedaccounts-test/src/test/java/org/tynamo/security/federatedaccounts/testapp/services&#34;&gt;&lt;em&gt;federatedaccounts&lt;/em&gt;&lt;/a&gt; puede verse como usar está técnica de &lt;em&gt;hash&lt;/em&gt; con &lt;em&gt;salt&lt;/em&gt; usando una base de datos. Básicamente es lo mismo pero accediendo a base de datos para obtener el &lt;em&gt;hash&lt;/em&gt; de la contraseña y el &lt;em&gt;salt&lt;/em&gt; con una entidad JPA.&lt;/p&gt;

&lt;h3 id=&#34;otras-opciones-que-añaden-más-seguridad&#34;&gt;Otras opciones que añaden más seguridad&lt;/h3&gt;

&lt;p&gt;Aún así como comento este ejemplo de &lt;em&gt;Salted Password Hashing&lt;/em&gt; aunque dificulta un ataque aún es viable usar fuerza bruta o un diccionario. En el artículo &lt;a href=&#34;https://stormpath.com/blog/password-security-right-way/&#34;&gt;Password Security Right Way&lt;/a&gt; comentan tres ideas más. Una es usar como función de &lt;em&gt;hash&lt;/em&gt; &lt;a href=&#34;http://bcrypt.sourceforge.net/&#34;&gt;Bcrypt&lt;/a&gt; no porque sea más segura que SHA-512 sino porque es más lenta y esto puede hacer inviable la fuerza bruta o de diccionario, hay &lt;a href=&#34;https://issues.apache.org/jira/browse/SHIRO-290&#34;&gt;planes de proporcionar Bcrypt en Apache Shiro&lt;/a&gt; en futuras versiones. En el ejemplo como alternativa a bcrypt se usan varios millones de iteraciones de aplicación de la función para añadir tiempo de cálculo al &lt;em&gt;hash&lt;/em&gt;, este tiempo adicional no es significativo en el cálculo de un &lt;em&gt;hash&lt;/em&gt; pero en un ataque de fuerza bruta puede aumentarlo de forma tan significativa que sea inviable. La segunda idea interesante es además de &lt;em&gt;hashear&lt;/em&gt; la clave es cifrarla de modo que aún habiendo sido comprometida la base de datos se necesite la clave privada de cifrado que también debería ser comprometida para producir el ataque. La tercera es partir el &lt;em&gt;hash&lt;/em&gt; y distribuirlo entre varios sistemas de modo que sea necesario romperlos todos para obtener en &lt;em&gt;hash&lt;/em&gt; original, lo que dificulta aún más un ataque.&lt;/p&gt;

&lt;p&gt;Para implementar la segunda opción deberemos proporcionar implementaciones propias de &lt;a href=&#34;https://shiro.apache.org/static/1.2.3/apidocs/org/apache/shiro/authc/credential/CredentialsMatcher.html&#34;&gt;CredentialsMatcher&lt;/a&gt; y de &lt;a href=&#34;https://shiro.apache.org/static/1.2.3/apidocs/org/apache/shiro/crypto/hash/SimpleHash.html&#34;&gt;SimpleHash&lt;/a&gt;, quizá esto sea tema para otro artículo.&lt;/p&gt;

&lt;h3 id=&#34;código-fuente-del-ejemplo&#34;&gt;Código fuente del ejemplo&lt;/h3&gt;

&lt;p&gt;El &lt;a href=&#34;https://github.com/picodotdev/elblogdepicodev/tree/master/PlugInTapestry&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; está alojado en un repositorio de GitHub, es completamente funcional y puedes probarlo en tu equipo. Una vez descargado el siguiente comando e introduciendo en el navegador &lt;em&gt;http://localhost:8080/PlugInTapestry&lt;/em&gt;, en la página que se muestra hay un botón para iniciar sesión:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c718273bc1a5ec76831b.js?file=gradlew.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/75/iniciar-sesion.png&#34; title=&#34;Botón de inicio de sesión&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/75/iniciar-sesion.png&#34;&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;h3 id=&#34;nota-final&#34;&gt;Nota final&lt;/h3&gt;

&lt;p&gt;En este artículo recomiendo leer los interesantes enlaces del apartado de referencia del final, de ellos los siguientes dos son bastante completos &lt;a href=&#34;https://stormpath.com/blog/password-security-right-way/&#34;&gt;Password Security the Right Way&lt;/a&gt; y &lt;a href=&#34;https://crackstation.net/hashing-security.htm&#34;&gt;The RIGHT Way: How to Hash Properly&lt;/a&gt; aunque todos merecen el tiempo dedicado a una lectura detenida. Para terminar mucho de esto es fútil si se permiten contraseñas sencillas por lo que exigir contraseñas con cierta fortaleza de la forma comentada al principio también es necesario si la seguridad de la aplicación es un requisito importante.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stormpath.com/blog/password-security-right-way/&#34;&gt;Password Security the Right Way&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://codahale.com/how-to-safely-store-a-password/&#34;&gt;How To Safely Store A Password&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stormpath.com/product/password_security/&#34;&gt;Password Security with Stormpath&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stormpath.com/blog/strong-password-hashing-apache-shiro/&#34;&gt;Strong Password Hashing With Apache Shiro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://crackstation.net/hashing-security.htm#properhashing&#34;&gt;The RIGHT Way: How to Hash Properly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://shiro.apache.org/realm.html#Realm-HashingandCorrespondingMatchers&#34;&gt;Apache Shiro, Hashing and Corresponding Matchers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://shiro.apache.org/realm.html#Realm-HashingCredentials&#34;&gt;Apache Shiro, Hashing Credentials&lt;/a&gt;
&lt;a href=&#34;http://tynamo.org/tapestry-security+guide&#34;&gt;http://tynamo.org/tapestry-security+guide&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://strongpasswordgenerator.com/&#34;&gt;Strong Password Generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.arumeinformatica.es/blog/encriptar-y-guardar-contrasenas-en-base-de-datos/&#34;&gt;Encriptar y guardar contraseñas en base de datos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.michael-pratt.com/blog/8/Seguridad-en-el-almacenamiento-de-PasswordsContrasenas/&#34;&gt;Seguridad en el almacenamiento de Passwords/Contraseñas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osi.es/ca/node/4522&#34;&gt;Usuarios con contraseñas repetidas: ciberdelincuentes felices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.elladodelmal.com/2015/03/un-hash-md5-en-la-password-no-susituye.html&#34;&gt;Un HASH MD5 en la password no sustituye a SSL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://es.wikipedia.org/wiki/Ataque_de_fuerza_bruta&#34;&gt;Ataque de fuerza bruta&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://es.wikipedia.org/wiki/Ataque_de_diccionario&#34;&gt;Ataque de diccionario&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://es.wikipedia.org/wiki/Tabla_arco%C3%ADris&#34;&gt;Tablas arcoiris o &lt;em&gt;rainbow tables&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="programacion"/>
            
                <category term="seguridad"/>
            
                <category term="tapestry"/>
            
                <category term="blog-stack"/>
            
                <category term="planeta-linux"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2014/02/configurar-ssl-en-un-servidor-tomcat-jboss-wildfly-lighttpd-nginx-apache/</id>
        <title>Configurar SSL/TLS en un servidor Tomcat, JBoss, WildFly, Lighttpd, Nginx o Apache</title>        
        <updated>2016-03-05T12:00:00+01:00</updated>
        <published>2014-02-28T16:58:17+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/02/configurar-ssl-en-un-servidor-tomcat-jboss-wildfly-lighttpd-nginx-apache/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Tanto en un servidor web como de aplicaciones podemos hacer que la comunicación entre el cliente y el servidor esté cifrada usando un protocolo seguro. La configuración para usar un protocolo seguro en cada servidor es diferente pero todos se basan en lo mismo, usar un certificado y un clave. En este artículo muestro la configuración necesaria en los servidores web y de aplicaciones más populares.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/openssl.svg&#34; class=&#34;right&#34; width=&#34;400&#34; alt=&#34;OpenSSL&#34; title=&#34;OpenSSL&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En entradas anteriores he explicado &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2013/11/introduccion-la-criptografia-e-inicio-con-gpg.html&#34;&gt;en que consiste la criptografía y GPG&lt;/a&gt; y como podemos usarlo a nivel personal para firmar y cifrar archivos y &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2013/11/como-usar-gpg-con-evolution.html&#34;&gt;firmar correos electrónicos con el cliente de correo Evolution&lt;/a&gt;. También he comentado &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/generar-y-convertir-claves-y-certificados-con-openssl/&#34;&gt;como crer un certificado con OpenSSL y como convertirlo a diferentes formatos&lt;/a&gt;. En esta entrada explicaré como usar un certificado SSL creado con OpenSSL después de conocer los &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/04/certificado-ssl-de-empresa-wildcard-y-de-validacion-extendida/&#34;&gt;Certificados SSL, de empresa, «wildcard» y de validación extendida&lt;/a&gt; para proporcionar acceso cifrado al sevidor web o servidor de aplicaciones, explicaré cual es la configuración necesaria para los servidores &lt;a href=&#34;http://tomcat.apache.org/&#34;&gt;Tomcat&lt;/a&gt;, &lt;a href=&#34;http://www.lighttpd.net/&#34;&gt;Lighttpd&lt;/a&gt;, &lt;a href=&#34;http://www.jboss.org/jbossas&#34;&gt;JBoss&lt;/a&gt;/&lt;a href=&#34;http://wildfly.org/&#34;&gt;WildFly&lt;/a&gt;, &lt;a href=&#34;http://nginx.org/&#34;&gt;Nginx&lt;/a&gt; y &lt;a href=&#34;http://www.apache.org/&#34;&gt;Apache&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Usar una conexión &lt;abbr title=&#34;Secure Sockets Layer&#34;&gt;SSL&lt;/abbr&gt; o &lt;abbr title=&#34;Transport Layer Security&#34;&gt;TLS&lt;/abbr&gt; y un certificado de servidor evita que los datos entre el navegador del usuario y el servidor sean legibles para una tercera parte siendo mayor la seguridad en nuestras aplicaciones o dando mayor confianza al usuario y usando algunos certificados al aparecer en la barra de navegación del navegador en verde el nombre de la entidad detrás de la página evitando problemas de suplantación de identidad.&lt;/p&gt;

&lt;p&gt;Los principales navegadores han anunciado que una conexión cifrada SSL/TLS es condición necesaria para usar el ya presente &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/introduccion-al-protocolo-http-2/&#34;&gt;protocolo HTTP/2&lt;/a&gt; que es más eficiente tanto para el cliente como para el servidor y con menores latencias. &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/configurar-http-2-en-nginx-apache-httpd-wildfly-o-jetty/&#34;&gt;Configurar HTTP/2 en Nginx, Apache HTTPD, WildFly o Jetty&lt;/a&gt; es sencillo y mejorará el rendimiento de nuestros sitios web o aplicaciones.&lt;/p&gt;

&lt;h3 id=&#34;configurar-ssl-tls-en-tomcat&#34;&gt;Configurar SSL/TLS en Tomcat&lt;/h3&gt;

&lt;p&gt;Tomcat es uno de los servidores de aplicaciones más usado para desplegar aplicaciones web desarrolladas con el lenguaje Java. La forma que explicaré a continuación sobre como obtener cifrado SSL con este servidor será usando APR (&lt;em&gt;Apache Portable Runtime&lt;/em&gt;). Previamente deberemos haber generado un certificado SSL con OpenSSL, una vez dispogamos del nuestro aunque sea autofirmado debemos añadir la siguiente configuración al archivo server.xml:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9275133.js?file=server.xml&#34;&gt;&lt;/script&gt;

&lt;p&gt;Hay que activar el conector SSL (el anterior xml) y disponer del certificado y su clave privada, ambos archivos se indican en los atributos SSLCertificateFile y SSLCertificateKeyFile. Si queremos usar el puerto estandar del protocolo HTTPS cambiaremos el valor del puerto de 8443 a 443 en el atributo port. La configuración es la misma tanto para Tomcat 7 como para Tomcat 8.&lt;/p&gt;

&lt;h3 id=&#34;configurar-ssl-tls-en-jboss&#34;&gt;Configurar SSL/TLS en JBoss&lt;/h3&gt;

&lt;p&gt;JBoss es otro de los servidores que es ampliamente usado para desplegar aplicaciones Java y que proporciona un perfil completo de las especificaciones EE al contrario que Tomcat que solo proporciona un perfil web. La configuración que hay que indicar en JBoss 7.1 es la siguiente:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9275133.js?file=standalone-jboss.xml&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;configurar-ssl-tls-en-wildfly&#34;&gt;Configurar SSL/TLS en WildFly&lt;/h3&gt;

&lt;p&gt;JBoss cambió recientemente el nombre de la versión community de JBoss, esta ha pasado a llamarse WildFly y la comercial con soporte sigue llamandose JBoss. WildFly soporta las especificaciones de Java EE 7. En WildFly el contenedor web es &lt;a href=&#34;http://undertow.io/&#34;&gt;undertow&lt;/a&gt; en vez de Tomcat y cambia la configuración de SSL. Senecesita crear un keystore JKS que contenga tanto la clave como el certificado.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9275133.js?file=standalone-wildfly.xml&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;configurar-ssl-tls-en-lighttpd&#34;&gt;Configurar SSL/TLS en Lighttpd&lt;/h3&gt;

&lt;p&gt;Lighttpd es un servidor web de los denominados ligeros que aunque posiblemente no tiene toda la versatilidad de Apache ofrece un mayor rendimiento. Para activar SSL en lighttpd debemos modificar el archivo de configuración y añadir lo siguiente:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9275133.js?file=lighttpd.conf&#34;&gt;&lt;/script&gt;

&lt;p&gt;Quizá debamos cambiar el propietario y permisos con:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9275133.js?file=script-1.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;El archivo localhost.pem contiene la clave y el certificado.&lt;/p&gt;

&lt;h3 id=&#34;configurar-ssl-tls-en-nginx&#34;&gt;Configurar SSL/TLS en Nginx&lt;/h3&gt;

&lt;p&gt;El proceso es similar para el servidor web Nginx aunque lógicamente se usan las directivas propias de configuración de Nginx.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9275133.js?file=nginx.conf&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;configurar-ssl-tls-en-apache&#34;&gt;Configurar SSL/TLS en Apache&lt;/h3&gt;

&lt;p&gt;Apache es uno de los servidores web más utilizados para servir sitios web en internet. Para activar SSL en Apache debemos modificar el archivo de configuración, añadiendo la siguiente configuración que activa el soporte de SSL y especifica el archivo de clave y certificado, nada distinto de lo necesario en los servidores anteriores:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9275133.js?file=httpd.conf&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html&#34;&gt;Tomcat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.jboss.org/jbossweb/7.0.x/ssl-howto.html&#34;&gt;JBoss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://community.jboss.org/message/824152#824152&#34;&gt;WildFly (Undertow)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://redmine.lighttpd.net/projects/1/wiki/HowToSimpleSSL&#34;&gt;Lighttpd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_ssl_module.html&#34;&gt;Nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://httpd.apache.org/docs/current/ssl/ssl_howto.html&#34;&gt;Apache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="seguridad"/>
            
                <category term="software"/>
            
                <category term="software-libre"/>
            
                <category term="planeta-linux"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2014/02/generar-y-convertir-claves-y-certificados-con-openssl/</id>
        <title>Generar y convertir claves y certificados con OpenSSL</title>        
        <updated>2017-04-08T23:00:00+02:00</updated>
        <published>2014-02-21T17:36:21+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/02/generar-y-convertir-claves-y-certificados-con-openssl/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Usando los comandos expuestos en este artículo y con OpenSSL podemos crear una clave pública y privada para usarlo con ssh o para cifrar y descifrar mensajes, un certificado autofirmado que podremos usar en un servidor de aplicaciones para usar un protocolo seguro y también convertir las claves y certificados a uno de los formatos aceptados por la aplicación que usemos.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/openssl.svg&#34; class=&#34;right&#34; width=&#34;400&#34; alt=&#34;OpenSSL&#34; title=&#34;OpenSSL&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Para un uso personal como enviar correos o archivos cifrados o firmados digitalmente usar &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2013/11/introduccion-la-criptografia-e-inicio-con-gpg.html&#34;&gt;GnuPG&lt;/a&gt; es una buena opción. En Internet los servidores también se aprovechan del uso de criptografía para realizar comunicaciones seguras entre el usuario y el servidor.&lt;/p&gt;

&lt;p&gt;Para hacer uso en un servidor de una comunicación https donde los datos viajan cifrados y sin que otras partes salvo el usuario y el servidor puedan acceder a los datos necesitamos un certificado digital. Un certificado es un archivo que contiene la clave pública sirviéndonos para verificar su autenticidad. Un certificado autofirmado es un certificado firmado con la misma clave privada asociada a la clave pública que contiene el certificado. Un certificado autofirmado es suficiente para un entorno de pruebas pero en un servidor para proporcionar confianza a los usuarios deberemos solicitar que una autoridad de certificados que nos firme con su clave nuestro certificado, si el usuario confía en esa autoridad de certificado puede de esta manera confiar en nuestro certificado y clave pública. Varias entidades de registro de dominios o halojamiento web ofrecen la compra de certificados SSL, en el artículo &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/04/certificado-ssl-de-empresa-wildcard-y-de-validacion-extendida/&#34;&gt;Certificado SSL, de empresa, «wildcard» y de validación extendida&lt;/a&gt; comento con un poco más detalle los varios tipos de certificados y algunas opciones donde obtenerlos o comprarlos.&lt;/p&gt;

&lt;p&gt;Dependiendo del tipo de certificado que solicitemos y nos entregue la autoridad de certificado el usuario podrá ver que está simplemente accediendo a un servidor con conexión segura, ver los detalles de nuestro certificado y en algunos casos el usuario podrá ver en la barra de direcciones en verde el nombre de la entidad, que puede darle al usuario más confianza y ver que realmente está accediendo al servidor correcto y no a uno que esté intentando suplantar una identidad. En este último caso la barra de direcciones no tendría en verde el nombre de la entidad, esto es algo que como usuarios debemos comprobar al acceder a determinados sitios de forma segura.&lt;/p&gt;

&lt;p&gt;Con la herramienta &lt;a href=&#34;https://www.openssl.org/&#34;&gt;OpenSSL&lt;/a&gt; y los siguientes comandos podemos generar claves y certificados y realizar las conversiones entre formatos que necesitemos.&lt;/p&gt;

&lt;h3 id=&#34;crear-claves-y-certificados&#34;&gt;Crear claves y certificados&lt;/h3&gt;

&lt;h4 id=&#34;crear-una-clave-privada-y-pública&#34;&gt;Crear una clave privada y pública&lt;/h4&gt;

&lt;p&gt;Para generar un par de claves RSA que nos permitan tanto cifrar datos como realizar firmas se emplea el siguiente comando:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-1.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para cifrar la clave generada con el algoritmo &lt;em&gt;aes256&lt;/em&gt; y protegerla por una contraseña se puede emplear el siguiente comando, en realidad al generar la clave indicando la misma opción &lt;em&gt;-aes256&lt;/em&gt; en el comando anterior la clave se generará cifrada y protegida por una contraseña. Para cambiar la contraseña es el mismo comando y el segundo comando elimina la contraseña y la descifra:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-12.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;El contenido de un archivo de clave privada sin cifrar tiene el siguiente aspecto (los tres puntos son líneas de contenido omitidas).&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=localhost.key&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;exportar-la-clave-pública&#34;&gt;Exportar la clave pública&lt;/h4&gt;

&lt;p&gt;El archivo generado al crear el par de claves contiene tanto la clave pública como la privada. La privada no se debe distribuir y se debe mantener protegida de forma que solo la conozca su propietario. La clave pública es la que se distribuye a otras personas o entidades. Para extraer la clave pública del archivo generado anterior por OpenSSL usamos el siguiente comando:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-9.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;También se puede obtener la clave pública en formato &lt;a href=&#34;https://www.openssh.com/&#34;&gt;OpenSSH&lt;/a&gt; y una representación gráfica de la huella digital.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-10.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/13/openssh-fingerprint.png&#34; title=&#34;Huella digital de una clave pública OpenSSH&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/13/openssh-fingerprint-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Huella digital de una clave pública OpenSSH&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h4 id=&#34;obtener-la-huella-digital-de-la-clave-pública&#34;&gt;Obtener la huella digital de la clave pública&lt;/h4&gt;

&lt;p&gt;La huella digital de una clave pública sirve para comprobar que la clave es la esperada. Son una cadena de números y letras pudiendo estar cada pareja de caracteres separados por &lt;em&gt;:&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-11.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/13/openssl-dgst.png&#34; title=&#34;Huella digital de una clave pública&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/13/openssl-dgst-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Huella digital de una clave pública&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h4 id=&#34;crear-un-certificado&#34;&gt;Crear un certificado&lt;/h4&gt;

&lt;p&gt;Un certificado contiene la firma de una tercera parte que valida nuestra clave pública como auténtica. Para que esa tercera parte pueda firmar nuestra clave deberemos generar una petición de firma de certificado y enviársela a la autoridad de certificado que nos lo devolverá firmado. La petición firma de certificado se crea con el siguiente comando:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-2.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Si no queremos tratar con una autoridad de certificado, ya que cobran por la firma, podemos crear un certificado autofirmado que puede ser suficiente para un entorno de pruebas. El comando para generar el certificado autofirmado es:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-3.sh&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;convertir-un-certificado-a-otros-formatos&#34;&gt;Convertir un certificado a otros formatos&lt;/h3&gt;

&lt;p&gt;Dependiendo de la autoridad de certificado el certificado puede estar en diferentes formatos, dependiendo del servidor donde tengamos idea de usarlo podemos necesitar convertirlo a otro formato. También podemos usar OpenSSL para hacer las conversiones.&lt;/p&gt;

&lt;h4 id=&#34;convertir-un-certificado-en-formato-der-crt-cer-der-a-pem&#34;&gt;Convertir un certificado en formato DER (.crt .cer .der) a PEM&lt;/h4&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-4.sh&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;convertir-un-certificado-en-formato-pem-a-der&#34;&gt;Convertir un certificado en formato PEM a DER&lt;/h4&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-5.sh&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;convertir-un-certificado-en-formato-pem-y-una-clave-privada-a-pkcs-12-pfx-p12&#34;&gt;Convertir un certificado en formato PEM y una clave privada a PKCS#12 (.pfx .p12)&lt;/h4&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-6.sh&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;convertir-un-archivo-en-formato-pkcs-12-pfx-p12-que-contiene-una-clave-privada-y-certificado-a-pem&#34;&gt;Convertir un archivo en formato PKCS#12 (.pfx .p12) que contiene una clave privada y certificado a PEM&lt;/h4&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-7.sh&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;convertir-pkcs-12-a-keystore-jks&#34;&gt;Convertir PKCS#12 a keystore JKS&lt;/h4&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9138093.js?file=script-8.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una vez que disponemos de un certificado y del formato en el que necesitemos podemos hacer uso de él, por ejemplo, en un servidor de páginas web o aplicaciones para proporcionar acceso mediante el protocolo HTTPS y proporcionar seguridad SSL. Pero eso será tema para la entrada &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/configurar-ssl-en-un-servidor-tomcat-jboss-wildfly-lighttpd-nginx-apache/&#34;&gt;Configurar SSL en un servidor Tomcat, JBoss, WildFly, Lighttpd, Nginx o Apache&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.openssl.org/&#34;&gt;OpenSSL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sslshopper.com/article-most-common-openssl-commands.html&#34;&gt;The Most Common OpenSSL Commands&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="programacion"/>
            
                <category term="seguridad"/>
            
                <category term="software"/>
            
                <category term="software-libre"/>
            
                <category term="planeta-linux"/>
            
        
    </entry>
    
</feed>
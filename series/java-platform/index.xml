<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://picodotdev.github.io/blog-bitix/series/java-platform/</id>
    <title type="text">Blog Bitix</title>
    <subtitle>Recent content on Blog Bitix</subtitle>
    <updated>2017-09-24T10:00:00+02:00</updated>
    <author><name>pico.dev</name></author>
    <generator>Hugo</generator>
    <icon>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</icon>
    <logo>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</logo>
    <rights>https://creativecommons.org/licenses/by-sa/4.0/</rights>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/09/novedades-de-java-9-mas-alla-de-la-modularidad/</id>
        <title>Novedades de Java 9, más allá de la modularidad</title>        
        <updated>2017-10-07T12:15:00+02:00</updated>
        <published>2017-09-24T10:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/09/novedades-de-java-9-mas-alla-de-la-modularidad/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;La modularidad introducida en Java 9 no es la única novedad incorporada en esta nueva versión. Aunque haya llegado a eclipsar al resto hay otra buena colección de mejoras que sin duda facilitarán la programación con uno de los lenguajes más empleados por los programadores aún después de más de 20 años.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;La última versión mayor de Java fue publicada en el año 2014, hace ya mucho tiempo para la época actual donde las cosas avanzan a un ritmo muy rápido. &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;Java 8 introdujo en el lenguaje notables cambios&lt;/a&gt; como las expresiones &lt;em&gt;lambda&lt;/em&gt; dotándolo de capacidades funcionales y mayor expresividad en menos líneas de código junto con referencias a métodos e interfaces funcionales que permite crear implementaciones anónimas de interfaces con una &lt;em&gt;lambda&lt;/em&gt;, se añaden los &lt;em&gt;streams&lt;/em&gt; como nueva forma de iterar sobre las colecciones, interfaces con métodos por defecto o estáticos que aumentan la compatibilidad hacia atrás que siempre se le ha dado gran importancia en la plataforma o una nueva API para fechas que solventa las deficiencias de la anterior. Grandes cambios en el lenguaje tan importantes como los que supusieron Java 5.&lt;/p&gt;

&lt;p&gt;Después de algunos aplazamientos principalmente por implementar la modularización de la forma correcta sin que en un futuro suponga un problema ha sido publicada en septiembre de 2017 la versión de Java 9. La característica más llamativa es &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/09/novedades-y-nuevas-caracteristicas-de-java-9-los-modulos/&#34;&gt;la modularización de la plataforma con Java 9&lt;/a&gt; que supone grandes mejoras como una mejor encapsulación de los paquetes, interfaces entre módulos bien definidas y dependencias explícitas que proporcionan optimización al usarse sólo los módulos que se necesitan, mayor seguridad al ser menor la superficie de ataque y configuración confiable al comprobar las dependencias al compilar o iniciarse la máquina virtual.&lt;/p&gt;

&lt;p&gt;Pero Java 9 además de los módulos incorpora en la plataforma otros cambios destacables. Esta no es una lista exhaustiva pero si contiene muchas de ellas.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/9/index.html&#34;&gt;Oracle JDK 9 Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/9/whatsnew/toc.htm&#34;&gt;What’s New in Oracle JDK 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/9/javase-docs.htm&#34;&gt;Guías descargables con documentación del JDK 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oracle.com/java/java9-screencasts.html&#34;&gt;Varios &lt;em&gt;screencasts&lt;/em&gt; sobre varias de las novedades de Java 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javamagazine.mozaicreader.com/SeptOct2017&#34;&gt;Java Magazine Sep/Oct 2017&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/264/tabla-novedades-java-9.jpg&#34; title=&#34;Tabla de novedades de Java 9&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/264/tabla-novedades-java-9-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Tabla de novedades de Java 9&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/264/duke-java-9.png&#34; width=&#34;300&#34; alt=&#34;Duke Java 9&#34; title=&#34;Duke Java 9&#34;&gt;
&lt;/div&gt;

&lt;h3 id=&#34;métodos-factoría-para-colecciones&#34;&gt;Métodos factoría para colecciones&lt;/h3&gt;

&lt;p&gt;Aún Java no incorpora en el lenguaje una forma de definir como literales elementos tan comunes como listas, conjuntos o mapas. Como alternativa se proporcionan métodos factoría estáticos para crear este tipo de estructuras de datos usando métodos por defecto en sus respectivas interfaces. Además, estos métodos crean colecciones inmutables.&lt;/p&gt;

&lt;p&gt;Aparte de definir este tipo de colecciones de una forma mucho más sencilla que hasta Java 8, las colecciones además son significativamente más eficientes. En el caso de Java 8 un &lt;em&gt;Set&lt;/em&gt; con dos elementos de capacidad 3 requiere un objeto &lt;em&gt;wrapper&lt;/em&gt; para la colección inmodificable, 1 &lt;em&gt;HashSet&lt;/em&gt;, 1 &lt;em&gt;HashMap&lt;/em&gt;, 1 Object[] de longitud 3, 2 dos nodos uno para cada elemento requiriendo en total unos 152 bytes. En el caso de Set creado con Java 9 requiere solo 20 bytes que comparados con los 152 es una mejora significativa más al tener en cuenta que este tipo de estructuras de datos son utilizadas de forma numerosa en cualquier programa. Aún estando hablando de bytes multiplicado por cada uso en algunos casos la reducción de memoria puede ser apreciable.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/543bdd4dad7311efbc80a298db328b73.js?file=Collections.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;//players.brightcove.net/1460825906/VkKNQZg6x_default/index.html?videoId=5582422289001&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;mejoras-en-la-clase-optional&#34;&gt;Mejoras en la clase &lt;em&gt;Optional&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Los métodos &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#or-java.util.function.Supplier-&#34;&gt;or()&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#ifPresentOrElse-java.util.function.Consumer-java.lang.Runnable-&#34;&gt;ifPresentOrElse()&lt;/a&gt; así como &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#stream--&#34;&gt;stream()&lt;/a&gt; mejoran la experiencia de uso en esta clase que contiene o no un objeto. El método &lt;em&gt;or()&lt;/em&gt; en caso de no contener el &lt;em&gt;Optional&lt;/em&gt; un objeto permite proporcionar un &lt;em&gt;Optional&lt;/em&gt; alternativo. Los métodos &lt;em&gt;ifPresent()&lt;/em&gt; y &lt;em&gt;ifPresentOrElse()&lt;/em&gt; permiten realizar una acción con el objeto del opcional si está presente u otra acción con un valor vacío si no está presente. El método &lt;em&gt;stream()&lt;/em&gt; convierte el &lt;em&gt;Optional&lt;/em&gt; en un &lt;em&gt;stream&lt;/em&gt; de cero o un elemento.&lt;/p&gt;

&lt;h3 id=&#34;mejoras-en-la-api-de-streams&#34;&gt;Mejoras en la API de &lt;em&gt;streams&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Los nuevos métodos de los &lt;em&gt;streams&lt;/em&gt; &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#dropWhile-java.util.function.Predicate-&#34;&gt;dropWhile()&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#takeWhile-java.util.function.Predicate-&#34;&gt;takeWhile()&lt;/a&gt; permiten descartar o tomar elementos del &lt;em&gt;stream&lt;/em&gt; mientras se comprueba una condición. El método &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#ofNullable-T-&#34;&gt;ofNullable()&lt;/a&gt; devuelve un &lt;em&gt;stream&lt;/em&gt; de un elemento o vacío dependiendo de si el objeto es &lt;em&gt;null&lt;/em&gt; o no. Los métodos &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#iterate-T-java.util.function.Predicate-java.util.function.UnaryOperator-&#34;&gt;iterate()&lt;/a&gt; permiten generar un secuencia de valores similar a un bucle &lt;em&gt;for&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;repl-con-jshell&#34;&gt;REPL con jshell&lt;/h3&gt;

&lt;p&gt;Otra de las características destacables es la incorporación de &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/09/jshell-la-herramienta-repl-incorporada-en-java-9/&#34;&gt;la herramienta JShell&lt;/a&gt; para evaluar código siguiendo el patrón &lt;em&gt;Read-Evaluate-Print-Loop&lt;/em&gt; o REPL para hacer pruebas de código sin la necesidad de un IDE, una herramienta de construcción o toda la infraestructura de un proyecto. Esta herramienta es el comando &lt;em&gt;jshell&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se pueden introducir expresiones que son evaluadas y comandos precedidos por el caracter &lt;em&gt;/&lt;/em&gt;. Soporta asistencia de código con la tecla tabulador.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm#JSHEL-GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8&#34;&gt;Guía de usuario de jshell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/264/jshell.png&#34; title=&#34;jshell&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/264/jshell-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;jshell&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;//players.brightcove.net/1460825906/VkKNQZg6x_default/index.html?videoId=5582429016001&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;jlink-para-generar-runtimes-mínimos&#34;&gt;jlink para generar &lt;em&gt;runtimes&lt;/em&gt; mínimos&lt;/h3&gt;

&lt;p&gt;Java 8 proporciona varios &lt;em&gt;runtimes&lt;/em&gt; reducidos con los &lt;em&gt;compact profiles&lt;/em&gt; que contienen algunas clases menos de las que incluye el JDK completo. Sin embargo, estos &lt;em&gt;runtimes&lt;/em&gt; están preconfigurados y las aplicaciones deben optar por el que ofrezca todas las clases que necesita.&lt;/p&gt;

&lt;p&gt;En Java 9 se proporciona &lt;a href=&#34;http://openjdk.java.net/jeps/282&#34;&gt;jlink&lt;/a&gt; que un sustituto más capaz que los &lt;em&gt;compact profiles&lt;/em&gt;. Permite generar &lt;em&gt;runtimes&lt;/em&gt; aprovechando la nueva modularidad del JDK con únicamente los módulos que necesite la aplicación.&lt;/p&gt;

&lt;p&gt;Esto es especialmente útil para los contenedores de &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; y los entornos &lt;em&gt;cloud&lt;/em&gt; ya que permite generar imágenes de contenedores con un tamaño significativamente menor. Por ejemplo, una imagen de Docker basada en la distribución &lt;a href=&#34;https://www.alpinelinux.org/&#34;&gt;Alpine Linux&lt;/a&gt; con el JDK completo ocupa unos 360 MiB, con &lt;em&gt;jlink&lt;/em&gt; si una aplicación solo necesita del módulo &lt;em&gt;java.base&lt;/em&gt; se puede generar un &lt;em&gt;runtime&lt;/em&gt; con únicamente ese módulo, con este &lt;em&gt;runtime&lt;/em&gt; adaptado la imagen del contenedor tiene un tamaño mucho menor, en este caso de únicamente de unos 40 MiB.&lt;/p&gt;

&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;//players.brightcove.net/1460825906/VkKNQZg6x_default/index.html?videoId=5582437011001&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;concurrencia&#34;&gt;Concurrencia&lt;/h3&gt;

&lt;p&gt;Se añade un &lt;em&gt;framework&lt;/em&gt; con un conjunto de clases para programación reactiva de publicación-subscripción con las clases &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html&#34;&gt;Flow&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Processor.html&#34;&gt;Flow.Processor&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Subscriber.html&#34;&gt;Flow.Subscriber&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Processor.html&#34;&gt;Flow.Publisher&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Processor.html&#34;&gt;Flow.Subscription&lt;/a&gt;. La clase &lt;em&gt;Subsription&lt;/em&gt; posee dos métodos: &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Subscription.html#cancel--&#34;&gt;cancel()&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Subscription.html#request-long-&#34;&gt;request()&lt;/a&gt; para dejar de recibir mensajes y solicitar recibir &lt;em&gt;n&lt;/em&gt; mensajes en la siguientes llamadas de &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Subscriber.html#onNext-T-&#34;&gt;onNext​()&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;El método &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html#copy--&#34;&gt;copy()&lt;/a&gt; de la clase &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html&#34;&gt;CompletableFuture&lt;/a&gt; permite obtener un copia completándose con el mismo valor cuando la operación se completa normalmente.&lt;/p&gt;

&lt;h3 id=&#34;variable-handles&#34;&gt;Variable Handles&lt;/h3&gt;

&lt;p&gt;Una de las justificaciones de la modularidad es el uso que hasta ahora se le ha dado a la famosa clase interna del JDK &lt;em&gt;sun.misc.Unsafe&lt;/em&gt;. Para proporcionar parte de la funcionalidad de esta clase en una API pública se introduce la clase &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/VarHandle.html&#34;&gt;VarHandle&lt;/a&gt; para referenciar a variables estáticas y no estáticas así como a &lt;em&gt;arrays&lt;/em&gt;. Estas instancias se obtienen mediante la clase &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.Lookup.html&#34;&gt;MethodHandle.Lookup&lt;/a&gt;. Una vez obtenida una instancia de &lt;em&gt;VarHandle&lt;/em&gt; se pueden realizar operaciones de bajo nivel sobre la variable que referencia como operaciones atómicas comparar y establecer pero sin la sobrecarga de rendimiento con las clases equivalentes del paquete &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/atomic/package-summary.html&#34;&gt;java.util.concurrent.atomic&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Para la mayoría de los programadores esto no les afectará directamente pero sí será una mejora para los desarrolladores de librerías importantes muy populares que si usan la clase &lt;em&gt;Unsafe&lt;/em&gt; y deberían aprovechar estas nuevas capacidades para dejar de usar la clase interna del JDK en la medida de lo posible.&lt;/p&gt;

&lt;h3 id=&#34;actualizaciones-en-la-api-para-procesos&#34;&gt;Actualizaciones en la API para procesos&lt;/h3&gt;

&lt;p&gt;Ahora es posible obtener el identificador del proceso o &lt;em&gt;pid&lt;/em&gt; con el método &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/Process.html#pid--&#34;&gt;pid()&lt;/a&gt; y los procesos hijos y descendientes con los métodos &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/Process.html#children--&#34;&gt;children​()&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/Process.html#descendants--&#34;&gt;descendants​()&lt;/a&gt; respectivamente.&lt;/p&gt;

&lt;h3 id=&#34;stackwalker&#34;&gt;StackWalker&lt;/h3&gt;

&lt;p&gt;La clase &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html&#34;&gt;StackWalker&lt;/a&gt; permite obtener un &lt;em&gt;stream&lt;/em&gt; secuencial de &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.StackFrame.html&#34;&gt;StackWalker.StackFrames&lt;/a&gt; del &lt;em&gt;thread&lt;/em&gt; actual para procesar la pila de llamadas o &lt;em&gt;stacktrace&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/543bdd4dad7311efbc80a298db328b73.js?file=StackWalker.java&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;strings-compactos&#34;&gt;Strings compactos&lt;/h3&gt;

&lt;p&gt;Internamente los la clase &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/String.html&#34;&gt;String&lt;/a&gt; contiene un array de &lt;em&gt;char&lt;/em&gt;, cada &lt;em&gt;char&lt;/em&gt; se representa en formato con la codificación UTF-8 ocupando 16 bits o 2 bytes por cada caracter. Para cadenas en aquellos lenguajes como inglés los caracteres pueden ser representados usando un único &lt;em&gt;byte&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Una buena parte de la memoria ocupada en la JVM por cualquier aplicación es debido a las cadenas de modo que tiene sentido compactar aquellas cadenas en las que sea posible representándolas con un único &lt;em&gt;byte&lt;/em&gt; por caracter.&lt;/p&gt;

&lt;p&gt;Lo mejor de todo es que esta optimización será transparente para los programadores y para las aplicaciones proporcionando una reducción en el uso de la memoria y aumento del rendimiento, también en el recolector de basura.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.javagists.com/compact-strings-java-9&#34;&gt;Compact Strings In Java 9&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;recolector-de-basura-g1-por-defecto&#34;&gt;Recolector de basura G1 por defecto&lt;/h3&gt;

&lt;p&gt;Se cambia el recolector de basura por defecto al llamado &lt;em&gt;G1&lt;/em&gt; optimizado para una balance adecuado entre alto rendimiento y baja latencia. En los siguientes artículos se explica de forma más detallada. Al igual que los &lt;em&gt;string&lt;/em&gt; compactos para la mayoría de los programadores será un cambio transparente que no tenga repercusión en la forma de programar las aplicaciones.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html&#34;&gt;Getting Started with the G1 Garbage Collector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.com/articles/Make-G1-Default-Garbage-Collector-in-Java-9&#34;&gt;Case for Defaulting to G1 Garbage Collector in Java 9&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;//players.brightcove.net/1460825906/VkKNQZg6x_default/index.html?videoId=5582428191001&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;identificador-para-variables&#34;&gt;Identificador para variables _&lt;/h3&gt;

&lt;p&gt;El identificador &lt;em&gt;_&lt;/em&gt; queda reservado para en un futuro usarlo en parámetros a los que no se les dé un uso y no sean relevantes como por ejemplo en las &lt;em&gt;lambdas&lt;/em&gt;. También se evaluará en el &lt;a href=&#34;http://openjdk.java.net/projects/amber/&#34;&gt;proyecto Amber&lt;/a&gt; usar este identificador para tipos diamante parciales como &lt;em&gt;Foo&amp;lt;String, _&amp;gt;&lt;/em&gt; o en referencias a métodos &lt;em&gt;foo.&amp;lt;String, _&amp;gt;bar()&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.takipi.com/project-amber-the-future-of-java-exposed/&#34;&gt;Project Amber: The Future of Java Exposed&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;métodos-privados-en-interfaces&#34;&gt;Métodos privados en interfaces&lt;/h3&gt;

&lt;p&gt;Ahora se pueden crear métodos privados en interfaces como utilidad a las implementaciones de los métodos por defecto.&lt;/p&gt;

&lt;h3 id=&#34;mejor-try-with-resource&#34;&gt;Mejor &lt;em&gt;try-with-resource&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Ahora las variables finales o efectivamente finales pueden ser colocadas en los bloques &lt;em&gt;try-with-resource&lt;/em&gt; simplificando  algunos usos.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/543bdd4dad7311efbc80a298db328b73.js?file=TryWithResources.java&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;javadoc&#34;&gt;Javadoc&lt;/h3&gt;

&lt;p&gt;Ahora la documentación Javadoc se genera con marcado de HTML 5 e incluye un cuadro de búsqueda para encontrar más fácilmente tipos y métodos.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/264/javadoc.png&#34; title=&#34;Javadoc&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/264/javadoc-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Javadoc&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;archivos-jar-multiversión&#34;&gt;Archivos Jar multiversión&lt;/h3&gt;

&lt;p&gt;Los desarrolladores de librerías para dar soporte a varias versiones de Java debían optar entre generar un artefacto para cada versión o un único archivo &lt;em&gt;jar&lt;/em&gt; limitándose a usar la mínima versión soportada y sin aprovechar las nuevas capacidades de siguientes versiones. Esto es un impedimento para el uso de nuevas versiones.&lt;/p&gt;

&lt;p&gt;Con Java 9 se puede generar un único archivo &lt;em&gt;jar&lt;/em&gt; con algunas clases para una o varias versiones de Java. Por ejemplo, en un archivo &lt;em&gt;jar&lt;/em&gt; con las clases &lt;em&gt;A&lt;/em&gt;, &lt;em&gt;B&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; y &lt;em&gt;D&lt;/em&gt; compatibles con Java 6 el desarrollador ahora puede decidir que para la versión 9 la clase &lt;em&gt;A&lt;/em&gt; y &lt;em&gt;B&lt;/em&gt; sean unas optimizadas para esta versión. Esto se consigue con una estructura específica de directorios en el archivo &lt;em&gt;jar&lt;/em&gt;, ubicándose la clase optimizada para Java 9 &lt;em&gt;A&lt;/em&gt; en &lt;em&gt;META-INF/versions/9/A.class&lt;/em&gt; y para Java 10 en &lt;em&gt;META-INF/versions/10/A.class&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/543bdd4dad7311efbc80a298db328b73.js?file=Multirelease.out&#34;&gt;&lt;/script&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://openjdk.java.net/jeps/238&#34;&gt;JEP 238: Multi-Release JAR Files&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;nuevo-modelo-de-publicación&#34;&gt;Nuevo modelo de publicación&lt;/h3&gt;

&lt;p&gt;A partir de la publicación de Java 9 se cambia el modelo de publicación de nuevas versiones optando por una basada en calendario en vez de una por características a incluir. El caso de versiones que han de incluir las características previstas ocasiona el problema que si una se retrasa provoca un retraso en la versión. Con el modelo basado en fechas fijas preestablecidas la versión se liberará con aquellas características que estén listas en la fecha planificada de publicación sin ser retrasadas por aquellas que no.&lt;/p&gt;

&lt;p&gt;Se ha optado por producir una nueva versión cada seis meses con el &lt;a href=&#34;http://openjdk.java.net/&#34;&gt;OpenJDK&lt;/a&gt; y &lt;a href=&#34;https://www.gnu.org/licenses/gpl.html&#34;&gt;licencia GPL&lt;/a&gt; para satisfacer las necesidades de los desarrolladores y una versión con soporte de largo plazo cada tres años para satisfacer las necesidades de tiempo de soporte prolongado de las empresas, &lt;em&gt;Oracle JDK&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;//players.brightcove.net/1460825906/VkKNQZg6x_default/index.html?videoId=5582439790001&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Para finalizar un par de libros, &lt;a href=&#34;http://amzn.to/2g0qu6t&#34;&gt;Java 9 Revealed&lt;/a&gt; y &lt;a href=&#34;http://amzn.to/2fY3wwT&#34;&gt;Java 9 Modularity Revealed&lt;/a&gt; que explican detalladamente las novedades de la modularidad, las novedades incluídas en este artículo y algunas otras más.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1484225910&amp;linkId=9c7874501bb32fa3318e285022e0207a&#34;&gt;&lt;/iframe&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1484227123&amp;linkId=59d96101c25f9c16c4427b8ee9daef1a&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Y unos buenos vídeos sobre las nuevas características de Java 9, uno en español y otro en inglés.&lt;/p&gt;

&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;https://www.youtube.com/embed/CkmB86pCV6A&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
    &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;https://www.youtube.com/embed/9EiLRD95zDg&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zeroturnaround.com/rebellabs/the-best-java-9-language-and-api-improvements/&#34;&gt;The best Java 9 Language and API improvements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jaxenter.com/new-features-in-java-9-137344.html&#34;&gt;New Java 9 features at a glance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amzn.to/2ylsidI&#34;&gt;Modern Java Recipes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/try-with-resources-enhancement-in-java-9&#34;&gt;Try-With-Resource Enhancements in Java 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javamagazine.mozaicreader.com/JulyAug2017&#34;&gt;Revista Java Magazine Jul/Aug 2017&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/java-9-and-intellij-idea&#34;&gt;Java 9 and IntelliJ IDEA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.autentia.com/2017/09/13/java-9-mas-alla-de-la-modularidad/&#34;&gt;Java 9 más allá de la modularidad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/09/jshell-la-herramienta-repl-incorporada-en-java-9/&#34;&gt;JShell la herramienta REPL incorporada en Java 9&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/09/novedades-y-nuevas-caracteristicas-de-java-9-los-modulos/</id>
        <title>Novedades y nuevas características de Java 9, los módulos</title>        
        <updated>2017-10-07T12:10:00+02:00</updated>
        <published>2017-09-23T12:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/09/novedades-y-nuevas-caracteristicas-de-java-9-los-modulos/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Si en Java 8 la característica más destacada fue la incorporación al lenguaje de las &lt;em&gt;lambdas&lt;/em&gt; y los &lt;em&gt;streams&lt;/em&gt; en Java 9 la característica que más destaca es la definición de los módulos que proporciona varios importantes beneficios.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Después de unos cuantos aplazamientos de fechas finalmente ha sido publicado el 21 de septiembre de 2017 la &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/index.html&#34;&gt;versión 9 del lenguaje y plataforma Java&lt;/a&gt;, tres años después de las también importantes &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;novedades y nuevas características de Java 8&lt;/a&gt;. Al mismo tiempo se ha publicado versión de &lt;a href=&#34;http://www.oracle.com/technetwork/java/javaee/downloads/index.html&#34;&gt;Java EE 8&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;La incorporación de los módulos a la plataforma con Java 9 es una de las modificaciones más importantes en esta versión mayor del lenguaje. Aún siendo una de las características más destacadas y que ha eclipsado a otras modificaciones más allá de los módulos también importantes.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/9/index.html&#34;&gt;Oracle JDK 9 Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/9/whatsnew/toc.htm&#34;&gt;What’s New in Oracle JDK 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/9/javase-docs.htm&#34;&gt;Guías descargables con documentación del JDK 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oracle.com/java/java9-screencasts.html&#34;&gt;Varios &lt;em&gt;screencasts&lt;/em&gt; sobre varias de las novedades de Java 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javamagazine.mozaicreader.com/SeptOct2017&#34;&gt;Java Magazine Sep/Oct 2017&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/tabla-novedades-java-9.jpg&#34; title=&#34;Tabla de novedades de Java 9&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/tabla-novedades-java-9-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Tabla de novedades de Java 9&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;
&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/duke-java-9.png&#34; width=&#34;300&#34; alt=&#34;Duke Java 9&#34; title=&#34;Duke Java 9&#34;&gt;
&lt;/div&gt;

&lt;p&gt;Los módulos van a mejorar una de las deficiencias existentes en la visibilidad de las clases entre paquetes. Los módulos de Java proporcionan una mayor encapsulación de las clases contenidas en un paquete y las librerías. Esta encapsulación evita que una aplicación u otra librería haga uso y dependa de clases y paquetes de los que no debería lo que mejora la compatibilidad con versiones futuras. Los desarrolladores de una librería con los módulos ahora tienen un mayor control de los paquetes que expone una librería y que forma parte de su API pública. Con lo que se evita casos que se han dado hasta ahora como que librerías y programas dependan de clases internas en la API de Java como &lt;em&gt;sun.misc.BASE64Encoder&lt;/em&gt; o la famosa &lt;em&gt;sun.misc.Unsafe&lt;/em&gt;, para la primera en Java se añadió un reemplazo con &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/util/Base64.html&#34;&gt;java.util.Base64&lt;/a&gt;, para la segunda con Java 9 para parte de su funcionalidad se ha añadido algunas nuevas clases.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/java-version.png&#34; title=&#34;Java 9&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/java-version-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/jshell.png&#34; title=&#34;JShell&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/jshell-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Java 9 y JShell&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Los módulos proporcionan:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Encapsulación fuerte: se diferencia entre que es la API pública y usable y la parte privada a la que impide su uso accidental y acoplamiento indeseado entre módulos. La parte privada está encapsulado y de esta forma puede modificarse libremente con la seguridad de no afectar a los usuarios del módulo.&lt;/li&gt;
&lt;li&gt;Interfaces bien definidas: el código no encapsulado forma parte de la API del módulo, dado que otros módulos pueden usar esta API pública hay que tener especial cuidado al modificarlo al introducir cambios que sean incompatibles. Los módulos deben exportar una API bien definida y estable.&lt;/li&gt;
&lt;li&gt;Dependencias explícitas: los módulos necesitan a menudo otros módulos, estas dependencias son parte de la definición del módulo. Las dependencias explícitas forman un grafo que es importante conocer para entender las necesidades de una aplicación y para ejecutarla con todas sus dependencias.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los beneficios son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configuración confiable: el sistema de módulos comprueba si una combinación de módulos satisface todas las dependencias antes de compilar o ejecutar una aplicación.&lt;/li&gt;
&lt;li&gt;Encapsulación fuerte: se evitan dependencias sobre detalles internos de implementación.&lt;/li&gt;
&lt;li&gt;Desarrollo escalable: se crean límites entre el equipo que desarrolla un módulo y el que lo usa.&lt;/li&gt;
&lt;li&gt;Optimización: dado que el sistema de módulos sabe que módulos necesita cada uno solo se consideran los necesarios mejorándose tiempos de inicio y memoria consumida.&lt;/li&gt;
&lt;li&gt;Seguridad: la encapsulación y optimización limita la superficie de ataque.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La modularización afecta al diseño, compilación, empaquetado y despliegue es mucho más que una nueva característica del lenguaje. Los módulos son artefactos con su propia entidad que contienen código y metadados para describir el módulo y como se relaciona con otros módulos.&lt;/p&gt;

&lt;p&gt;Hasta ahora se seguía una convención de poner clases en paquetes de nombre &lt;em&gt;.impl&lt;/em&gt; o &lt;em&gt;.internal&lt;/em&gt; pero realmente la gente seguía usando esas clases porque simplemente se podía. No había ninguna forma de ocultar las implementaciones de esos paquetes más allá del los modificadores de accesibilidad &lt;em&gt;protected&lt;/em&gt; y &lt;em&gt;private&lt;/em&gt; que no son satisfactorios para ocultar las implementaciones.&lt;/p&gt;

&lt;p&gt;Java desde sus inicios ha hecho un buen trabajo en la definición de interfaces usando la palabra reservada &lt;em&gt;interface&lt;/em&gt;. En el apartado de dependencias es donde había deficiencias. Sí, hay sentencias &lt;em&gt;import&lt;/em&gt; explícitas pero desafortunadamente son únicamente para el tiempo de compilación.&lt;/p&gt;

&lt;p&gt;En tiempo ejecución no hay ninguna noción de archivos JAR o agrupación lógica. En el &lt;em&gt;classpath&lt;/em&gt; todas las clases son puestas en una lista plana. Cuando la JVM carga una clase la encuentra recorriendo esa lista en orden secuencial, tan pronto como la clase es encontrada la búsqueda finaliza y la clase es cargada. Si la clase no se encuentra se obtiene una excepción en tiempo de ejecución y dado que las clases son cargadas bajo demanda en el momento de uso esa excepción potencialmente puede ser lanzada en un momento posterior de haber iniciado la aplicación. La JVM no puede verificar eficientemente la corrección del &lt;em&gt;classpath&lt;/em&gt; en el inicio o si se debería añadir otra librería &lt;em&gt;jar&lt;/em&gt;. Otros problemas insidiosos suceden cuando hay clases duplicadas en el &lt;em&gt;classpath&lt;/em&gt; por versiones diferentes de una misma librería.&lt;/p&gt;

&lt;p&gt;Antes del sistema de módulos de Java la librería de tiempo de ejecución consistía en un gran archivo &lt;em&gt;rt.jar&lt;/em&gt; con un tamaño de más de 60 MiB. Este archivo contiene la mayor parte de clases de la plataforma en forma de monolito. Para conseguir mayor flexibilidad y ser una plataforma de futuro se decidió modularizar el JDK.&lt;/p&gt;

&lt;p&gt;Eliminar algunas tecnologías en desuso del JDK no era una opción viable. La compatibilidad hacia atrás es uno de los principios más importantes para Java que guían su desarrollo. Eliminar estas APIs rompería esta compatibilidad hacia atrás, a pesar de que afectaría a un pequeño porcentaje de usuarios todavía hay una buena cantidad de gente usando tecnologías como CORBA.&lt;/p&gt;

&lt;p&gt;Descomponer el JDK en módulos ha sido un trabajo inmenso. Con más de 20 años de código heredado acumulados separar una enmarañada y grande base de código conteniendo cientos de clases en módulos bien definidos con límites claros mientras se mantiene la compatibilidad hacia atrás. Esto toma tiempo siendo el motivo de tomar tanto tiempo el incorporar un sistema de módulos en Java. Pero en el futuro este esfuerzo será recompensado en términos de velocidad de desarrollo y aumento de flexibilidad para el JDK.&lt;/p&gt;

&lt;p&gt;Con el tiempo las dependencias entre los propios paquetes y clases de la API de Java estaba enmarañada, con Java 9 las dependencias entre paquetes se ha simplificado en gran medida.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/java-8-modules.jpg&#34; title=&#34;Módulos de Java 8&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/java-8-modules-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/java-9-modules.jpg&#34; title=&#34;Módulos de Java 9&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/java-9-modules-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Módulos de Java 8 y Java 9&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;El entorno de ejecución de Java y el compilador conocen exactamente ahora que módulo resolver al buscar los tipos para un paquete dado. Previamente la única forma de obtener un tipo arbitrario era hacer una búsqueda en todo el &lt;em&gt;classpath&lt;/em&gt;. Por ejemplo, dos módulos con el mismo nombre producen un error en inicio de la aplicación, en vez de en tiempo de ejecución.&lt;/p&gt;

&lt;p&gt;Los módulos permiten definir a cada librería los paquetes de clases que exporta como su API accesible por otra librería o programa que la requiera. Además, cada librería debe al mismo tiempo definir qué paquetes requiere. Las exportaciones y requerimientos permiten ahora detectar al iniciar la máquina virtual si el grafo de dependencias está completo cosa que antes se producía en un mayor número de casos en tiempo de ejecución posiblemente con la excepción &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/NoClassDefFoundError.html&#34;&gt;NoClassDefFound&lt;/a&gt;. Una de los efectos que se mejoran en Java y que ya es una característica a la que se le da mucha importancia es la compatibilidad hacia atrás y también la encapsulación ya que los desarrolladores de las librerías tienen mayor control de que paquetes se permite su uso evitando dependencias no deseadas que impidan en un futuro que aplicaciones que hipotéticamente las usasen dejasen de ser compatibles con nuevas versiones.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9f69c721f4186e3eb005a6cfebdf6dfd.js?file=java-list-modules.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;La definición de un módulo se realiza con un nuevo archivo de código fuente de nombre &lt;em&gt;module-info.java&lt;/em&gt;. Con la palabra reservada &lt;em&gt;requires&lt;/em&gt; y una línea por paquete se definen qué paquetes requiere el módulo, con la palabra reservada &lt;em&gt;exports&lt;/em&gt; se define que paquetes del módulo se exportan y son visibles por algún otro módulo que lo requiera. También se han añadido las palabras reservadas &lt;em&gt;provides&lt;/em&gt; y &lt;em&gt;uses&lt;/em&gt; para proporcionar y usar definiciones de servicios que con anterioridad se realizaba en archivos ubicados en &lt;em&gt;META-INF/services&lt;/em&gt; como muestro en el ejemplo &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/09/aplicacion-java-extensible-con-la-clase-serviceloader/&#34;&gt;Aplicación Java extensible con la clase ServiceLoader&lt;/a&gt;. También se puede hacer que la directiva &lt;em&gt;requires&lt;/em&gt; sea de forma transitiva para que el módulo que lo use pueda usar ese paquete sin requerirlo de forma explícita, la directiva &lt;em&gt;opens&lt;/em&gt; permite hacer uso de reflectividad usando el método &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/reflect/AccessibleObject.html&#34;&gt;setAccesible&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dado que la transición hacia el uso de los módulos puede generar problemas de compatibilidad con aplicaciones existentes se han añadido algunos parámetros para la máquina virtual en el comando &lt;em&gt;java&lt;/em&gt; e incluso en el caso más grave desactivar completamente el sistema de módulos, aunque lógicamente esto está desaconsejado. En la &lt;a href=&#34;http://docs.oracle.com/javase/9/migrate/toc.htm&#34;&gt;guía de migración a Java 9&lt;/a&gt; están detallados los aspectos a tener en cuenta en la migración de una versión anterior a Java 9.&lt;/p&gt;

&lt;p&gt;Este es el típico ejemplo &lt;em&gt;Hola Mundo&lt;/em&gt; con Java 9 en que que muestro como compilar un programa usando los módulos y como ejecutarlo directamente desde la linea de comandos. En el código de la clase &lt;em&gt;Main&lt;/em&gt; no hay ningún cambio respecto al que sería con una versión anterior de Java sin embargo se añade el nuevo archivo de código fuente &lt;em&gt;module-info.java&lt;/em&gt; donde se definen sus dependencias que este programa no tiene salvo la implícita sobre el módulo &lt;em&gt;java.base&lt;/em&gt;. Los comandos para compilar y ejecutar el ejemplo directamente con los comandos &lt;em&gt;javac&lt;/em&gt; y &lt;em&gt;java&lt;/em&gt; si cambian, ahora se usa en vez de &lt;em&gt;classpath&lt;/em&gt; la opción &lt;em&gt;module-path&lt;/em&gt; y se indica la clase del módulo que contiene el método &lt;em&gt;main&lt;/em&gt; del programa.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9f69c721f4186e3eb005a6cfebdf6dfd.js?file=Main.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/9f69c721f4186e3eb005a6cfebdf6dfd.js?file=module-info.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/9f69c721f4186e3eb005a6cfebdf6dfd.js?file=java.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/java-9-helloworld.png&#34; title=&#34;Hola Mundo con Java 9&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/java-9-helloworld-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Hola Mundo con Java 9&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;El comando &lt;em&gt;jdeps&lt;/em&gt; muestra las dependencias de los módulos muy útil para tareas de análisis o depuración.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/jdeps.png&#34; title=&#34;Dependencias del ejemplo Hola Mundo con Java 9&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/jdeps-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/jdeps-java-sql.png&#34; title=&#34;Dependencias del módulo java.sql&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2017/263/jdeps-java-sql-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Análisis de dependencais con jdeps&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Para profundizar más en los detalles de la modularidad y el resto de novedades de Java 9 están los libros &lt;a href=&#34;http://amzn.to/2g0qu6t&#34;&gt;Java 9 Revealed&lt;/a&gt; y &lt;a href=&#34;http://amzn.to/2fY3wwT&#34;&gt;Java 9 Modularity Revealed&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1484225910&amp;linkId=9c7874501bb32fa3318e285022e0207a&#34;&gt;&lt;/iframe&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1484227123&amp;linkId=59d96101c25f9c16c4427b8ee9daef1a&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Para finalizar este artículo incluyo un vídeo sobre los módulos que comenta los aspectos más destacados. Hay &lt;a href=&#34;https://www.oracle.com/java/java9-screencasts.html&#34;&gt;otros vídeos sobre las novedades de Java 9&lt;/a&gt; de no más de 15 minutos cada uno.&lt;/p&gt;

&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;//players.brightcove.net/1460825906/VkKNQZg6x_default/index.html?videoId=5582429007001&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/HolaMundoJava9&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./java.sh&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/java-9-its-heeeere&#34;&gt;Java 9: It&amp;rsquo;s Heeeere&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/9/migrate/toc.htm&#34;&gt;Java Platform, Standard Edition Oracle JDK 9 Migration Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jaxenter.com/java-9-modules-jpms-basics-135885.html&#34;&gt;Java 9 modules – JPMS basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/09/jshell-la-herramienta-repl-incorporada-en-java-9/&#34;&gt;JShell la herramienta REPL incorporada en Java 9&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2016/04/aplicacion-de-ejemplo-usando-varias-especificaciones-de-java-ee-7/</id>
        <title>Aplicación de ejemplo usando varias especificaciones de Java EE 7</title>        
        <updated>2016-09-17T12:00:00+02:00</updated>
        <published>2016-04-08T17:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/04/aplicacion-de-ejemplo-usando-varias-especificaciones-de-java-ee-7/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Más lentamente que otras tecnologías Java EE en cada nueva versión sigue adaptándose a las nuevas tendencias en el desarrollo y facilitando la programación de aplicaciones de entidad empresarial. Java EE está formado por un conjunto de especificaciones que resuelven en gran medida muchas de las necesidades funcionales de las aplicaciones ya sean de persistencia, seguridad, mensajería, lógica de negocio, transaccionalidad, inyección de dependencias, presentación HTML, JSON, WebSockets, conexión a base de datos, envío de correos electrónicos o concurrencia. En este artículo mostraré un ejemplo usando varias de estas especificaciones y proporcionaré el código fuente completo.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java-ee.png&#34; class=&#34;right&#34; alt=&#34;Java EE&#34; title=&#34;Java EE&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.png&#34; class=&#34;right&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Comentaba las &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/03/introduccion-y-nuevas-caracteristicas-de-java-ee-7/&#34;&gt;novedades y nuevas características de Java EE 7&lt;/a&gt; que en el 2013 trajo esta nueva versión para el desarrollo de aplicaciones empresariales con el lenguaje Java. Hacía una descripción y cuáles eran las especificaciones y versiones de las mismas que proporcionan la funcionalidades comunes a muchas aplicaciones. En este artículo mostraré un ejemplo con código con la implementación de una aplicación usando varias de las especificaciones de Java EE.&lt;/p&gt;

&lt;p&gt;El ejemplo consistirá en una supuesta aplicación sencilla para hacer la lista de la compra de un supermercado usando las siguientes especificaciones &lt;abbr title=&#34;Java Server Faces&#34;&gt;JSF&lt;/abbr&gt;, &lt;abbr title=&#34;Java Persistence API&#34;&gt;JPA&lt;/abbr&gt;, &lt;abbr title=&#34;Java Transactions API&#34;&gt;JTA&lt;/abbr&gt;, Security, &lt;abbr title=&#34;Contexts and Dependency Injection&#34;&gt;CDI&lt;/abbr&gt;, &lt;abbr title=&#34;Enterprise Java Bean&#34;&gt;EJB&lt;/abbr&gt;, &lt;abbr title=&#34;Representational State Transfer&#34;&gt;REST&lt;/abbr&gt;, &lt;abbr title=&#34;Java API for RESTful Web Services&#34;&gt;JAX-RS&lt;/abbr&gt;, &lt;abbr title=&#34;JavaScript Object Notation&#34;&gt;JSON&lt;/abbr&gt;, eventos CDI y WebSockets. El comprador irá seleccionando productos y la cantidad de los mismos de su compra, la aplicación le informará del precio de los productos seleccionados hasta el momento y finalmente para hacer la compra iniciará sesión. En el momento que se realice una compra el &lt;em&gt;stock&lt;/em&gt; de productos se actualizará en todos los clientes conectados al supermercado.&lt;/p&gt;

&lt;p&gt;Este ejemplo está relacionado con otros artículos que he escrito como &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-de-multiproyecto-con-gradle/&#34;&gt;Ejemplo de multiproyecto con Gradle&lt;/a&gt;, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;Novedades y nuevas características de Java 8&lt;/a&gt; y alguno quizá considere de la misma forma que sigue habiendo más de &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/10-razones-para-seguir-usando-java/&#34;&gt;10 razones para seguir usando Java&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Para facilitar el desarrollo de la aplicación en el lado cliente usaré algunas librerías JavaScript de forma similar al ejemplo de la &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/04/ejemplo-lista-de-tareas-con-backbone-y-react/&#34;&gt;lista de tareas con Backbone y React junto con RequireJS&lt;/a&gt;. Seleccionados los productos, la compra se realizará usando una API REST intercambiando los datos con formato JSON, se persistirá en la base de datos con JPA actualizándose en ese momento el &lt;em&gt;stock&lt;/em&gt; de los productos de lo que se encargará un EJB para controlar esta pequeña lógica de negocio, si no hay &lt;em&gt;stock&lt;/em&gt; suficiente de un producto se producirá una excepción y devolverá un código de estado adecuado en la petición HTTP, al realizar la compra se generará un mensaje evento CDI que desencadenará la actualización del &lt;em&gt;stock&lt;/em&gt; de los usuarios conectados usando WebSockets. La página del listado de productos y el formulario de autenticación se generará usando la tecnología de presentación JSF.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2016/136/supermarket-java-ee-7.png&#34; title=&#34;Supermarket con Java EE 7&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2016/136/supermarket-java-ee-7-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Supermarket con Java EE 7&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Veamos primero la página inicial índice con el listado de productos generada con JSF. Obtiene el listado de productos y genera el HTML del mismo, además carga los JavaScripts necesarios para que la aplicación funcione en el navegador del cliente.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=index.html&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=template.html&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=IndexBean.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;El JavaScript añade la lógica en el cliente para ir realizando la lista de la compra usando poco más que &lt;a href=&#34;https://jquery.com/&#34;&gt;jQuery&lt;/a&gt; y &lt;a href=&#34;http://requirejs.org/&#34;&gt;Require JS&lt;/a&gt;, además, inicializa el WebSocket para recibir los mensajes desde el servidor con la actualizaciones del stock de los productos. Realizada la lista de productos se enviará un petición REST al servidor para formalizar la compra.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=main-index.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Las peticiones de compras en el servidor se procesarán por un &lt;em&gt;endpoint&lt;/em&gt; de una interfaz REST que usando un EJB con la lógica de negocio para persistir la compra en una base de datos relacional y actualizar los &lt;em&gt;stocks&lt;/em&gt;. Actualizados los &lt;em&gt;stocks&lt;/em&gt; y persistida la compra se genera un evento CDI con el hecho de que se ha producido una compra.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=PurchasesResource.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=ApplicationConfig.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=NoStockExceptionHandler.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;La aplicación irá registrando los usuarios conectados a la aplicación con el objetivo de enviarles las actualizaciones de &lt;em&gt;stock&lt;/em&gt; de los productos y con un evento CDI con la notificación de que se ha producido una compra que ha actualizado el &lt;em&gt;stock&lt;/em&gt; de algunos productos enviará los nuevos &lt;em&gt;stocks&lt;/em&gt; a los clientes con la tecnología WebSocket en un mensaje con datos en JSON que soportan los navegadores y Java EE.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=Supermarket.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=SupermarketLocal.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Usando la API de seguridad de Java EE autenticaremos al comprador o vendedor, la página se personalizará según el rol del usuario y en el servidor con la anotación &lt;a href=&#34;https://docs.oracle.com/javaee/7/api/javax/annotation/security/RolesAllowed.html&#34;&gt;RolesAllowed&lt;/a&gt; y métodos &lt;em&gt;post&lt;/em&gt;, &lt;em&gt;get&lt;/em&gt;, &lt;em&gt;list&lt;/em&gt; se limitarán las acciones que pueden realizar según sus roles, su uso se puede ver en los listados de código anteriores. Con la página de inicio de sesión se autenticará al usuario de forma programática usando &lt;code&gt;request.login(username, password);&lt;/code&gt;. Esta acción es recomendable hacerla usando el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/configurar-ssl-en-un-servidor-tomcat-jboss-wildfly-lighttpd-nginx-apache/&#34;&gt;protocolo seguro HTTPS con TLS a configurar en el servidor&lt;/a&gt; para que la contraseña se transmita cifrada entre el cliente y el servidor.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=login.html&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=LoginBean.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;La aplicación está dividida en varios módulos construidos con la &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2012/03/herramienta-de-construccion-gradle.html&#34;&gt;herramienta de automatización Gradle&lt;/a&gt; siendo una aplicación &lt;abbr title=&#34;Enterprise ARchive&#34;&gt;EAR&lt;/abbr&gt; estándar estando constituida por un módulo para los EJB, otro para la aplicación web con un &lt;abbr title=&#34;Web  ARchive&#34;&gt;WAR&lt;/abbr&gt;. Un cliente podría conectarse directamente a la aplicación sin mediación de un navegador web, esto último sería lo que emplearíamos si fuese una &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/10/introduccion-a-javafx-aplicaciones-de-escritorio-en-java/&#34;&gt;aplicación de escritorio empleando Java FX&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/cf3678d2eaa7006290c24bba68b513fa.js?file=SupermarketClient.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2016/136/aplicacion-cliente.png&#34; title=&#34;Aplicación cliente Supermarket&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2016/136/aplicacion-cliente-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Aplicación cliente Supermarket&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;El conjunto de especificaciones de Java EE proporciona una solución para la mayoría de funcionalidades que necesita una aplicación pero también podemos sustituir alguna y combinarlas con otras de las muchas librerías o &lt;em&gt;frameworks&lt;/em&gt; disponibles en la plataforma Java. Por ejemplo, como &lt;em&gt;framework&lt;/em&gt; en vez de usar Servlet y JSP o JSF podemos usar &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/libro-sobre-desarrollo-de-aplicaciones-con-apache-tapestry/&#34;&gt;Apache Tapestry&lt;/a&gt;, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/01/introduccion-y-ejemplo-basico-sobre-vertx/&#34;&gt;Vert.x&lt;/a&gt;, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/01/aplicacion-web-con-spark-framework-y-java/&#34;&gt;Spark&lt;/a&gt;, &lt;a href=&#34;https://struts.apache.org/&#34;&gt;Struts&lt;/a&gt;, &lt;a href=&#34;https://grails.org/&#34;&gt;Grails&lt;/a&gt;, &amp;hellip; dependiendo de las necesidades de la aplicación, su complejidad y nuestras preferencias. Como &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/alternativa-a-hibernate-u-orm-y-ejemplo-de-jooq/&#34;&gt;alternativa al ORM de JPA o JDBC se puede usar jOOQ&lt;/a&gt;. &lt;a href=&#34;https://www.rabbitmq.com/&#34;&gt;RabbitMQ&lt;/a&gt; en vez de JMS o &lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt; en vez de CDI, EJB y JTA.&lt;/p&gt;

&lt;p&gt;Algunos libros sobre Java EE que he leído y que me han gustado han sido los siguientes, &lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.es/gp/product/1449370179/ref=as_li_ss_tl?ie=UTF8&amp;camp=3626&amp;creative=24822&amp;creativeASIN=1449370179&amp;linkCode=as2&amp;tag=blobit-21&#34;&gt;Java EE 7 Essentials&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=as2&amp;o=30&amp;a=1449370179&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt; hace un repaso detallado pero no muy profundo para hacerse una idea bastante buena del conjunto de especificaciones de Java EE. Otro buen libro es &lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.es/gp/product/1782171983/ref=as_li_ss_tl?ie=UTF8&amp;camp=3626&amp;creative=24822&amp;creativeASIN=1782171983&amp;linkCode=as2&amp;tag=blobit-21&#34;&gt;Java EE 7 Development with WildFly&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=as2&amp;o=30&amp;a=1782171983&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt; que entra más en detalle en cada una de las especificaciones. El &lt;a href=&#34;https://docs.oracle.com/javaee/7/tutorial/&#34;&gt;tutorial oficial de Java EE 7&lt;/a&gt; también es un buen punto de partida. &lt;a target=&#34;_blank&#34; href=&#34;https://www.amazon.es/s/ref=as_li_ss_tl?_encoding=UTF8&amp;camp=3626&amp;creative=24822&amp;field-keywords=libros%20java%20ee%207&amp;linkCode=ur2&amp;tag=blobit-21&amp;url=search-alias%3Daps&#34;&gt;Libros sobre Java EE 7&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=ur2&amp;o=30&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt; hay muchos por la cantidad de tiempo que ya tiene, es recomendable leer alguno que esté actualizado a las últimas versiones.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe src=&#34;https://rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=1449370179&amp;internal=1&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
    &lt;iframe src=&#34;https://rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=1782171983&amp;internal=1&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Con Java EE 6 y 7 ciertas partes de configuración se pueden realizar con anotaciones en vez de con XML sin embargo aún no ha desaparecido completamente aunque si reducido considerablemente.&lt;/p&gt;

&lt;p&gt;Ejecutar este ejemplo require instalar previamente el servidor de aplicaciones &lt;a href=&#34;http://wildfly.org/&#34;&gt;WildFly&lt;/a&gt; e iniciarlo con &lt;code&gt;./standalone.sh -c standalone-full.xml&lt;/code&gt;. Iniciado el servidor y desplegada la aplicación con el siguiente comando de Gradle se puede acceder a ella con el navegador en la dirección &lt;em&gt;&lt;a href=&#34;https://localhost:8443/war/&#34;&gt;https://localhost:8443/war/&lt;/a&gt;&lt;/em&gt; teniendo el protocolo seguro configurado.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaEE7&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew build deploy&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;En el futuro Java EE 8 está planificado un &lt;em&gt;framework&lt;/em&gt; basado en acciones en vez de componentes como en JSF, también el soporte para &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/introduccion-al-protocolo-http-2/&#34;&gt;el protocolo HTTP/2&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/03/introduccion-y-nuevas-caracteristicas-de-java-ee-7/&#34;&gt;Introducción y nuevas características de Java EE 7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/09/ejemplo-de-api-rest-en-java-con-jax-rs-y-spring-boot/&#34;&gt;Ejemplo de API REST en Java con JAX-RS y Spring Boot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javaee/7/tutorial/&#34;&gt;Tutorial Java EE 7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;Novedades y nuevas características de Java 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/10-razones-para-seguir-usando-java/&#34;&gt;10 razones para seguir usando Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/libro-sobre-desarrollo-de-aplicaciones-con-apache-tapestry/&#34;&gt;Libro sobre desarrollo de aplicaciones con Apache Tapestry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/04/ejemplo-lista-de-tareas-con-backbone-y-react/&#34;&gt;Ejemplo lista de tareas con Backbone y React&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/alternativa-a-hibernate-u-orm-y-ejemplo-de-jooq/&#34;&gt;Alternativa a Hibernate u ORM y ejemplo de jOOQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/10/introduccion-a-javafx-aplicaciones-de-escritorio-en-java/&#34;&gt;Introducción a JavaFX, aplicaciones de escritorio en Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2012/03/herramienta-de-construccion-gradle.html&#34;&gt;Herramienta de construcción Gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-de-multiproyecto-con-gradle/&#34;&gt;Ejemplo de multiproyecto con Gradle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2016/03/introduccion-y-nuevas-caracteristicas-de-java-ee-7/</id>
        <title>Introducción y nuevas características de Java EE 7</title>        
        <updated>2016-09-17T12:00:00+02:00</updated>
        <published>2016-03-11T17:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/03/introduccion-y-nuevas-caracteristicas-de-java-ee-7/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Java sigue siendo uno de los lenguajes más usado para desarrollar aplicaciones empresariales en entidades públicas o empresas privadas. Proporciona un conjunto de especificaciones que cubren las necesidades funcionales de la mayoría de las aplicaciones y sigue evolucionando, adaptándose a las nuevas tendencias actuales y agregando nuevas funcionalidades de forma estandarizada en la plataforma. Aún así muchas entidades siguen y seguirán usando versiones anteriores a la última tanto de Java EE como de Java.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java-ee.png&#34; class=&#34;right&#34; alt=&#34;Java EE&#34; title=&#34;Java EE&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.png&#34; class=&#34;right&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Hace ya unos años, en 2013, fue publicada una nueva versión del conjunto de especificaciones que forman parte de &lt;a href=&#34;http://www.oracle.com/technetwork/es/java/javaee/overview/index.html&#34;&gt;Java EE&lt;/a&gt; con varias novedades y mejoras que aumentan la productividad. Java EE 7 es el conjunto de especificaciones a disposición de las aplicaciones empresariales que son implementadas por cada servidor de aplicaciones donde se ejecutan las &lt;em&gt;apps&lt;/em&gt; Java, estas especificaciones describen la funcionalidad y permiten que una aplicación pueda ser ejecutada en cualquier servidor que las implemente ya sea &lt;a href=&#34;http://wildfly.org/&#34;&gt;WildFly&lt;/a&gt;, &lt;a href=&#34;http://www.oracle.com/us/products/middleware/cloud-app-foundation/weblogic/overview/index.html&#34;&gt;WebLogic&lt;/a&gt; o &lt;a href=&#34;http://www-01.ibm.com/software/es/websphere/&#34;&gt;WebSphere&lt;/a&gt; sin necesidad de grandes cambios o ninguno en absoluto al proporcionar interoperabilidad entre diferentes implementaciones con el objetivo de no estar encadenado a un determinado vendedor.&lt;/p&gt;

&lt;p&gt;Java EE usa como lenguaje de programación Java que incorporando numerosas &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;novedades en la versión 8&lt;/a&gt; lo hacen seguir siendo uno de los mejores lenguajes y más usado para el desarrollo de aplicaciones empresariales. Estos son mis &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/10-razones-para-seguir-usando-java/&#34;&gt;10 razones para seguir usando Java&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;El modelo clásico de capas en la arquitectura de las aplicaciones Java EE se divide en las siguientes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cliente: normalmente se trata de un navegador pero puede ser un teléfono inteligente o una computadora de escritorio, incluso otra aplicación. Es la que presenta la información al usuario.&lt;/li&gt;
&lt;li&gt;Capa web: se comunica con el cliente y la capa de negocio. Obtiene los datos y los transforman al formato adecuado al cliente generalmente &lt;abbr title=&#34;HyperText Markup Language&#34;&gt;HTML&lt;/abbr&gt; o &lt;abbr title=&#34;JavaScript Object Notation&#34;&gt;JSON&lt;/abbr&gt;.&lt;/li&gt;
&lt;li&gt;Capa de negocio: proporciona y persiste los datos de la capa cliente y contiene la lógica de negocio de la aplicación. Se ejecuta en un servidor de aplicaciones o contenedor de &lt;em&gt;servlets&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Sistemas de información: donde se persisten los datos de la aplicación, puede ser una base de datos relacional como &lt;a href=&#34;https://www.oracle.com/&#34;&gt;Oracle&lt;/a&gt;, &lt;a href=&#34;https://www.mysql.com/&#34;&gt;MySQL&lt;/a&gt; o &lt;a href=&#34;https://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt; o una base de datos NoSQL como &lt;a href=&#34;https://redis.io/&#34;&gt;Redis&lt;/a&gt; o &lt;a href=&#34;https://www.mongodb.com/&#34;&gt;MongoDB&lt;/a&gt; u otros sistemas como &lt;a href=&#34;https://www.elastic.co/products/elasticsearch/&#34;&gt;Elasticsearch&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2016/131/aplicaciones-multicapa-javaee.png&#34; title=&#34;Aplicaciones multicapa Java EE&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2016/131/aplicaciones-multicapa-javaee.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Aplicaciones multicapa Java EE&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;En el &lt;a href=&#34;http://www.oracle.com/technetwork/java/javaee/tech/index.html&#34;&gt;listado de especificaciones&lt;/a&gt; encontramos algunas dedicadas a persistencia en base de datos (JDBC, JPA), transaccionalidad (JTA), procesamiento de peticiones HTTP (Servlets, JSF, REST), generación de HTML (Servlets, JSP, JSF), servicios web basados en REST y SOAP (JAX-RS, JAX-WS), soporte para websockets en el lado del servidor y cliente, tratamiento de JSON, validación de objetos, comunicación entre aplicaciones desacoplada con mensajes (JMS), concurrencia, servicios de nombres y descubrimiento o trabajos en lotes entre otras. Las especificaciones y versiones que componen Java EE 7 son:&lt;/p&gt;

&lt;p&gt;Tecnologías aplicaciones Web (websockets, html)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java API for WebSocket&lt;/strong&gt; 1.0 (nueva)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java API for JSON Processing&lt;/strong&gt; 1.0 (nueva)&lt;/li&gt;
&lt;li&gt;Java Servlet 3.1&lt;/li&gt;
&lt;li&gt;JavaServer Faces (JSF) 2.2&lt;/li&gt;
&lt;li&gt;Expression Language (EL) 3.0&lt;/li&gt;
&lt;li&gt;JavaServer Pages (JSP) 2.3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tecnologías aplicaciones empresariales (persistencia, transaccionalidad, inyección de dependencias, concurrencia, validación, mensajería, correos electrónicos)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Batch Applications for the Java Platform&lt;/strong&gt; 1.0 (nueva)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Concurrency Utilities for Java EE&lt;/strong&gt; 1.0 (nueva)&lt;/li&gt;
&lt;li&gt;Contexts and Dependency Injection for Java (CDI) 1.1&lt;/li&gt;
&lt;li&gt;Dependency Injection for Java 1.0&lt;/li&gt;
&lt;li&gt;Java Persistence (JPA) 2.1&lt;/li&gt;
&lt;li&gt;Java Transaction API (JTA) 1.2&lt;/li&gt;
&lt;li&gt;Java Message Service API (JMS) 2.0&lt;/li&gt;
&lt;li&gt;Enterprise JavaBeans (EJB) 3.2&lt;/li&gt;
&lt;li&gt;Bean Validation 1.1&lt;/li&gt;
&lt;li&gt;JavaMail 1.5&lt;/li&gt;
&lt;li&gt;Interceptors 1.2&lt;/li&gt;
&lt;li&gt;Java EE Connector Architecture (JCA) 1.7&lt;/li&gt;
&lt;li&gt;Common Annotations for the Java Platform 1.2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tecnologías servicios web (servicios web REST, SOAP)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java API for RESTful Web Services (JAX-RS) 2.0&lt;/li&gt;
&lt;li&gt;Java API for XML-Based Web Services (JAX-WS) 2.2&lt;/li&gt;
&lt;li&gt;Implementing Enterprise Web Services 1.3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Metadatos de servicios web para la plataforma Java&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java API for XML-Based RPC (JAX-RPC) 1.1 (Opcional)&lt;/li&gt;
&lt;li&gt;Java API for XML Messaging 1.3&lt;/li&gt;
&lt;li&gt;Java API for XML Registries (JAXR) 1.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tecnologías de gestión y seguridad (autenticación, autorización)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java Authentication Service Provider Interface for Containers (JASPIC) 1.1&lt;/li&gt;
&lt;li&gt;Java Authorization Contract for Containers (JACC) 1.5&lt;/li&gt;
&lt;li&gt;Java EE Application Deployment 1.2  (Opcional)&lt;/li&gt;
&lt;li&gt;J2EE Management 1.1&lt;/li&gt;
&lt;li&gt;Debugging Support for Other Languages 1.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Especificaciones relacionadas con Java EE en Java SE (bases de datos, XML, gestión)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java Database Connectivity (JDBC) 4.0&lt;/li&gt;
&lt;li&gt;Java Architecture for XML Binding (JAXB) 2.2&lt;/li&gt;
&lt;li&gt;Java Management Extensions (JMX) 2.0&lt;/li&gt;
&lt;li&gt;JavaBeans Activation &lt;em&gt;framework&lt;/em&gt; (JAF) 1.1&lt;/li&gt;
&lt;li&gt;Java API for XML Processing (JAXP) 1.3&lt;/li&gt;
&lt;li&gt;Streaming API for XML (StAX) 1.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Además de incorporar nuevas especificaciones y las existentes recibir mejoras entre las novedades se encuentran varias que facilitan el desarrollo posibilitando en gran medida prescindir de configuración en archivos &lt;abbr title=&#34;eXtensible Markup Language&#34;&gt;XML&lt;/abbr&gt; propensos a errores, ya se inició en Java EE 6, sustituyéndose por definiciones declarativas con anotaciones. Entre las mejoras están:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Usando la nueva funcionalidad de entrada y salida (NIO) de Java SE los &lt;em&gt;servlets&lt;/em&gt; pueden manejar comunicación asíncrona. Se permite &lt;em&gt;upgrade&lt;/em&gt; del protocolo lo que permite por ejemplo empezar una petición como HTTP/1.1 y pasar a usar HTTP/2, en WildFly esto es usado para reducir el número de puertos abiertos.&lt;/li&gt;
&lt;li&gt;JPA ahora puede invocar procedimientos almacenados, ejecutar sentencias SQL de &lt;em&gt;update&lt;/em&gt; y &lt;em&gt;delete&lt;/em&gt; masivas y controlar que entidades son cargadas de forma ansiosa (&lt;em&gt;eager&lt;/em&gt;) o vaga (&lt;em&gt;lazy&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;Se continúa avanzando en lo iniciado en versiones anteriores permitiendo usar POJO con anotaciones para facilitar el desarrollo.&lt;/li&gt;
&lt;li&gt;JTA define una nueva anotación que permite a cualquier &lt;em&gt;bean&lt;/em&gt; CDI usar transacciones.&lt;/li&gt;
&lt;li&gt;En JAX-RS se añade una API cliente para invocar &lt;em&gt;enpoints&lt;/em&gt; REST, se añade soporte para E/S asíncrona tanto para el cliente como para el servidor y &lt;em&gt;hypermedia linking&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Bean Validation permite validación a nivel de método con mejor integración en el resto de la plataforma Java EE.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los servidores de aplicaciones Java pueden implementar todas las especificaciones denominándose &lt;em&gt;full-profile&lt;/em&gt; como JBoss/WildFly, WebLogic o WebSphere. Sin embargo, algunas aplicaciones no necesitan todas las funcionalidades definidas en Java EE por lo que algunos servidores como &lt;a href=&#34;https://tomee.apache.org/&#34;&gt;TomEE&lt;/a&gt; también WildFly pueden implementar únicamente un subconjunto para la generación de contenido web, denominándose así &lt;em&gt;web-profile&lt;/em&gt;. Otros servidores como &lt;a href=&#34;https://tomcat.apache.org/&#34;&gt;Tomcat&lt;/a&gt; y &lt;a href=&#34;https://eclipse.org/jetty/&#34;&gt;Jetty&lt;/a&gt; son contenedores de &lt;em&gt;servlets&lt;/em&gt; que soportan un grupo más reducido de especificaciones de las tecnologías web (únicamente &lt;em&gt;servlet&lt;/em&gt;, JSP, EL y WebSocket) pero que siguen siendo suficientes para algunas aplicaciones o usando algunas equivalentes proporcionadas por Spring.&lt;/p&gt;

&lt;p&gt;Tecnologías &lt;em&gt;web-profile&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java Servlet API&lt;/li&gt;
&lt;li&gt;Enterprise Java Bean Lite&lt;/li&gt;
&lt;li&gt;Context and Dependency Injection&lt;/li&gt;
&lt;li&gt;Java Server Faces&lt;/li&gt;
&lt;li&gt;Java Transaction API&lt;/li&gt;
&lt;li&gt;Java Persistence API&lt;/li&gt;
&lt;li&gt;Web Socket&lt;/li&gt;
&lt;li&gt;Bean Validation&lt;/li&gt;
&lt;li&gt;JAX-RS&lt;/li&gt;
&lt;li&gt;JSON-P&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java EE 7 fué publicada hace ya varios años y muy posiblemente muchas entidades públicas y empresas privadas seguirán usando versiones más antiguas para sus aplicaciones. En el mundo empresarial las aplicaciones se han de mantener funcionando algunos lustros o décadas, para atender este requisito Java en sus 20 años se ha caracterizado por ofrecer compatibilidad hacia atrás en cada nueva versión e incorporar en el lenguaje solo aquellas mejoras que se han mostrado útiles. Esto puede hacer parecer que avanza lentamente, al menos más que otras tecnologías, y que usando las versiones anteriores hoy parezcan obsoletas, en su momento XML era uno de los formatos más empleados para realizar configuración y se usaba profusamente, hoy se están prefiriendo formatos menos verbosos y legibles como JSON y YAML. &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;Java 8 ofrece varias novedades en el lenguaje&lt;/a&gt; y Java EE 7 usando anotaciones en gran medida hace innecesarios los ficheros XML ambos siguiendo las nuevas tendencias del desarrollo y programación. Algunas personas comparan las tecnologías que prefieren con lo que recuerdan de versiones antiguas de Java o Java EE.&lt;/p&gt;

&lt;p&gt;Java EE ofrece a los desarrolladores un conjunto de especificaciones que cubren las necesidades de un gran número de aplicaciones empresariales y la plataforma ofrece garantías a largo plazo como ha demostrado que le hacen seguir siendo una de opciones preferidas para el desarrollo. La alternativa a Java EE más usada es &lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt; y sus numerosos proyectos que proporcionan funcionalidades similares sin necesidad de un contenedor &lt;em&gt;full-profile&lt;/em&gt;. En cualquiera de estas dos opciones la base de procesamiento y generación de HTML en el lado del servidor son los &lt;em&gt;servlets&lt;/em&gt; pero estos trabajan a bajo nivel, no se suelen usar directamente prefiriéndose &lt;em&gt;frameworks&lt;/em&gt; de más alto nivel como &lt;a href=&#34;http://projects.spring.io/spring-framework/&#34;&gt;Spring MVC&lt;/a&gt;, &lt;a href=&#34;http://tapestry.apache.org&#34;&gt;Apache Tapestry&lt;/a&gt;, &lt;a href=&#34;https://grails.org/&#34;&gt;Grails&lt;/a&gt;, &lt;a href=&#34;https://struts.apache.org/&#34;&gt;Struts&lt;/a&gt; u otros. Del mismo modo para el acceso a la base de datos está JDBC pero tampoco se suele usar directamente por ofrecer una API a bajo nivel prefiriendo &lt;a href=&#34;http://hibernate.org/&#34;&gt;Hibernate&lt;/a&gt;, JPA o &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/alternativa-a-hibernate-u-orm-y-ejemplo-de-jooq/&#34;&gt;jOOQ como alternativa a JDBC a los ORM&lt;/a&gt; anteriores. En el artículo &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/06/nueva-visita-a-herramientas-para-un-proyecto-java/&#34;&gt;Nueva visita a Herramientas para un proyecto Java&lt;/a&gt; comento algunas herramientas alternativas o complementarias a algunas de las especificaciones de Java EE.&lt;/p&gt;

&lt;p&gt;Algunos libros que he he leído y me han gustado para conocer las nuevas posibilidades de Java EE 7 son los siguientes, &lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.es/gp/product/B00EJX7WEQ/ref=as_li_ss_tl?ie=UTF8&amp;camp=3626&amp;creative=24822&amp;creativeASIN=B00EJX7WEQ&amp;linkCode=as2&amp;tag=blobit-21&#34;&gt;Java EE 7 Essentials&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=as2&amp;o=30&amp;a=B00EJX7WEQ&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt; que no entra en muchos detalles pero hace un repaso general de todo e incluye ejemplos de cada cosa con suficientes pormenores para empezar a programar, &lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.es/gp/product/B00RP13D9M/ref=as_li_ss_tl?ie=UTF8&amp;camp=3626&amp;creative=24822&amp;creativeASIN=B00RP13D9M&amp;linkCode=as2&amp;tag=blobit-21&#34;&gt;Java EE 7 Development with WildFly&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=as2&amp;o=30&amp;a=B00RP13D9M&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt; entra un poco más en detalle y explica varias cosas del servidor de aplicaciones WildFly, &lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.es/gp/product/B00FDLOF66/ref=as_li_ss_tl?ie=UTF8&amp;camp=3626&amp;creative=24822&amp;creativeASIN=B00FDLOF66&amp;linkCode=as2&amp;tag=blobit-21&#34;&gt;Java EE 7 Developer Handbook&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=as2&amp;o=30&amp;a=B00FDLOF66&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt; repasa igualmente Java EE 7 con numerosos ejemplos de código, finalmente también es posible consultar el &lt;a href=&#34;https://docs.oracle.com/javaee/7/JEETT.pdf&#34;&gt;tutorial oficial de Java EE 7&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe src=&#34;https://rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B00EJX7WEQ&amp;internal=1&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
    &lt;iframe src=&#34;https://rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B00RP13D9M&amp;internal=1&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
    &lt;iframe src=&#34;https://rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B00FDLOF66&amp;internal=1&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;El futuro Java EE 8 está planificado para 2017 fecha también planificada para Java 9 en la que se añadirá soporte para HTTP/2 y será la versión 4.0 de los &lt;em&gt;servlets&lt;/em&gt;. Pero no hace falta esperar hasta el 2017 para aprovecharnos hoy de las &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/introduccion-al-protocolo-http-2/&#34;&gt;ventajas de HTTP/2 tanto para clientes como servidores&lt;/a&gt;, los principales navegadores ya lo soportan y se puede &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/configurar-http-2-en-nginx-apache-httpd-wildfly-o-jetty/&#34;&gt;configurar HTTP/2 en varios servidores web y de aplicaciones Java&lt;/a&gt; como &lt;a href=&#34;https://nginx.org/&#34;&gt;Nginx&lt;/a&gt;, &lt;a href=&#34;https://httpd.apache.org/&#34;&gt;Apache HTTPD&lt;/a&gt;, WildFly o Jetty. También se ha anunciado que como alternativa a JSF basado en componentes se proporcionará una especificación que implemente el patrón MVC basado en acciones.&lt;/p&gt;

&lt;p&gt;Descrito, en el otro artículo presentaré un &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/04/aplicacion-de-ejemplo-usando-varias-especificaciones-de-java-ee-7/&#34;&gt;ejemplo de aplicación usando Java EE 7&lt;/a&gt; mostrando algunas de sus funcionalidades como JSF, WebSockets, REST, EJB o JMS usando el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/servidor-de-aplicaciones-jboss-slash-wildfly/&#34;&gt;servidor de aplicaciones WildFly&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Por cierto, como nota para técnicos, reclutadores, empresas y páginas de empleo, Java EE pasó a llamarse así en el ¡2006!, hace una década, ya es hora actualizarse también y dejar de llamarlo incorrectamente J2EE o JEE.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/04/aplicacion-de-ejemplo-usando-varias-especificaciones-de-java-ee-7/&#34;&gt;Aplicación de ejemplo usando varias especificaciones de Java EE 7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/09/ejemplo-de-api-rest-en-java-con-jax-rs-y-spring-boot/&#34;&gt;Ejemplo de API REST en Java con JAX-RS y Spring Boot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition&#34;&gt;Java EE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javaee/7/tutorial/&#34;&gt;Java EE 7 Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/java/javaee/tech/index.html&#34;&gt;Java EE 7 Technologies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;Novedades y nuevas características de Java 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/10-razones-para-seguir-usando-java/&#34;&gt;10 motivos para seguir usando Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/introduccion-al-protocolo-http-2/&#34;&gt;Introducción al protocolo HTTP/2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/02/configurar-http-2-en-nginx-apache-httpd-wildfly-o-jetty/&#34;&gt;Configurar HTTP/2 en Nginx, Apache HTTPD, WildFly o Jetty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/servidor-de-aplicaciones-jboss-slash-wildfly/&#34;&gt;Servidor de aplicaciones JBoss/WildFly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/alternativa-a-hibernate-u-orm-y-ejemplo-de-jooq/&#34;&gt;Alternativa a Hibernate u ORM y ejemplo de jOOQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/</id>
        <title>Novedades y nuevas características de Java 8</title>        
        <updated>2016-03-12T12:00:00+01:00</updated>
        <published>2014-03-21T16:03:27+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;La octava versión de Java añade numerosas novedades importantes al lenguaje. Algunas de las más destacadas son las expresiones lambdas y los streams que dotan al lenguaje de características de programación funcional pero también lo hacen en muchas construcciones de código comunes más expresivo, menos extenso y más legible. Pero hay otras novedades relevantes que detallo en el artículo como los métodos por defecto en interfaces o la nueva API para fechas.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.png&#34; class=&#34;right&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;El 18 de marzo de 2014 se publicó la nueva versión de la plataforma &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/overview/java8-2100321.html&#34;&gt;Java 8&lt;/a&gt;, Java 7 fue liberada el en julio de 2011. Java 8 incorporará varias novedades siguiendo la tendencia de otros lenguajes como la incorporación de lambdas o closures o una demandada nueva API para el manejo de fechas entre otras muchas características más. La &lt;a href=&#34;http://openjdk.java.net/projects/jdk8/features&#34;&gt;lista completa de novedades&lt;/a&gt; es bastante amplia, a continuación pondré lo que me ha parecido más destacable:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Se añaden las expresiones lambda o closures y se adapta la API para usarlas en los sitios que se pueda.&lt;/li&gt;
&lt;li&gt;Se definen nuevos perfiles compactos para dispositivos que no necesitan toda la API Java, esto es una alternativa a la modularización. Inicialmente la modularización era una característica que estaba planificada para Java 8 pero finalmente se ha aplazado a posteriores versiones.&lt;/li&gt;
&lt;li&gt;Incluido nuevo &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/index.html&#34;&gt;motor de Javascript Nashorn&lt;/a&gt; que implementa ECMAscript 5.1 y es más rápido que su predecesor Rhino.&lt;/li&gt;
&lt;li&gt;Eliminación de espacio de memoria Permanent Generation (PermGen) que pasa a llamarse Metaspace. Su tamaño
será dinámico pero no evitará fugas de memoria.&lt;/li&gt;
&lt;li&gt;Soporte para la creación de una máquina virtual menor a 3 MB.&lt;/li&gt;
&lt;li&gt;Acceso mediante reflection a los nombres de los parámetros. Mejorará la legibilidad del código que use reflection y permitirá mejorar el soporte en los IDE.&lt;/li&gt;
&lt;li&gt;Ordenación en java.util.Arrays de forma paralela.&lt;/li&gt;
&lt;li&gt;Operaciones masivas sobre colecciones tales como filter/map/reduce (streams) de forma serializada o paralela.&lt;/li&gt;
&lt;li&gt;Soporte de forma estándar para la codificación y decodificación Base64.&lt;/li&gt;
&lt;li&gt;Nueva API para Date y Time.&lt;/li&gt;
&lt;li&gt;Varias mejoras de seguridad.&lt;/li&gt;
&lt;li&gt;Se incorporan en la máquina virtual Java HotSpot características que estaban en JRockit, convergiendo ambas máquinas virtuales. Se incorpora Mission Control.&lt;/li&gt;
&lt;li&gt;Mejoras en JDBC la base para el acceso en bases de datos en Java.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://openjdk.java.net/projects/jdk8/features&#34;&gt;Otras novedades&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java 8 representa una evolución notable en este lenguaje de programación al mismo nivel o más del que supuso la versión Java 5. Aunque tengas varios años de experiencia quizá aún no has tenido oportunidad de usar todas las novedades que se han incorporado en cada versión en proyectos reales, probablemente porque los caminos de migración de las empresas son lentos y muchas siguen usando versiones antiguas en sus aplicaciones. Para conocer y aprovechar todas estas novedades de Java recomiendo los siguientes libros que son de lo mejor que he encontrado como documentación, el primer libro es &lt;a href=&#34;http://www.amazon.es/gp/product/0131872486/ref=as_li_ss_tl?ie=UTF8&amp;camp=3626&amp;creative=24822&amp;creativeASIN=0131872486&amp;linkCode=as2&amp;tag=blobit-21&#34;&gt;Thinking in Java&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=as2&amp;o=30&amp;a=0131872486&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34;&gt; que nos introduce en este lenguaje de programación desde el inicio, aunque ya conozcas o uses Java el libro &lt;a href=&#34;http://www.amazon.es/gp/product/B00B8V09HY/ref=as_li_ss_tl?ie=UTF8&amp;camp=3626&amp;creative=24822&amp;creativeASIN=B00B8V09HY&amp;linkCode=as2&amp;tag=blobit-21&#34;&gt;Effective Java&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=as2&amp;o=30&amp;a=B00B8V09HY&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34;&gt; contiene gran cantidad de información y consejos para usar Java de una forma más efectiva haciendo un repaso de las características del lenguaje que aunque no esté actualizado con las novedades que introduce Java 8 casi todo sigue siendo aplicable, el último libro es &lt;a href=&#34;http://www.amazon.es/gp/product/1617291994/ref=as_li_ss_tl?ie=UTF8&amp;camp=3626&amp;creative=24822&amp;creativeASIN=1617291994&amp;linkCode=as2&amp;tag=blobit-21&#34;&gt;Java 8 in Action&lt;/a&gt;&lt;img src=&#34;https://ir-es.amazon-adsystem.com/e/ir?t=blobit-21&amp;l=as2&amp;o=30&amp;a=1617291994&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34;&gt; que explica en mucho más detalle que lo hecho en este artículo cada una de las nuevas características de Java 8 y complementa el libro Effective Java pero aprovechando las novedades introducidas en el lenguaje.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe src=&#34;https://rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=0131872486&amp;internal=1&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
    &lt;iframe src=&#34;https://rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B00B8V09HY&amp;internal=1&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
    &lt;iframe src=&#34;https://rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=1617291994&amp;internal=1&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;A continuación algunas características de Java explicadas con un poco más de detalle.&lt;/p&gt;

&lt;h3 id=&#34;streams&#34;&gt;Streams&lt;/h3&gt;

&lt;p&gt;Los streams no son un nuevo tipo de colección son una nueva forma de recorrer las colecciones distinta a los &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&#34;&gt;Iterator&lt;/a&gt;. La ventaja de los streams es que pueden procesarse de forma serializada o paralela y proporcionan un estilo de operaciones más funcionales. Un flujo consiste un una fuente (una colección), varias operaciones intermedias (de filtrado o transformación) y una operación final que produce un resultado (suma, cuenta&amp;hellip;). Los streams son lazy de modo que las operaciones solo se realizan cuando se llama a la operación final, también son eficientes no necesitando en algunos casos procesar todos los elementos del stream para devolver el resultado final.&lt;/p&gt;

&lt;p&gt;Tradicionalmente en la API de colecciones la iteración sobre los elementos debíamos proporcionarla de forma externa. Con Java 8 podemos expresarla de forma interna, de la siguiente manera.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9689477.js?file=Stream.java&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;lambda&#34;&gt;Lambda&lt;/h3&gt;

&lt;p&gt;Esta es una de las principales novedades y que más se estaba echando de menos en Java de otros lenguajes como &lt;a href=&#34;http://groovy.codehaus.org/&#34;&gt;Groovy&lt;/a&gt; o &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt;. Las expresiones lambda son funciones que no está asociadas a un determinado nombre y que pueden pasarse como argumento a otras funciones. Tienen el siguiente aspecto:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9689477.js?file=Lambda.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;El uso de expresiones lambdas junto con el stream API proporciona a Java 8 características de programación funcional, pero sobre todo hace el código más sencillo, menos extenso, más expresivo y más legible. En las expresiones lambda de Java podemos seguir aprovechándonos de la compilación estática y del tipado fuerte.&lt;/p&gt;

&lt;h3 id=&#34;referencias-de-métodos&#34;&gt;Referencias de métodos&lt;/h3&gt;

&lt;p&gt;Todo el código desarrollado previamente a Java 8 no hace uso de las lambdas, pero con las &lt;a href=&#34;http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html&#34;&gt;referencias a métodos&lt;/a&gt; podemos usar esos métodos ya implementados como si se tratasen de funciones lambdas. Hay diferentes formas de hacer referencias a métodos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A métodos estáticos&lt;/li&gt;
&lt;li&gt;A un método de una instancia concreta&lt;/li&gt;
&lt;li&gt;A un método de instancia de una instancia arbitraria de un tipo&lt;/li&gt;
&lt;li&gt;A un constructor&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9689477.js?file=ReferenciaMetodos.java&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;interfaces-funcionales&#34;&gt;Interfaces funcionales&lt;/h3&gt;

&lt;p&gt;Una interfaz funcional es aquella que solo tiene un método abstracto (sin implementación). Algunos ejemplos de interfaces funcionales son &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html&#34;&gt;Runnable&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/awt/event/ActionListener.html&#34;&gt;ActionListener&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html&#34;&gt;Comparator&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html&#34;&gt;Callable&lt;/a&gt;. Para definir una interfaz funcional se puede usar la anotación &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html&#34;&gt;@FunctionalInterface&lt;/a&gt; y pueden representarse con una expresión lambda. En el siguiente ejemplo puede apreciarse que con las interfaces funcionales y las lambdas podemos hacer lo mismo de forma más clara, menos verbosa y con código más legible.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9689477.js?file=InterfazFuncional-1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;En Java 8 podemos hacer:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9689477.js?file=InterfazFuncional-2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Java 8 icorpora varias interfaces funcionales que puede ser usadas en expresiones lambda, entre ellas están:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html&#34;&gt;Predicate&lt;/a&gt;: función que retorna un booleano dado un argumento.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html&#34;&gt;Function&lt;/a&gt;: función que retorna un valor dado un argumento.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html&#34;&gt;Supplier&lt;/a&gt;: producen un tipo, al contrario que las funciones no tienen argumento&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html&#34;&gt;Consumer&lt;/a&gt;: representa una operación a realizarse en un argumento.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;métodos-por-defecto-en-interfaces&#34;&gt;Métodos por defecto en interfaces&lt;/h3&gt;

&lt;p&gt;Hasta ahora las interfaces en Java solo podían definir métodos pero no sus implementaciones. El problema con las interfaces es que cuando se modifican se rompen todas las clases que las usan. Esto se ha resuelto de tal forma que se puedan añadir nuevos métodos con implementación a las interfaces y ha sido necesario para incorporar las lambdas a interfaces existentes como List. En Java 8 las interfaces podrán incorporar implementaciones para algunos de sus métodos, teniendo así algo parecido a herencia múltiple.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9689477.js?file=MetodosDefault.java&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;métodos-estáticos-en-interfaces&#34;&gt;Métodos estáticos en interfaces&lt;/h3&gt;

&lt;p&gt;Además de definir métodos por defecto en las interfaces a partir de ahora podemos definir métodos estáticos. Definiendo métodos estáticos en las interfaces evitaremos tener que crear clases de utilidad. Podremos incluir en un mismo tipo (la interfaz) todos los métodos relacionados.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/9689477.js?file=MetodosStatic.java&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;mejoras-en-la-programación-asíncrona&#34;&gt;Mejoras en la programación asíncrona&lt;/h3&gt;

&lt;p&gt;Los procesadores actuales están aumentando su capacidad de proceso más a base de concurrencia proporcionando más núcleos que a base de hacerlos más rápidos en Ghz o &lt;a href=&#34;https://es.wikipedia.org/wiki/Instrucciones_por_ciclo&#34;&gt;instrucciones por ciclo&lt;/a&gt;, los lenguajes de programación tienen que adaptarse para facilitar su aprovechamiendo de forma fácil. Desde las primeras versiones de Java ya se incluía soporte para trabajar con hilos o threads sin embargo su programación es propensa a errores y difícil de depurar. Java 7 con el nuevo soporte conocido como &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html&#34;&gt;Fork/Join&lt;/a&gt; mejoraba la situación.&lt;/p&gt;

&lt;p&gt;Por otra parte para maximizar el aprovechamiento de los recursos disponibles cuando surgen bloqueos de entrada/salida como acceso a disco o comunicación por red surge la programación asíncrona. Para ello Java 8 mejora el soporte existente desde Java 7 con la clase &lt;a href=&#34;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html&#34;&gt;Future&lt;/a&gt; que permite recoger el resultado de una operación mientras se realiza otra al mismo tiempo, en Java 8 se proporciona la clase &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html&#34;&gt;CompletableFuture&lt;/a&gt; que implementa la interfaz Future. La clase CompletableFuture soporta el uso de lambdas, hace más fácil la programación concurrente y programación asíncrona que el Fork/Join y el Future respectivamente permitiendo igualmente ejecutar tareas de forma concurrente, combinar el resultado de dos tareas que se ejecutan al mismo tiempo, realizar otra tarea al terminar una prevía o por supuesto esperar a que todas las tareas concurrentes finalicen.&lt;/p&gt;

&lt;h3 id=&#34;anotaciones-en-cualquier-uso-de-tipos&#34;&gt;Anotaciones en cualquier uso de tipos&lt;/h3&gt;

&lt;p&gt;Con la introducción de anotaciones en Java 5 podemos usar anotaciones en la declaración de los tipos (definición de clases, interfaces, propiedades, métodos, &amp;hellip;). Desde ahora podremos usar las anotaciones en el uso de cualquier tipo como por ejemplo expresiones new, casts, cláusulas implements y cláusulas throws.&lt;/p&gt;

&lt;h3 id=&#34;java-time&#34;&gt;Java Time&lt;/h3&gt;

&lt;p&gt;Trabajar con fechas, horas y diferentes zonas horarias en Java tradicionalmente ha sido molesto, para tratar de mejorar la situación podíamos usar la librería JodaTime. Finalmente, después de mucho tiempo esperando a que se hiciera se va a proporcionar una mejor &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html&#34;&gt;API en el JDK 8 para trabajar con fechas, horas y zonas horarias&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2014/17/componentes-jpse8.png&#34; title=&#34;&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/2014/17/componentes-jpse8-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;futuro-java-9&#34;&gt;Futuro Java 9&lt;/h3&gt;

&lt;p&gt;Viendo el pasado reciente de Java hablar del futuro puede ser precipitado, quizá la característica más comentada sea la modularización con el proyecto conocido como &lt;a href=&#34;http://openjdk.java.net/projects/jigsaw/&#34;&gt;Jigsaw&lt;/a&gt;, pero ha sido abandonada para Java 8 según tengo entendido por ser difícil incorporarla manteniendo la compatibilidad hacia atrás, por el momento dispondremos de una solución intermedia con los compact profiles.&lt;/p&gt;

&lt;p&gt;Otro de los puntos donde parece que se pondrá énfasis es en el soporte para entornos en la nube que son en estos momentos la tendencia hacia la que evolucionan las aplicaciones.&lt;/p&gt;

&lt;h3 id=&#34;pasado-en-java-5-6-y-7&#34;&gt;Pasado en Java 5, 6 y 7&lt;/h3&gt;

&lt;p&gt;Las versiones de Java 5, 6 y 7 también incluyeron varias novedades y dado que en el ámbito empresarial la tecnología se adopta de forma lenta es posible que mucha gente (incluido yo mismo) aún desconozca cuales eran algunas de las principales novedades y características de versiones anteriores.&lt;/p&gt;

&lt;h4 id=&#34;java-7&#34;&gt;Java 7&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Project coin&lt;/li&gt;
&lt;li&gt;Strings en switchs&lt;/li&gt;
&lt;li&gt;Gestión automática de recursos en sentencias try-catch&lt;/li&gt;
&lt;li&gt;Multicatch&lt;/li&gt;
&lt;li&gt;Rethrow de excepciones más precisos&lt;/li&gt;
&lt;li&gt;Operador diamante &amp;lt;&amp;gt;&lt;/li&gt;
&lt;li&gt;Literales binarios&lt;/li&gt;
&lt;li&gt;Guiones bajos en literales numéricos&lt;/li&gt;
&lt;li&gt;Fork/Join y utilidades de concurrencia&lt;/li&gt;
&lt;li&gt;Mejoras en trabajo con archivos y carpetas&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Más en &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html&#34;&gt;Java 7 New Features and Enhancements&lt;/a&gt; y &lt;a href=&#34;http://www.javacodegeeks.com/2013/10/java7-a-look-back.html&#34;&gt;Java 7 a look back&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;java-6&#34;&gt;Java 6&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Lenguajes de scripting&lt;/li&gt;
&lt;li&gt;API para el compilador&lt;/li&gt;
&lt;li&gt;Nuevas anotaciones&lt;/li&gt;
&lt;li&gt;Nueva API para XML (StaX)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Más en &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/features-141434.html&#34;&gt;Java 6 New Features and Enhancements&lt;/a&gt; y &lt;a href=&#34;http://www.javabeat.net/introduction-to-java-6-0-new-features-part-i/&#34;&gt;Introduction to java 6 newfeatures&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;java-5&#34;&gt;Java 5&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Generics&lt;/li&gt;
&lt;li&gt;Bucle for mejorado&lt;/li&gt;
&lt;li&gt;Autoboxing/unboxing&lt;/li&gt;
&lt;li&gt;Enums&lt;/li&gt;
&lt;li&gt;Varargs&lt;/li&gt;
&lt;li&gt;Static import&lt;/li&gt;
&lt;li&gt;Anotaciones&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Más en &lt;a href=&#34;http://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html&#34;&gt;Java 5 New Features and Enhancements&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;presentación&#34;&gt;Presentación&lt;/h3&gt;

&lt;p&gt;Finalmente, una presentación muy interesante en forma de &lt;a href=&#34;https://www.youtube.com/watch?v=FTfAP29TjUk&#34;&gt;vídeo de Youtube&lt;/a&gt; en español y la &lt;a href=&#34;http://www.javahispano.org/storage/documentacion/2013-JUG-Madrid.pdf&#34;&gt;presentación de la que se habla en formato pdf&lt;/a&gt; que fue publicada en &lt;a href=&#34;http://www.javahispano.org/portada/2014/3/10/video-y-presentacion-de-la-charla-sobre-java-8.html&#34;&gt;JavaHispano&lt;/a&gt;, en él se habla de muchas de las novedades y de algunas futuras en Java 9.&lt;/p&gt;

&lt;div class=&#34;media media-video&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;https://www.youtube.com/embed/FTfAP29TjUk?rel=0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;hr&gt;

&lt;p&gt;En los &lt;a href=&#34;http://docs.oracle.com/javase/tutorial/&#34;&gt;tutoriales de Java&lt;/a&gt; hay algunos de estos puntos más ampliados y algunos apartados no comentados en esta entrada. Otros artículos muy completos son &lt;a href=&#34;http://winterbe.com/posts/2014/03/16/java-8-tutorial/&#34;&gt;Java 8 Tutorial&lt;/a&gt; y &lt;a href=&#34;http://www.techempower.com/blog/2013/03/26/everything-about-java-8/&#34;&gt;Everything about Java 8&lt;/a&gt;, en el apartado de referencia al final de la entrada hay algún enlace más digno de lectura.&lt;/p&gt;

&lt;p&gt;Java es usado ampliamente en entornos empresariales ya sean públicos o privados, pequeños o grandes que con las &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/03/introduccion-y-nuevas-caracteristicas-de-java-ee-7/&#34;&gt;especificaciones de Java EE 7&lt;/a&gt; proporcionan a las aplicaciones un conjunto de funcionalidades estadarizadas con las que tendremos posibilidad de elegir la implementación que mejor consideremos no encadenándonos a un determinado vendedor.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://openjdk.java.net/projects/jdk8/&#34;&gt;JDK 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javacodegeeks.com/2013/10/java8.html&#34;&gt;Java 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://winterbe.com/posts/2014/03/16/java-8-tutorial/&#34;&gt;Java 8 Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zeroturnaround.com/rebellabs/java-8-explained-default-methods/&#34;&gt;Java 8 Explained Default Methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javacodegeeks.com/2013/10/introduction-to-java-lambdas.html&#34;&gt;Introduction to Java lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zeroturnaround.com/rebellabs/java-8-revealed-lambdas-default-methods-and-bulk-data-operations/&#34;&gt;Java 8 revealed, lambdas, default methods and bulk data operations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javacodegeeks.com/2013/07/lambdas-coming-to-a-java-8-near-you.html&#34;&gt;Lambdas coming to a Java 8 near you&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://viralpatel.net/blogs/java-8-default-methods-tutorial/&#34;&gt;Java 8 default methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://unpocodejava.wordpress.com/2014/01/22/novedades-relevantes-java-8/&#34;&gt;Novedades relevantes Java 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javacodegeeks.com/2014/03/the-optional-type-api.html&#34;&gt;The optional type API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.techempower.com/blog/2013/03/26/everything-about-java-8/&#34;&gt;Everything about Java 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javacodegeeks.com/2014/03/8-new-features-for-java-8.html&#34;&gt;8 new features for java 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javacodegeeks.com/2014/03/happy-8th-birthday-java.html&#34;&gt;Happy 8th birthday Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javacodegeeks.com/2014/01/compiling-lambda-expressions-scala-vs-java-8.html&#34;&gt;Compiling lambda expressions scala vs Java 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.dzone.com/articles/java-8-permgen-metaspace&#34;&gt;Java 8 PermGen to metaspace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="java"/>
            
                <category term="programacion"/>
            
                <category term="software"/>
            
                <category term="planeta-linux"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    
</feed>
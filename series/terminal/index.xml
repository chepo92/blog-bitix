<?xml version="1.0" encoding="utf-8"?><feed version="2.0" xmlns="http://www.w3.org/2005/Atom"><id>https://picodotdev.github.io/blog-bitix/series/terminal/</id><title type="text">Blog Bitix</title><subtitle>Recent content on Blog Bitix</subtitle><updated>2016-07-10T11:00:00+02:00</updated><author><name>picodotdev</name></author><generator>Hugo</generator><icon>https://picodotdev.github.io/blog-bitix/assets/images/logotipos/hugo.png</icon><logo>https://picodotdev.github.io/blog-bitix/assets/images/logotipos/hugo.png</logo><rights>https://creativecommons.org/licenses/by-sa/4.0/</rights><entry><id>https://picodotdev.github.io/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/</id><title>Guía básica del intérprete de comandos Bash</title><updated>2016-07-10T11:00:00+02:00</updated><published>2016-07-10T11:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>La línea de comandos sigue siendo una poderosa herramienta que aunque menos intuitiva que una interfaz gráfica permite hacer las tareas de forma más sencilla, directa y que se puede automatizar. Conocer las opciones del intérprete de comandos es básico para aprovechar su máximo potencial. Desde las combinaciones de teclas hasta los &lt;em>scripts&lt;/em> o archivos de lotes. Tuberías y redirecciones, comandos con ejecución condicional, variables, interpolación de cadenas, &lt;em>scrtips&lt;/em>, argumentos, funciones, &lt;em>for&lt;/em>, &lt;em>switch&lt;/em>, &lt;em>if&lt;/em>, comparaciones, &amp;hellip;&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/linux.svg" class="right " width="200" alt="Linux" title="Linux"/>
&lt;/div>
&lt;div class="logotypes" style="float: right; clear: right;">
&lt;img src="assets/images/logotipos/gnu.svg" class="right " width="200" alt="GNU" title="GNU"/>
&lt;/div>
&lt;p>Automatizar las tareas que realizamos permite ahorrarnos el tiempo de tener que hacerlo manualmente y evita los errores que se puede producir. En &lt;a href="https://www.gnu.org/">GNU&lt;/a>/&lt;a href="https://www.linux.com/">Linux&lt;/a> el uso de la terminal no es algo extraño y muchas tareas son realizadas más fácil y rápido con un comando que con un programa con interfaz gráfica, además tiene la ventaja de que puede automatizarse creando un &lt;em>script&lt;/em> &lt;a href="https://es.wikipedia.org/wiki/Bash">Bash&lt;/a>.&lt;/p>
&lt;p>El intérprete de comandos Bash junto con la combinación de otros programas proporcionados por la parte GNU de los sistemas Linux presentes en la mayoría de las distribuciones por defecto es suficiente para automatizar la mayor parte de tareas que necesitemos. Conociendo las posibilidades que ofrece junto con &lt;a href="https://picodotdev.github.io/blog-bitix/2016/06/combinacion-de-teclas-para-copiar-y-pegar-en-la-terminal/">las combinaciones de teclas del intérprete Bash y del emulador de la terminal&lt;/a> junto con &lt;a href="https://picodotdev.github.io/blog-bitix/2016/07/comandos-basicos-de-gnu-linux/">los comandos básicos de GNU&lt;/a> subiremos un nivel en el manejo de los sistemas GNU/Linux.&lt;/p>
&lt;h3 id="tuberías-y-redirecciones">Tuberías y redirecciones&lt;/h3>
&lt;p>Al ejecutar un comando podemos querer encadenar la salida de un comando con la entrada de otro, mediante una tubería. Uno de los puntos de la filosofía de los programas de los sistemas Unix es que realicen una o pocas tareas pero que lo hagan muy bien. Usando varios programas especializados en una tarea podemos juntarlos como si fuese piezas de Lego para realizarla tarea compleja que necesitamos, encadenando la salida de un comando como la entrada del siguiente.&lt;/p>
&lt;p>Una de las cosas buenas de Bash es que está presente por defecto en la mayoría de las distribuciones Linux y si no es este intérprete de comandos será otro similar por lo que no necesitamos instalar nada más adicional para usarlo. Aún así si necesitaremos algo más potente que Bash como lenguaje de programación podemos optar por un lenguaje de programación como &lt;a href="https://www.python.org/">Python&lt;/a> para realizar los &lt;em>scripts&lt;/em> aunque necesitaremos instalar su paquete y las dependencias que los &lt;em>scripts&lt;/em> usen.&lt;/p>
&lt;p>Por ejemplo, dada una lista de concursantes habilitados en un sorteo podemos obtener 3 ganadores de forma aleatoria con la combinación de los siguientes comandos. El comando &lt;code>grep&lt;/code> permite aplicar una expresión regular a cada línea de un fichero que si la cumple es enviada a la salida, &lt;code>shuf&lt;/code> reordena las líneas de forma aleatoria y con la opción &lt;code>-n 3&lt;/code> emite las 3 primeras. Los comandos proporcionados por GNU en los sistemas Linux proporcionan multitud de comandos como estos muy útiles, combinándolos conseguimos tareas más capaces que lo que son los comandos individualmente.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ grep &lt;span class="s2">&amp;#34;^[^#]&amp;#34;&lt;/span> sorteo.txt &lt;span class="p">|&lt;/span> shuf -n &lt;span class="m">3&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/sorteo-1.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/sorteo-1.sh" target="_blank">sorteo-1.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/sorteo.png" title="Sorteo implementado con dos comandos de GNU/Linux" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/sorteo-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Sorteo implementado con dos comandos de GNU/Linux&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Por defecto la salida estándar de un comando es la terminal pero podemos redirigirla a un fichero con la opción &lt;code>&amp;gt;&lt;/code>.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ grep &lt;span class="s2">&amp;#34;^[^#]&amp;#34;&lt;/span> sorteo.txt &lt;span class="p">|&lt;/span> shuf -n &lt;span class="m">3&lt;/span> &amp;gt; ganadores.txt
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/sorteo-2.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/sorteo-2.sh" target="_blank">sorteo-2.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Además de la salida estándar los programas tienen la salida de errores que podemos redirigir con &lt;code>2&amp;gt;&lt;/code>, si queremos redirigir la salida estándar y la de error podemos usar la redirección &lt;code>&amp;amp;&amp;gt;&lt;/code>. Tanto la opción &lt;code>&amp;gt;&lt;/code> y &lt;code>2&amp;gt;&lt;/code> crean un fichero con la salida redirigida, si en vez de sobreescribir el contenido del archivo queremos añadirlo al final podemos hacer la redirección con &lt;code>&amp;gt;&amp;gt;&lt;/code>.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ grep &lt;span class="s2">&amp;#34;^[^#]&amp;#34;&lt;/span> sorteo.txt &lt;span class="p">|&lt;/span> shuf -n &lt;span class="m">3&lt;/span> &amp;gt;&amp;gt; ganadores.txt
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/sorteo-3.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/sorteo-3.sh" target="_blank">sorteo-3.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;h3 id="múltiples-comandos">Múltiples comandos&lt;/h3>
&lt;p>Si necesitamos ejecutar dos comandos seguidos podemos introducirlos en la misma línea en vez de individualmente, ejecutar un comando si el anterior se ha ejecutado correctamente con &lt;code>&amp;amp;&amp;amp;&lt;/code> o al contrario ejecutar un comando si el anterior ha fallado con &lt;code>||&lt;/code>. Si en la ubicación de trabajo que estamos existe un directorio no se podrá crear otro con el mismo nombre, dependiendo de las opciones de encadenamiento según el resultado del comando anterior se ejecutará o no el siguiente comando.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ mkdir directorio &lt;span class="p">;&lt;/span> mkdir directorio &lt;span class="p">;&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Directorio creado&amp;#34;&lt;/span>
$ mkdir directorio &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> mkdir directorio &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Directorio creado&amp;#34;&lt;/span>
$ mkdir directorio &lt;span class="p">&amp;amp;&lt;/span>&amp;gt; /dev/null &lt;span class="o">||&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;La creación de directorio ha fallado&amp;#34;&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/multiples-comandos.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/multiples-comandos.sh" target="_blank">multiples-comandos.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/multiples-comandos.png" title="Múltiples comandos en la misma línea" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/multiples-comandos-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Múltiples comandos en la misma línea&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;h3 id="variables-e-interpolación-de-cadenas">Variables e interpolación de cadenas&lt;/h3>
&lt;p>Podemos definir variables locales en el &lt;em>script&lt;/em> o exportarlas para que estén accesibles en otros procesos e incluso interpolarlas en cadenas de la siguiente forma:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nv">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;picodotdev&amp;#34;&lt;/span>
&lt;span class="nb">export&lt;/span> &lt;span class="nv">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;picodotdev&amp;#34;&lt;/span>
$ &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$name&lt;/span>
$ &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="s2">Hola &lt;/span>&lt;span class="nv">$name&lt;/span>&lt;span class="s2">!&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/variables-1.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/variables-1.sh" target="_blank">variables-1.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>También podemos interpolar la salida de un comando dentro de una cadena:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="s2">Hola &lt;/span>&lt;span class="nv">$name&lt;/span>&lt;span class="s2">! a las `date`&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/variables-2.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/variables-2.sh" target="_blank">variables-2.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/variables.png" title="Interpolación en cadenas de variables y comandos" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/variables-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Interpolación en cadenas de variables y comandos&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;h3 id="invocaciones-de-comandos-anteriores">Invocaciones de comandos anteriores&lt;/h3>
&lt;p>Con el comando &lt;code>history&lt;/code> podemos ver el historial completo de comandos que hemos ejecutado con anterioridad. Al lado de cada comando vemos un identificador numérico que podemos usar para ejecutarlo de nuevo con &lt;code>![identificador]&lt;/code>. Con el siguiente historial podemos ejecutar el comando con identificador 512 indicando una exclamación y el identificador, &lt;code>!512&lt;/code>. Si queremos ejecutar el último comando introducido podemos usar la doble exclamación &lt;code>!!&lt;/code>. Si queremos ejecutar el último comando completo de cierto comando podemos usar &lt;code>![comando]&lt;/code> en vez de su identificador.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/history.png" title="Historial de comandos" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/history-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Historial de comandos&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Hay más &lt;a href="http://www.softpanorama.org/Scripting/Shellorama/bash_command_history_reuse.shtml">formas de ejecutar comandos del historial&lt;/a>. Si quisieramos invocar un comando del historial cambiando algún argumento podemos hacer una búsqueda en orden inverso con &lt;kbd>Ctrl+r&lt;/kbd>.&lt;/p>
&lt;h3 id="scripts">Scripts&lt;/h3>
&lt;p>Los &lt;em>scritps&lt;/em> son archivos de texto con permisos de ejecución interpretados por Bash u otro intérprete que ejecuta los comandos del &lt;em>script&lt;/em>, es la forma de automatizar varios comandos. Al inicio de los &lt;em>scripts&lt;/em> se suele incluir el &lt;a href="https://es.wikipedia.org/wiki/Shebang">shebang&lt;/a> donde se indica el programa encargado de interpretar el &lt;em>script&lt;/em>, puede ser Bash o un programa escrito en un lenguaje de programación como &lt;a href="https://www.python.org/">Python&lt;/a>. Se puede indicar de varias formas pero las preferidas son las siguientes:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">#!/usr/bin/env python&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/scripts-1.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/scripts-1.sh" target="_blank">scripts-1.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Una vez escrito el &lt;em>script&lt;/em> antes de ejecutarlo debemos darle permisos de ejecución con el comando &lt;code>chmod&lt;/code>:&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ chmod +x script.sh
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/scripts-2.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/scripts-2.sh" target="_blank">scripts-2.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;h3 id="argumentos">Argumentos&lt;/h3>
&lt;p>Al igual que los comandos pueden recibir opciones y argumentos los &lt;em>scripts&lt;/em> también, hacer uso de ellos son mediante las siguientes variables:&lt;/p>
&lt;ul>
&lt;li>$0: contiene nombre del &lt;em>script&lt;/em>.&lt;/li>
&lt;li>$1: primer argumento, $2 segundo argumento, &amp;hellip;&lt;/li>
&lt;li>$#: número de argumentos al invocar el &lt;em>script&lt;/em>.&lt;/li>
&lt;li>$*: todos los argumentos al invocar el &lt;em>script&lt;/em>.&lt;/li>
&lt;li>$?: valor del estado de salida del último comando ejecutado. Normalmente se usa &lt;em>0&lt;/em> para los comandos ejecutados correctamente y &lt;em>1&lt;/em> para los que han terminado incorrectamente.&lt;/li>
&lt;/ul>
&lt;h3 id="funciones-for-switch-if-comparaciones">Funciones, &lt;em>for&lt;/em>, &lt;em>switch&lt;/em>, &lt;em>if&lt;/em>, comparaciones&lt;/h3>
&lt;p>En los &lt;em>scripts&lt;/em> Bash se pueden definir funciones para reutilizar parte del &lt;em>script&lt;/em>. Pueden incluir argumentos.&lt;/p>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="k">function&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="s2">Hola &lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">!&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">function&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;picodotdev&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
Además los _scripts_ pueden incluir ciertas sentencias para controlar el flujo de ejecución del _script_ con expresiones condicionales, bucles y comparaciones.
&lt;span class="k">for&lt;/span> file in /etc/* &lt;span class="k">do&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$file&lt;/span>
&lt;span class="k">done&lt;/span>
&lt;span class="o">{&lt;/span>&lt;span class="o">{&lt;/span>% gist &lt;span class="nv">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span> &lt;span class="nv">file&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span> %&lt;span class="o">}&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="nb">getopts&lt;/span> &lt;span class="s2">&amp;#34;:df&amp;#34;&lt;/span> opt&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nv">$opt&lt;/span> in
d&lt;span class="o">)&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Opción «d» indicada&amp;#34;&lt;/span>
&lt;span class="p">;&lt;/span>&lt;span class="p">;&lt;/span>
f&lt;span class="o">)&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Opción «f» indicada&amp;#34;&lt;/span>
&lt;span class="p">;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="se">\?&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="s2">Opción inválida: -&lt;/span>&lt;span class="nv">$OPTARG&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="p">;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">esac&lt;/span>
&lt;span class="k">done&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/funciones-1.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/funciones-1.sh" target="_blank">funciones-1.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/opciones.png" title="Opciones de un script" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/opciones-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Opciones de un script&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;div class="code">
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> -f &lt;span class="nv">$1&lt;/span> &lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;El archivo existe.&amp;#34;&lt;/span>
&lt;span class="k">fi&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="highlight-meta">
&lt;span class="raw">&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/funciones-2.sh" target="_blank">view raw&lt;/a>&lt;/span>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/code/funciones-2.sh" target="_blank">funciones-2.sh&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>Los &lt;em>scripts&lt;/em> de Bash suelen manejar ficheros y disponemos de una buena cantidad de opciones para comparar:&lt;/p>
&lt;ul>
&lt;li>[ -a FILE ]: verdadero si el fichero existe.&lt;/li>
&lt;li>[ -d FILE ]: verdadero si el fichero existe y es un directorio.&lt;/li>
&lt;li>[ -e FILE ]: verdadero si el fichero existe.&lt;/li>
&lt;li>[ -f FILE ]: verdadero si el fichero existe y es un fichero regular.&lt;/li>
&lt;li>[ -h FILE ]: verdadero si el fichero existe y es un enlace simbólico.&lt;/li>
&lt;li>[ -r FILE ]: verdadero si el fichero existe y se puede leer.&lt;/li>
&lt;li>[ -s FILE ]: verdadero si el fichero existe y su tamaño es mayor que cero.&lt;/li>
&lt;li>[ -w FILE ]: verdadero si el fichero existe y se puede escribir.&lt;/li>
&lt;li>[ -x FILE ]: verdadero si el fichero existe y se puede ejecutar.&lt;/li>
&lt;li>&lt;p>[ -N FILE ]: verdadero si el fichero existe y ha sido modificado desde la última lectura.&lt;/p>&lt;/li>
&lt;li>&lt;p>[ FILE1 -nt FILE2 ]: verdadero si &lt;em>FILE1&lt;/em> ha sido modificado más recientemente que &lt;em>FILE2&lt;/em> o si &lt;em>FILE1&lt;/em> existe y &lt;em>FILE2&lt;/em> no.&lt;/p>&lt;/li>
&lt;li>&lt;p>[ FILE1 -ot FILE2 ]: verdadero si &lt;em>FILE2&lt;/em> ha sido modificado más recientemente que &lt;em>FILE1&lt;/em> o si &lt;em>FILE2&lt;/em> existe y &lt;em>FILE1&lt;/em> no.&lt;/p>&lt;/li>
&lt;li>&lt;p>[ FILE1 -ef FILE2 ]: verdadero si &lt;em>FILE1&lt;/em> y &lt;em>FILE2&lt;/em> se refieren al mismo dispositivo y número de inodo.&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>Y otros menos comunes:&lt;/p>
&lt;ul>
&lt;li>[ -S FILE ]: verdadero si el fichero existe y es un &lt;em>socket&lt;/em>.&lt;/li>
&lt;li>[ -b FILE ]: verdadero si el fichero existe y es un fichero especial de bloques.&lt;/li>
&lt;li>[ -c FILE ]: verdadero si el fichero existe y es un fichero especial de caracteres.&lt;/li>
&lt;li>[ -g FILE ]: verdadero si el fichero existe y su bit &lt;em>SGID&lt;/em> está establecido.&lt;/li>
&lt;li>[ -k FILE ]: verdadero si el fichero existe y su bit &lt;em>sticky&lt;/em> está establecido.&lt;/li>
&lt;li>[ -p FILE ]: verdadero si el fichero existe y es una tubería con nombre (FIFO).&lt;/li>
&lt;li>[ -t FD ]: verdadero si el descriptor de fichero está abierto y refiere a una terminal.&lt;/li>
&lt;li>[ -u FILE ]: verdadero si el fichero existe y su bit &lt;em>SUID&lt;/em> está establecido.&lt;/li>
&lt;li>[ -O FILE ]: verdadero si el fichero existe y el ID del usuario efectivo es su propietario.&lt;/li>
&lt;li>[ -G FILE ]: verdadero si el fichero existe y el ID del grupo efectivo es su propietario.&lt;/li>
&lt;li>[ -L FILE ]: verdadero si el fichero existe y es un enlace simbólico.&lt;/li>
&lt;/ul>
&lt;p>Y algunos otros:&lt;/p>
&lt;ul>
&lt;li>[ -o OPTIONNAME ]: verdadero si la copión &lt;em>OPTIONNAME&lt;/em> está activa.&lt;/li>
&lt;li>[ -z STRING ]: verdadero si la longitud de &lt;em>STRING&lt;/em> es cero.&lt;/li>
&lt;li>[ -n STRING ] o [ STRING ]: verdadero si la longitud de &lt;em>STRING&lt;/em> no es cero.&lt;/li>
&lt;li>[ STRING1 == STRING2 ]: verdadero si las cadenas son iguales.&lt;/li>
&lt;li>[ STRING1 != STRING2 ]: verdadero si las cadenas no son iguales.&lt;/li>
&lt;li>[ STRING1 &amp;lt; STRING2 ]: verdadero si léxicamente &lt;em>STRING1&lt;/em> se ordena antes que &lt;em>STRING2&lt;/em> en el &lt;em>locale&lt;/em> actual.&lt;/li>
&lt;li>[ STRING1 &amp;gt; STRING2 ]: verdadero si léxicamente &lt;em>STRING1&lt;/em> se ordena después que &lt;em>STRING2&lt;/em> en el &lt;em>locale&lt;/em> actual.&lt;/li>
&lt;li>[ ARG1 OP ARG2 ]: donde &lt;em>OP&lt;/em> es un operador de entre &lt;em>-eq&lt;/em>, &lt;em>-ne&lt;/em>, &lt;em>-lt&lt;/em>, &lt;em>-le&lt;/em>, &lt;em>-gt&lt;/em> o &lt;em>-ge&lt;/em>. Estas operaciones aritméticas binarias retornan verdadero si &lt;em>ARG1&lt;/em> es igual a, no igual a, menor que, menor que o igual, mayor que o mayor que o igual que &lt;em>ARG2&lt;/em>, respectivamente. &lt;em>ARG1&lt;/em> y &lt;em>ARG2&lt;/em> son valores enteros.&lt;/li>
&lt;/ul>
&lt;p>Las expresiones anteriores se pueden combinar:&lt;/p>
&lt;ul>
&lt;li>[ ! EXPR ]: verdadero si &lt;em>EXPR&lt;/em> es false.&lt;/li>
&lt;li>[ ( EXPR ) ]: retorna el valor de &lt;em>EXPR&lt;/em>, puede usarse para cambiar la precedencia de operadores.&lt;/li>
&lt;li>[ EXPR1 -a EXPR2 ]: verdadero si ambas &lt;em>EXPR1&lt;/em> y &lt;em>EXPR2&lt;/em> son verdadero, operador &lt;em>and&lt;/em>.&lt;/li>
&lt;li>[ EXPR1 -o EXPR2 ]: verdadero si alguna de &lt;em>EXPR1&lt;/em> y &lt;em>EXPR2&lt;/em> son verdadero, operador &lt;em>or&lt;/em>.&lt;/li>
&lt;/ul>
&lt;h3 id="control-de-trabajos">Control de trabajos&lt;/h3>
&lt;p>El comando &lt;code>jobs&lt;/code> obtenemos una lista de trabajos que se está ejecutando junto con su identificador y estado, con la combinación de teclas &lt;kbd>Ctrl+z&lt;/kbd> dejamos el proceso actual detenido y en segundo plano, con &lt;code>fg&lt;/code> lo devolvemos a primer plano y si estaba detenido se continua su ejecución, con &lt;code>bg&lt;/code> si estaba detenido continua su ejecución en segundo plano.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/trabajos.png" title="Trabajos en primer y segundo plano" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/guia-basica-del-interprete-de-comandos-bash/images/trabajos-thumb.png" width="289"/>&lt;/a>
&lt;figcaption>Trabajos en primer y segundo plano&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Esta guía es parte de un tema de los explicados en el completo libro sobre la administración sobre sistemas Unix, &lt;a href="https://amzn.to/29vctVP">UNIX and Linux System Administration Handbook&lt;/a>. Un libro con cantidad de temas para conocer más en detalle nuestros sistemas basados en la filosofía Unix. Casi 1300 páginas de documentación con información básica y detallada que deberíamos obligarnos a conocer. Redes, seguridad, virtualización, hospedaje web, copias de seguridad, procesos periódicos, instalación de software, control de procesos y muchos temas más. Otros buenos documentos son &lt;a href="http://www.tldp.org/LDP/abs/html/index.html">Advanced Bash-Scripting Guide&lt;/a> y
el siguiente &lt;a href="http://bash.cyberciti.biz/guide/Main_Page">manual de Bash&lt;/a>.&lt;/p>
&lt;div class="media-amazon" style="text-align: center;">
&lt;iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=0131480057&amp;linkId=28302f39b86c5d07ee3db2bc5752c2ed&amp;internal=1">&lt;/iframe>
&lt;/div>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="http://www.howtogeek.com/howto/44997/how-to-use-bash-history-to-improve-your-command-line-productivity/">How To Use Bash History to Improve Your Command-Line Productivity&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-codigo"/><category term="planeta-linux"/><category term="software-libre"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2016/07/comandos-basicos-de-gnu-linux/</id><title>Comandos básicos de GNU/Linux</title><updated>2016-07-10T10:00:00+02:00</updated><published>2016-07-03T12:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/07/comandos-basicos-de-gnu-linux/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Conociendo los comandos y sus opciones podemos realizar una tarea que nos ahorre una gran cantidad de tiempo si lo hubiésemos hecho manualmente o con una interfaz gráfica. La parte GNU de las mayoría distribuciones Linux proporcionan una buena cantidad de comandos útiles interesantes de conocer que están a nuestra disposición para cuando los necesitemos.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/linux.svg" class="right " width="200" alt="Linux" title="Linux"/>
&lt;/div>
&lt;div class="logotypes" style="float: right; clear: right;">
&lt;img src="assets/images/logotipos/gnu.svg" class="right " width="200" alt="GNU" title="GNU"/>
&lt;/div>
&lt;p>El proyecto &lt;abbr title="GNU Is Not Unix">&lt;a href="https://www.gnu.org/">GNU&lt;/a>&lt;/abbr> promovido por la &lt;abbr title="Free Software Foundation">&lt;a href="https://www.fsf.org/">FSF&lt;/a>&lt;/abbr> y que se usa en la mayoría de las distribuciones Linux proporciona muchos comandos útiles. Las más modernas interfaces gráficas no superan a la línea de comandos para realizar las tareas de forma rápida, directa y con la posibilidad de automatización. Conociendo las &lt;a href="https://picodotdev.github.io/blog-bitix/2016/06/atajos-de-teclado-basicos-de-la-terminal-en-gnu-linux/">combinaciones de teclas de nuestro emulador de terminal y del intérprete de comandos&lt;/a> dominaremos aún más el uso de la consola, también mejoraremos si conocemos las posibilidades que ofrece un &lt;a href="https://www.gnu.org/software/bash/manual/bashref.html">intérprete de comandos como bash&lt;/a>.&lt;/p>
&lt;p>En la colección de &lt;a href="https://www.gnu.org/software/coreutils/manual/coreutils.html">utilidades que forman el núcleo de GNU&lt;/a> hay una lista completa junto con su documentación. A continuación una lista no exhaustiva de algunos comandos que disponemos pero son de los más utilizados (algunos más que otros) que tengamos que usar directamente o en &lt;em>scripts&lt;/em> de bash. En orden alfabético.&lt;/p>
&lt;ul>
&lt;li>&lt;em>apropos&lt;/em>: muestra una lista de comandos relacionados con una palabra.&lt;/li>
&lt;li>&lt;em>at&lt;/em>: programa una tarea a una determinada hora.&lt;/li>
&lt;li>&lt;em>cal&lt;/em>: emite en la terminal un calendario.&lt;/li>
&lt;li>&lt;em>cat&lt;/em>: concatena archivos y emite sus contenidos en la salida.&lt;/li>
&lt;li>&lt;em>cd&lt;/em>: cambia el directorio de trabajo actual de la terminal.&lt;/li>
&lt;li>&lt;em>chgrp&lt;/em>: cambia el grupo propietario del archivo.&lt;/li>
&lt;li>&lt;em>chmod&lt;/em>: cambia los permisos del archivo.&lt;/li>
&lt;li>&lt;em>chown&lt;/em>: cambia el usuario propietario del archivo.&lt;/li>
&lt;li>&lt;em>cp&lt;/em>: copia el contenido de un fichero a otro nuevo o sobrescribiendo uno existente.&lt;/li>
&lt;li>&lt;em>date&lt;/em>: muestra la fecha del sistema.&lt;/li>
&lt;li>&lt;em>df&lt;/em>: muestra el uso del disco.&lt;/li>
&lt;li>&lt;em>du&lt;/em>: estima el espacio usado por los archivos.&lt;/li>
&lt;li>&lt;em>echo&lt;/em>: emite un mensaje en la salida.&lt;/li>
&lt;li>&lt;em>find&lt;/em>: busca archivos en la jerarquía de directorios.&lt;/li>
&lt;li>&lt;em>free&lt;/em>: muestra el estado de la memoria del sistema.&lt;/li>
&lt;li>&lt;em>grep&lt;/em>: aplica expresiones regulares al contenido y filtra las que que no la cumplen.&lt;/li>
&lt;li>&lt;em>head&lt;/em>: muestra el principio del contenido.&lt;/li>
&lt;li>&lt;em>history&lt;/em>: lista el historial de comandos introducidos con anterioridad.&lt;/li>
&lt;li>&lt;em>htop&lt;/em>: monitor de procesos similar a &lt;em>top&lt;/em> un poco más avanzado y más personalizable.&lt;/li>
&lt;li>&lt;em>kill&lt;/em>: envía una señal a un proceso, por ejemplo de terminación.&lt;/li>
&lt;li>&lt;em>less&lt;/em>: permite el movimiento adelante y atrás del contenido a visualizar cuando es más grande que el tamaño de la terminal.&lt;/li>
&lt;li>&lt;em>ln&lt;/em>: crea enlaces simbólicos.&lt;/li>
&lt;li>&lt;em>lsblk&lt;/em>: lista los dispositivos de bloques.&lt;/li>
&lt;li>&lt;em>ls&lt;/em>: lista ficheros y directorios del sistema de ficheros. Con diferentes opciones podremos visualizar además de los nombres más información como permisos, fecha de última modificación y tamaño.&lt;/li>
&lt;li>&lt;em>man&lt;/em>: muestra la página de manual de un comando. En las páginas de manual incluye una descripción de lo que hace el comando, sus opciones, parámetros y en algunos casos ejemplos de uso.&lt;/li>
&lt;li>&lt;em>md5sum&lt;/em>: calcula el &lt;em>hash&lt;/em> &lt;em>md5&lt;/em> de un contenido.&lt;/li>
&lt;li>&lt;em>mkdir&lt;/em>: crea un directorio opcionalmente con toda la ruta de carpetas hasta él si no existen.&lt;/li>
&lt;li>&lt;em>mv&lt;/em>: renombra un archivo y/ lo cambia de directorio.&lt;/li>
&lt;li>&lt;em>printf&lt;/em>: formatea un mensaje y lo emite en la salida.&lt;/li>
&lt;li>&lt;em>ps&lt;/em>: lista los procesos del sistema e información relacionada.&lt;/li>
&lt;li>&lt;em>pwd&lt;/em>: emite en la salida el directorio actual de trabajo.&lt;/li>
&lt;li>&lt;em>rmdir&lt;/em>: elimina un directorio&lt;/li>
&lt;li>&lt;em>sha1sum&lt;/em>: calcula el &lt;em>hash&lt;/em> &lt;em>sh1&lt;/em> de un contenido.&lt;/li>
&lt;li>&lt;em>shuf&lt;/em>: emite las líneas de entrada en la salida de forma aleatoria.&lt;/li>
&lt;li>&lt;em>sort&lt;/em>: ordena líneas de texto.&lt;/li>
&lt;li>&lt;em>tail&lt;/em>: muestra el final del contenido pudiendo verlo en tiempo real cuando se añade más. Útil para monitorizar la salida de un archivo de trazas.&lt;/li>
&lt;li>&lt;em>tar&lt;/em>: guarda varios archivos en uno solo.&lt;/li>
&lt;li>&lt;em>tmux&lt;/em>: permite ver varias terminales dividiendo el área disponible verticalmente u horizontalmente, desconectarse de una terminal sin dejar de ejecutar los comandos que estuviesen corriendo y volver a conectarse de nuevo.&lt;/li>
&lt;li>&lt;em>top&lt;/em>: monitor de procesos del sistema. Muestra el uso de cada núcleo del procesador, memoria usada, libre, procesos del sistema y su consumo de recursos de CPU y memoria. Un poco más básico que &lt;em>htop&lt;/em>.&lt;/li>
&lt;li>&lt;em>touch&lt;/em>: cambia la fecha de acceso y modificación a la actual del sistema, opcionalmente si el fichero no existe se crea con contenido vacío.&lt;/li>
&lt;li>&lt;em>uniq&lt;/em>: informa o emite las ocurrencias repetidas.&lt;/li>
&lt;li>&lt;em>vim&lt;/em>: es un editor de texto avanzado.&lt;/li>
&lt;li>&lt;em>xargs&lt;/em>: construye comandos y los ejecuta con las líneas de la entrada.&lt;/li>
&lt;li>&lt;em>yes&lt;/em>: repite indefinidamente el mensaje &lt;em>yes&lt;/em> en la salida hasta que se finaliza. Útil para ejecutar comandos de forma desatendida que requieren la intervención del usuario.&lt;/li>
&lt;li>&lt;em>zip&lt;/em>: crea un archivador comprimiendo el contenido de los archivos.&lt;/li>
&lt;/ul>
&lt;p>En sus respectivas páginas de manual, &lt;code>man [comando]&lt;/code>, podemos conocer las opciones que permite cada uno de ellos junto con algunos ejemplos de uso. Estos comandos se pueden combinar haciendo que la salida de un comando sea la entrada del siguiente mediante tuberías, por ejemplo, para ordenar un fichero de texto y mostrar las 5 primeras líneas con los comandos &lt;em>sort&lt;/em> y &lt;em>head&lt;/em> usaríamos &lt;code>sort fichero.txt | head -5&lt;/code>. Precisamente el comando &lt;code>sort&lt;/code> es lo que he utilizado para ordenar alfabéticamente la lista de comandos anterior.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/comandos-basicos-de-gnu-linux/images/comandos-gnu-linux.png" title="Uso de comandos GNU/Linux" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/comandos-basicos-de-gnu-linux/images/comandos-gnu-linux-thumb.png" width="300"/>&lt;/a>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/comandos-basicos-de-gnu-linux/images/man-grep.png" title="Página de manual de grep" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/07/comandos-basicos-de-gnu-linux/images/man-grep-thumb.png" width="300"/>&lt;/a>
&lt;figcaption>Uso de comandos GNU/Linux y página del manual de grep&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/software/coreutils/manual/coreutils.html">Manual GNU Coreutils&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/bash/manual/bashref.html">Manual de referencia bash&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.tecmint.com/useful-linux-commands-for-newbies/">20 Useful Commands for Linux Newbies&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-codigo"/><category term="planeta-linux"/><category term="software-libre"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2016/06/combinacion-de-teclas-para-copiar-y-pegar-en-la-terminal/</id><title>Combinación de teclas para copiar y pegar en la terminal</title><updated>2016-06-24T15:30:00+02:00</updated><published>2016-06-24T15:30:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/06/combinacion-de-teclas-para-copiar-y-pegar-en-la-terminal/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>En vez de usar el botón derecho de ratón y hacer clic sobre el menú desplegable para realizar la acción de copiar y pegar se puede emplear el teclado con una combinación de teclas para realizar estas mismas acciones. Si estas operaciones se realizan frecuentemente la combinación de teclas es más rápido y sencillo.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/linux.svg" class="right " width="200" alt="Linux" title="Linux"/>
&lt;/div>
&lt;div class="logotypes" style="float: right; clear: right;">
&lt;img src="assets/images/logotipos/gnu.svg" class="right " width="200" alt="GNU" title="GNU"/>
&lt;/div>
&lt;p>Usar una combinación de teclas para realizar alguna acción es más rápido que usar el ratón. Si se trata de una acción que realizamos frecuentemente podemos ahorrar bastante tiempo. Yo trabajo bastante con la terminal de GNOME y hasta ahora no sabía cómo copiar y pegar con una combinación de teclas del teclado.&lt;/p>
&lt;p>La combinación de teclas estandarizada para copiar y pegar en cualquier aplicación tanto en Linux como en Windows es &lt;kbd>Ctrl+c&lt;/kbd> para copiar y &lt;kbd>Ctrl+v&lt;/kbd> para pegar de y al portapapeles. En la terminal (al menos en la de GNOME) cambia ligeramente y hay que usar &lt;kbd>Ctrl+Shift+c&lt;/kbd> para copiar y &lt;kbd>Ctrl+Shift+v&lt;/kbd> para pegar el texto en la posición del cursor.&lt;/p>
&lt;p>Con el ratón deberemos seleccionar el texto pero con la combinación de teclas nos evitaremos pulsar el botón derecho del ratón, desplazarnos hasta la opción &lt;em>Copiar&lt;/em> del menú y finalmente hacer clic en él, para pegar la acción usaremos el mismo menú pero pulsando en la opción &lt;em>Pegar&lt;/em>.&lt;/p>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/06/combinacion-de-teclas-para-copiar-y-pegar-en-la-terminal/images/gnome-terminal.png" title="Menú para copiar y pegar en la terminal de GNOME" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/06/combinacion-de-teclas-para-copiar-y-pegar-en-la-terminal/images/gnome-terminal-thumb.png" width="650"/>&lt;/a>
&lt;figcaption>Menú para copiar y pegar en la terminal de GNOME&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Esto no es algo nada vital pero si es algo que usamos frecuentemente puede hacernos más fácil la tarea y ahorrarnos tiempo al igual que conocer y usar los &lt;a href="https://picodotdev.github.io/blog-bitix/2016/06/atajos-de-teclado-basicos-de-la-terminal-en-gnu-linux/">atajos de teclado básicos de la terminal en GNU/Linux&lt;/a>.&lt;/p>
&lt;div class="reference">
Referencia:&lt;br>
&lt;p>&lt;a href="http://askubuntu.com/questions/211292/a-terminal-which-provides-select-to-copy-and-right-click-to-paste">A terminal which provides select-to-copy and right-click-to-paste&lt;/a>&lt;/p>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-codigo"/><category term="planeta-linux"/><category term="software-libre"/></entry><entry><id>https://picodotdev.github.io/blog-bitix/2016/06/atajos-de-teclado-basicos-de-la-terminal-en-gnu-linux/</id><title>Atajos de teclado básicos de la terminal en GNU/Linux</title><updated>2016-06-17T18:00:00+02:00</updated><published>2016-06-17T18:00:00+02:00</published><link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2016/06/atajos-de-teclado-basicos-de-la-terminal-en-gnu-linux/"/><author><name>picodotdev</name></author><content type="html">
&lt;p>&lt;strong>Aprender las combinaciones de teclas de aquellas aplicaciones que usamos frecuentemente y durante mucho tiempo nos ayuda a hacer las cosas en menos tiempo y de forma más sencilla. Cada aplicación tiene los suyos propios, en este artículo los de la terminal con el intérprete de comandos &lt;em>bash&lt;/em> para GNU/Linux.&lt;/strong>&lt;/p>
&lt;div class="logotypes" style="float: right;">
&lt;img src="assets/images/logotipos/linux.svg" class="right " width="200" alt="Linux" title="Linux"/>
&lt;/div>
&lt;div class="logotypes" style="float: right; clear: right;">
&lt;img src="assets/images/logotipos/gnu.svg" class="right " width="200" alt="GNU" title="GNU"/>
&lt;/div>
&lt;p>Si no conoces lo que estás buscando una interfaz gráfica es una buena forma de descubrir cosas, si conoces exactamente lo que buscas y si lo tienes que hacer de forma repetida es tediosa y lenta. La terminal en &lt;a href="https://www.gnu.org/">GNU&lt;/a>/&lt;a href="https://www.linux.com/">Linux&lt;/a> sigue siendo una poderosa herramienta para realizar multitud de tareas. Entre sus ventajas son realizar la tareas de forma mucho más directa y simple que con una interfaz gráfica o la posibilidad de automatizar tareas repetitivas en un &lt;em>script bash&lt;/em> o en un lenguaje de programación como &lt;a href="https://www.python.org/">Python&lt;/a>. Entre las desventajas de la línea de comandos está que no suele ser tan intuitiva como una interfaz gráfica. Dadas las ventajas de la terminal o línea de comandos para algunas personas su uso es muy frecuente y en GNU/Linux es común tener que usarla en algún momento, conocer las combinaciones de teclas que podemos usar la tarea será más fácil y la haremos rápidamente.&lt;/p>
&lt;p>En el intérprete de la terminal &lt;a href="https://es.wikipedia.org/wiki/Bash">bash&lt;/a> podemos usar las siguientes combinaciones de teclas:&lt;/p>
&lt;ul>
&lt;li>&lt;kbd>Ctrl+a&lt;/kbd>: lleva el cursor al inicio de la línea de comandos.&lt;/li>
&lt;li>&lt;kbd>Ctrl+e&lt;/kbd>: lleva el cursor al final de la línea de comandos.&lt;/li>
&lt;li>&lt;kbd>Ctrl+l&lt;/kbd>: limpia la terminal, similar a lo que hace el comando &lt;code>clear&lt;/code>.&lt;/li>
&lt;li>&lt;kbd>Ctrl+u&lt;/kbd>: limpia desde la posición del cursor hasta el inicio de la línea. Si se está al final limpia la línea entera.&lt;/li>
&lt;li>&lt;kbd>Ctrl+k&lt;/kbd>: limpia desde la posición del cursor hasta el final de la línea. Si se está al inicio limpia la línea entera.&lt;/li>
&lt;li>&lt;kbd>Ctrl+h&lt;/kbd>: hace lo mismo que la tecla &lt;code>backspace&lt;/code>, borra el caracter inmediatamente anterior a la posición del cursor.&lt;/li>
&lt;li>&lt;kbd>Ctrl+w&lt;/kbd>: borra la palabra inmediatamente antes del cursor.&lt;/li>
&lt;li>&lt;kbd>Alt+d&lt;/kbd> o &lt;kbd>Esc+d&lt;/kbd>: borra la palabra siguiente después del cursor.&lt;/li>
&lt;li>&lt;kbd>Ctrl+p&lt;/kbd>: establece la línea de comandos con el último comando introducido.&lt;/li>
&lt;li>&lt;kbd>Ctrl+r&lt;/kbd>: inicia la búsqueda de comandos usados anteriormente, tecleando parte de un comando usos anteriores que hayamos realizado incluyendo las opciones y parámetros. Hecha una búsqueda pulsando de nuevo la combinación de teclas encontraremos coincidencias anteriores.&lt;/li>
&lt;li>&lt;kbd>Ctrl+c&lt;/kbd>: termina el proceso que se esté ejecutando, útil para recuperar el control del sistema.&lt;/li>
&lt;li>&lt;kbd>Ctrl+d&lt;/kbd>: sale de la terminal, similar al comando &lt;code>exit&lt;/code>.&lt;/li>
&lt;li>&lt;kbd>Ctrl+z&lt;/kbd>: suspende la ejecución del proceso que se está ejecutando y lo pone en segundo plano, con el comando &lt;code>fg&lt;/code> podremos volver a continuar su ejecución.&lt;/li>
&lt;li>&lt;kbd>Ctrl+t&lt;/kbd>: intercambia la posición de los dos caracteres antes del cursor, útil para corregir malos tecleos.&lt;/li>
&lt;li>&lt;kbd>Esc+t&lt;/kbd>: intercambia la posición de las dos palabras antes del cursor, útil para corregir malos tecleos.&lt;/li>
&lt;li>&lt;kbd>Alt+f&lt;/kbd>: mueve el cursor al inicio de la palabra siguiente de la línea, lo mismo que &lt;kbd>Ctrl+right&lt;/kbd> en la terminal de GNOME.&lt;/li>
&lt;li>&lt;kbd>Alt+b&lt;/kbd>: mueve el cursor al inicio de la palabra anterior de la línea, lo mismo que &lt;kbd>Ctrl+left&lt;/kbd> en la terminal de GNOME.&lt;/li>
&lt;li>&lt;kbd>Tab&lt;/kbd>: autocompleta comandos o rutas de directorios o archivos.&lt;/li>
&lt;/ul>
&lt;p>Poner comandos en segundo plano es útil si un proceso deja el sistema sin respuesta o queremos introducir otro antes de que termine el primero. Con tres comandos podemos &lt;a href="http://www.tldp.org/LDP/abs/html/x9644.html">manejar los procesos en primer y segundo plano&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>&lt;code>jobs&lt;/code>: con este comando podremos ver la lista de procesos en segundo plano, con información de si están detenidos/suspendidos o en ejecución además del identificativo asignado para usar en los comandos &lt;code>fg&lt;/code> y &lt;code>bg&lt;/code>.&lt;/li>
&lt;li>&lt;code>fg&lt;/code>: pone en primer plano un proceso, si estaba suspendido reanuda su ejecución.&lt;/li>
&lt;li>&lt;code>bg&lt;/code>: continua la ejecución del proceso pero lo deja en segundo plano, si emite contenido a la terminal se mostrará y quizá nos moleste al seguir trabajando.&lt;/li>
&lt;li>&lt;code>kill&lt;/code>: con el identificativo del proceso en segundo plano y un símbolo de porcentaje por delante podemos enviar la señal de terminado del proceso. Ejemplo, &lt;code>kill %1&lt;/code>.&lt;/li>
&lt;li>Añadiendo un &lt;em>ampersand&lt;/em>, &lt;code>&amp;amp;&lt;/code>, al final del comando pondremos el comando en ejecución pero en segundo plano directamente.&lt;/li>
&lt;/ul>
&lt;p>Las anteriores combinaciones de teclas son del intérprete de comandos bash, el emulador de terminal que usemos también incorpora algunas combinaciones de teclas más. En el caso del emulador del terminal de &lt;a href="https://www.gnome.org/">GNOME&lt;/a> podemos usar las siguientes combinaciones muy útiles:&lt;/p>
&lt;ul>
&lt;li>&lt;kbd>Ctrl+Shift+f&lt;/kbd>: abre un diálogo para hacer una búsqueda de texto en la salida de la terminal.&lt;/li>
&lt;li>&lt;kbd>Ctrl+Shift+g&lt;/kbd>: busca la siguiente ocurrencia de la búsqueda previa en la terminal.&lt;/li>
&lt;li>&lt;kbd>Ctrl+Shift+h&lt;/kbd>: busca la anterior ocurrencia de la búsqueda previa en la terminal.&lt;/li>
&lt;li>&lt;kbd>Ctrl+Shift+c&lt;/kbd>: copia el texto seleccionado de la terminal al portapapeles.&lt;/li>
&lt;li>&lt;kbd>Ctrl+Shift+v&lt;/kbd>: pega el texto del portapapeles en la línea de comandos.&lt;/li>
&lt;li>&lt;kbd>Up&lt;/kbd>: establece en la línea de comandos el comando anterior del historial, igual que &lt;kbd>Ctrl+p&lt;/kbd>.&lt;/li>
&lt;li>&lt;kbd>Down&lt;/kbd>: establece en la línea de comandos el siguiente comando del historial.&lt;/li>
&lt;li>&lt;kbd>Left Mouse&lt;/kbd>: selecciona líneas de texto de la terminal.&lt;/li>
&lt;li>&lt;kbd>Ctrl+Left Mouse&lt;/kbd>: selecciona bloques de texto de la terminal.&lt;/li>
&lt;/ul>
&lt;div class="media" style="text-align: center;">
&lt;figure>
&lt;a href="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/06/atajos-de-teclado-basicos-de-la-terminal-en-gnu-linux/images/gnome-terminal.png" title="Terminal de GNOME con el intérprete de comandos bash" data-gallery>&lt;img src="https://picodotdev.github.io/blog-bitix/blog-bitix/2016/06/atajos-de-teclado-basicos-de-la-terminal-en-gnu-linux/images/gnome-terminal-thumb.png" width="650"/>&lt;/a>
&lt;figcaption>Terminal de GNOME con el intérprete de comandos bash&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;div class="reference">
Referencia:&lt;br>
&lt;ul>
&lt;li>&lt;a href="http://www.howtogeek.com/howto/ubuntu/keyboard-shortcuts-for-bash-command-shell-for-ubuntu-debian-suse-redhat-linux-etc/">Keyboard Shortcuts for Bash (Command Shell for Ubuntu, Debian, Suse, Redhat, Linux, etc)&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.thegeekstuff.com/2010/05/unix-background-job/">Bg, Fg, &amp;amp;, Ctrl-Z – 5 Examples to Manage Unix Background Jobs&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://serverfault.com/questions/430153/block-select-on-a-linux-console">Block select on a Linux console&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.tldp.org/LDP/abs/html/x9644.html">Job Control Commands&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></content><category term="gnu-linux"/><category term="planeta-codigo"/><category term="planeta-linux"/><category term="software-libre"/></entry></feed>
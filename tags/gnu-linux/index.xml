<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://picodotdev.github.io/blog-bitix/tags/gnu-linux/</id>
    <title type="text">Blog Bitix</title>
    <subtitle>Recent content on Blog Bitix</subtitle>
    <updated>2017-05-13T09:00:00+02:00</updated>
    <author><name>pico.dev</name></author>
    <generator>Hugo</generator>
    <icon>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</icon>
    <logo>https://picodotdev.github.io/blog-bitix//assets/images/logotipos/hugo.png</logo>
    <rights>https://creativecommons.org/licenses/by-sa/4.0/</rights>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/05/descargar-e-instalar-la-distribucion-ubuntu-de-gnu-linux-paso-a-paso-desde-cero/</id>
        <title>Descargar e instalar la distribución Ubuntu de GNU/Linux paso a paso desde cero</title>        
        <updated>2017-05-13T09:00:00+02:00</updated>
        <published>2017-05-13T09:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/05/descargar-e-instalar-la-distribucion-ubuntu-de-gnu-linux-paso-a-paso-desde-cero/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Pasar de usar Windows a usar una distribución GNU/Linux es un paso difícil para muchos usuarios, algunos usuarios desconocen incluso que tienen la posibilidad de usar un sistema operativo alternativo a Windows. O si lo conocen pueden creer erróneamente que instalar una distribución GNU/Linux es muy complicado&amp;hellip; sabiendo algunas casas por lo demás es tan sencillo instalar como el sistema operativo Windows ya que muchas distribuciones incluyen una interfaz gráfica en su instalador y el proceso consiste en responder unas pocas preguntas, introducir algunos datos y pulsar varios botones siguiente.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/ubuntu.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Ubuntu&#34; title=&#34;Ubuntu&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/linux.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Linux&#34; title=&#34;Linux&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/gnu.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;GNU&#34; title=&#34;GNU&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Quizá hayas oído hablar de Linux o &lt;a href=&#34;https://www.gnu.org/&#34;&gt;GNU&lt;/a&gt;/&lt;a href=&#34;http://www.linux.com/&#34;&gt;Linux&lt;/a&gt; como alternativa al sistema operativo de Microsoft &lt;a href=&#34;http://www.microsoft.com/es-es/windows/&#34;&gt;Windows&lt;/a&gt; y sientes curiosidad por probarlo y adentrarte con ello en el mundo del software libre. Si estás leyendo esta guía y te es necesaria para instalar una de las muchas distribuciones de GNU/Linux entiendo que necesitas ayuda para saber como instalarlo desde cero, paso a paso y empezando desde lo más básico.&lt;/p&gt;

&lt;p&gt;En GNU/Linux para cada tarea que un usuario quiera realizar hay múltiples opciones entre las que elegir, desde tareas ofimáticas como &lt;a href=&#34;http://www.libreoffice.org/&#34;&gt;LibreOffice&lt;/a&gt;, navegadores web como &lt;a href=&#34;https://www.mozilla.org/es-ES/firefox/new/&#34;&gt;Firefox&lt;/a&gt; o &lt;a href=&#34;https://www.google.es/chrome/browser/desktop/&#34;&gt;Chrome&lt;/a&gt;, mensajería instantánea como &lt;a href=&#34;https://wiki.gnome.org/action/show/Apps/Empathy&#34;&gt;Empathy&lt;/a&gt;, correo electrónico como &lt;a href=&#34;https://wiki.gnome.org/Apps/Evolution/&#34;&gt;Evolution&lt;/a&gt;, &lt;a href=&#34;https://www.mozilla.org/es-ES/thunderbird/&#34;&gt;Thunderbird&lt;/a&gt; o &lt;a href=&#34;https://wiki.gnome.org/Apps/Geary&#34;&gt;Geary&lt;/a&gt;, reproductores de música o vídeo como &lt;a href=&#34;https://www.videolan.org/vlc/&#34;&gt;VLC&lt;/a&gt;, visor de imágenes y archivos PDF, edición fotográfica como &lt;a href=&#34;https://www.gimp.org/&#34;&gt;GIMP&lt;/a&gt;, edición de vídeo como &lt;a href=&#34;http://www.openshot.org/&#34;&gt;OpenShot&lt;/a&gt;, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/08/22-plus-buenos-juegos-en-gnu-linux/&#34;&gt;algunos juegos destacables&lt;/a&gt;, &amp;hellip; en todos los casos hay un programa de software libre por el que no hay que pagar una licencia ni buscar &lt;em&gt;cracks&lt;/em&gt; para activar el software que son fuente de virus y problemas de seguridad. Y ya desde hace mucho tiempo en GNU/Linux el hardware es reconocido y usable en su mayor parte desde el primer momento incluyendo la tarjeta gráfica, sonido, red, bluetooth, wifi, HDMI, USB, &amp;hellip; aunque alguno puede necesitar instalar sus controladores de dispositivo.&lt;/p&gt;

&lt;p&gt;Debes saber es en GNU/Linux hay muchas versiones o distribuciones, muchas desarrolladas por personas sin ánimo de lucro que se agrupan formando comunidades y otras que tienen el soporte de una empresa pero que a los usuarios les ofrece la distribución sin ningún coste ni necesidad de adquirir licencias. Una distribución está formada por el conjunto de programas de software o paquetes, repositorios de paquetes y gestor de paquetes. Hay muchas distribuciones, y muchas son cientos, pero no más de 10 con una cuota de uso dentro de las distros significativa.&lt;/p&gt;

&lt;p&gt;El paso de Windows a GNU/Linux significa usar un nuevo entorno y es algo que muchos de los usuarios que hoy somos de GNU/Linux hemos dado en algún momento, yo empecé por pasar &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2010/03/de-windows-arch-linux.html&#34;&gt;De Windows a Arch Linux&lt;/a&gt; y aún me mantengo &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/08/de-arch-linux-a-arch-linux/&#34;&gt;De Arch Linux a Arch Linux&lt;/a&gt;. GNU/Linux tiene sus puntos fuertes y algunos para los usuarios de escritorio menos fuertes, principalmente debido a no ser el sistema mayoritario los fabricantes tienen más en cuenta a Windows cuando lanzan un nuevo producto, en el caso de los juegos triple AAA o la excesiva fragmentación por la cantidad de opciones. En cualquier caso muchas distribuciones GNU/Linux son tan fáciles de usar como Windows o &lt;a href=&#34;http://www.apple.com/macos/&#34;&gt;macOS&lt;/a&gt; y tan o más capaces que estos.&lt;/p&gt;

&lt;p&gt;Lo primero que debes hacer es &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/10/elegir-una-distribucion-gnu-linux-segun-el-usuario-uso-o-equipo/&#34;&gt;decidir la distribución que quieres instalar&lt;/a&gt;, según tus preferencias y necesidades. Para los usuarios que van a tener su primer contacto con GNU/Linux algunas de las recomendadas son &lt;a href=&#34;http://www.ubuntu.com/&#34;&gt;Ubuntu&lt;/a&gt; o &lt;a href=&#34;https://elementary.io/es/&#34;&gt;elementaryOS&lt;/a&gt;. En este artículo explicaré como instalar Ubuntu en su versión 16.04 &lt;abbr title=&#34;Long Term Support&#34;&gt;LTS&lt;/abbr&gt;, los pasos son similares para elementaryOS ya que es una distribución que se basa en Ubuntu.&lt;/p&gt;

&lt;p&gt;Las versiones LTS de Ubuntu tienen un soporte de largo plazo de 5 años para corrección de errores y fallos de seguridad y se publican cada dos años siendo la siguiente LTS la 18.04 que se publicará en marzo del año 2018. Salvo que estés afectado por &lt;em&gt;versionitis&lt;/em&gt; y quieras tener las últimas versiones de los programas la versión LTS es más recomendable.&lt;/p&gt;

&lt;h3 id=&#34;requisitos-mínimos&#34;&gt;Requisitos mínimos&lt;/h3&gt;

&lt;p&gt;Los &lt;a href=&#34;https://help.ubuntu.com/community/Installation/SystemRequirements&#34;&gt;requisitos mínimos de Ubuntu&lt;/a&gt; son bastante bajos para cualquier sistema de unos pocos años. Aunque en la memoria es recomendable tener al menos 2 GiB o incluso 4 GiB.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Procesador de 700 MHz (Intel Celeron o mejor)&lt;/li&gt;
&lt;li&gt;Memoria del sistema 512 MiB RAM&lt;/li&gt;
&lt;li&gt;5 GB de espacio de almacenamiento (o memoria USB, tarjeta de memoria o unidad externa)&lt;/li&gt;
&lt;li&gt;Gráficos con resolución de al menos 1024x768&lt;/li&gt;
&lt;li&gt;Unidad CD/DVD o puerto USB&lt;/li&gt;
&lt;li&gt;Acceso a internet es recomendable&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;copia-de-seguridad&#34;&gt;Copia de seguridad&lt;/h3&gt;

&lt;p&gt;Al instalar Ubuntu todos los datos que tuviese el equipo se perderán por lo que si quieres conservarlos debes copiarlos previamente a un disco duro externo o memoria USB de la capacidad que necesiten tus archivos, una vez finalizada la instalación de Ubuntu puedes recuperarlos y copiarlos al equipo de nuevo.&lt;/p&gt;

&lt;h3 id=&#34;descarga-de-ubuntu&#34;&gt;Descarga de Ubuntu&lt;/h3&gt;

&lt;p&gt;Antes de iniciar la instalación hay que descargar la imágen ISO de la versión de Ubuntu que queramos instalar. En la &lt;a href=&#34;http://www.ubuntu.com/&#34;&gt;página oficial de Ubuntu&lt;/a&gt; se puede descargar de forma directa con el navegador o vía P2P en la red de compartición de archivos torrent. Ubuntu a su vez proporciona varias versiones de su distribución donde varía el entorno de escritorio que también debes elegir según tus preferencias, hay varias posibilidades &lt;a href=&#34;http://unity.ubuntu.com/&#34;&gt;Unitiy&lt;/a&gt; (que en la versión 18.04 será sustituida por GNOME), &lt;a href=&#34;https://www.gnome.org/&#34;&gt;GNOME&lt;/a&gt; y &lt;a href=&#34;https://www.kde.org/&#34;&gt;KDE&lt;/a&gt; aunque recomiendo una de las dos últimas. Cualquiera de ellas con un aspecto gráfico muy cuidado, intuitivas y fáciles de usar. La opción más similar al entorno de escritorio de Windows es KDE con la que te encontrarás bastante cómodo al usarla si provienes de Windows.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ubuntu.com/&#34;&gt;Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://unity.ubuntu.com/&#34;&gt;Ubuntu Unity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ubuntugnome.org/&#34;&gt;Ubuntu GNOME&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kubuntu.org/&#34;&gt;Ubuntu KDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ubuntu.com/download/ubuntu-flavours&#34;&gt;Más sabores de Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;creación-del-medio-de-instalación&#34;&gt;Creación del medio de instalación&lt;/h3&gt;

&lt;p&gt;Para una mayor velocidad de instalación es mejor usar una memoria USB de al menos 8 GiB de capacidad en vez un CD o DVD que son más lentos y algunos equipos nuevos ya ni siquiera incorporan porque están en desuso con la aparición de las memorias USB. La memoria debe estar vacía ya que se perderán todos sus datos. Con el &lt;a href=&#34;https://rufus.akeo.ie/&#34;&gt;programa Rufus para Windows&lt;/a&gt; seleccionado el archivo de la imagen ISO descargada y la unidad USB se crea el medio de instalación, en la siguiente página está explicado como &lt;a href=&#34;https://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows&#34;&gt;crear una memoria USB arrancable en Windows&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hay que conectar una memoria USB, seleccionarla, seleccionar el archivo de la imagen ISO de Ubuntu y pulsar el botón &lt;em&gt;Empezar&lt;/em&gt;, al cabo de unos minutos la memoria estará lista para empezar a instalar Ubuntu.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/rufus.png&#34; title=&#34;Creación de medio de instalación en memoria USB desde Windows&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/rufus-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Creación de medio de instalación en memoria USB dese Windows&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;iniciar-el-sistema-con-el-medio-de-instalación&#34;&gt;Iniciar el sistema con el medio de instalación&lt;/h3&gt;

&lt;p&gt;Con el equipo apagado y la memoria USB contactada hay que iniciar el equipo para que se inicie desde la memoria USB. La forma de hacer que el equipo se inicie desde la memoria USB depende de cual sea el fabricante. Pulsando una tecla dependiendo de caso como F2, F8, F10, F12, ESC u otra se puede entrar en la BIOS o seleccionar el medio de instalación. La BIOS es una zona de configuración donde se modifican algunos parámetros del equipo muy importantes con lo que hay que tener cuidado de que se modifica para evitar comportamientos anómalos, a pesar de todo suele ser bastante intuitiva y si es un equipo reciente incluso con interfaz gráfica.&lt;/p&gt;

&lt;p&gt;Según el fabricante e incluso modelos de la misma fabricante la tecla de acceso para iniciar desde el medio de instalación varía:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Acer: F2 o Delete&lt;/li&gt;
&lt;li&gt;Asus: F2 o F10&lt;/li&gt;
&lt;li&gt;Dell: F2, F1, Delete, F12 o F3&lt;/li&gt;
&lt;li&gt;HP: F10 o Esc&lt;/li&gt;
&lt;li&gt;Lenovo: F1 o F2&lt;/li&gt;
&lt;li&gt;Sony: F2, F3, F1 o tecla assist&lt;/li&gt;
&lt;li&gt;Toshiba: F2, F1, Esc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En las siguientes páginas puedes encontrar varias posibles teclas para entrar en la BIOS y cambiar la unidad de inicio del sistema según la marca, &lt;a href=&#34;http://www.makeuseof.com/tag/enter-bios-computer/&#34;&gt;I&lt;/a&gt;, &lt;a href=&#34;https://www.lifewire.com/bios-setup-utility-access-keys-for-major-bios-manufacturers-2624461&#34;&gt;II&lt;/a&gt; y &lt;a href=&#34;https://www.lifewire.com/bios-setup-utility-access-keys-for-popular-computer-systems-2624463&#34;&gt;III&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Puede ser el caso de que cuando se inicia el equipo muestre un mensaje con la tecla que hay que pulsar si hay que probar hasta dar con ella. Después de pulsar la tecla de encendido poco después o según se muestra un logotipo es cuando hay que pulsar la tecla.&lt;/p&gt;

&lt;p&gt;Si tu sistema tiene una BIOS de tipo UEFI, cualquier equipo del último lustro su BIOS será de este tipo, se debe &lt;a href=&#34;https://help.ubuntu.com/community/UEFI&#34;&gt;desactivar la opción llamada &lt;em&gt;Secure Boot&lt;/em&gt;&lt;/a&gt; que utiliza Windows como medida de seguridad pero que no está soportada aún en GNU/Linux.&lt;/p&gt;

&lt;h3 id=&#34;instalación-de-ubuntu&#34;&gt;Instalación de Ubuntu&lt;/h3&gt;

&lt;p&gt;Una vez iniciado el programa que guía en la instalación de Ubuntu hay que responder a algunas preguntas e introducir algunos pocos datos y en cuestión de menos de una hora el equipo ya está listo para empezar a usarse. En el artículo he utilizado la versión 16.04 LTS.&lt;/p&gt;

&lt;p&gt;El asistente de instalación pregunta:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;El idioma.&lt;/li&gt;
&lt;li&gt;Si se quieren descargar las actualizaciones (recomendable) y software para reproducir mp3, flash así como controladores para la tarjeta gráfica y wifi.&lt;/li&gt;
&lt;li&gt;Borrar el contenido del disco duro y si se quieren cifrar los datos del dispositivo de almacenamiento.&lt;/li&gt;
&lt;li&gt;La clave para cifrar los datos del dispositivo de almacenamiento.&lt;/li&gt;
&lt;li&gt;Una confirmación para proceder a borrar el disco duro e iniciar la instalación.&lt;/li&gt;
&lt;li&gt;La zona horaria del usuario y la disposición del teclado.&lt;/li&gt;
&lt;li&gt;El nombre del equipo, del usuario y la contraseña para iniciar sesión.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los asistentes de instalación utilizan el entorno de escritorio del sabor que se está instalando pero los pasos son similares y piden la misma información.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-01.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-01-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-02.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-02-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-03.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-03-thumb.png&#34;/&gt;&lt;/a&gt;
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-04.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-04-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-05.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-05-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-06.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-06-thumb.png&#34;/&gt;&lt;/a&gt;
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-07.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-07-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-08.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-08-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-09.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-09-thumb.png&#34;/&gt;&lt;/a&gt;
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-10.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-10-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-11.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-11-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-12.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-12-thumb.png&#34;/&gt;&lt;/a&gt;
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-13.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-13-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-14.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-14-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-15.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-15-thumb.png&#34;/&gt;&lt;/a&gt;
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-16.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-16-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-17.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-17-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-18.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-18-thumb.png&#34;/&gt;&lt;/a&gt;
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-19.png&#34; title=&#34;Instalación de Ubuntu&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-19-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-20.png&#34; title=&#34;&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/instalacion-ubuntu-20-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Instalación de Ubuntu&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;usando-ubuntu&#34;&gt;Usando Ubuntu&lt;/h3&gt;

&lt;p&gt;Si se ha elegido cifrar el contenido del dispositivo de almacenamiento al realizar la instalación en el inicio del sistema Ubuntu pregunta por la contraseña para descifrar su contenido.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-01.png&#34; title=&#34;Ubuntu 16.04 con entorno de escritorio Unity&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-01-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-02.png&#34; title=&#34;&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-02-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-03.png&#34; title=&#34;&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-03-thumb.png&#34;/&gt;&lt;/a&gt;
  
  &lt;figcaption&gt;Ubuntu 16.04 con entorno de escritorio Unity&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-04.png&#34; title=&#34;Ubuntu 16.04 con entorno de escritorio GNOME&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-04-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-05.png&#34; title=&#34;Ubuntu 16.04 con entorno de escritorio GNOME&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-05-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-06.png&#34; title=&#34;Ubuntu 16.04 con entorno de escritorio GNOME&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-06-thumb.png&#34;/&gt;&lt;/a&gt;
  
  &lt;figcaption&gt;Ubuntu 16.04 con entorno de escritorio GNOME&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-07.png&#34; title=&#34;Ubuntu 16.04 con entorno de escritorio KDE&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-07-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-08.png&#34; title=&#34;Ubuntu 16.04 con entorno de escritorio KDE&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-08-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Ubuntu 16.04 con entorno de escritorio KDE&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;centro-de-software-y-actualizaciones&#34;&gt;Centro de software y actualizaciones&lt;/h3&gt;

&lt;p&gt;Ubuntu por defecto ya incorpora una buena cantidad de software preinstalado. En cualquier caso con la aplicación &lt;em&gt;Software de Ubuntu&lt;/em&gt; se puede instalar más.&lt;/p&gt;

&lt;p&gt;Al cabo de un tiempo de haber instalado Ubuntu se publicarán actualizaciones del software que tengas instalado con mejoras y correcciones de seguridad que son recomendables instalarlas usando la aplicación &lt;em&gt;Actualizciones de software&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-software.png&#34; title=&#34;Instalar y desinstalar software&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-software-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-actualizaciones.png&#34; title=&#34;Instalar actualizaciones de seguridad y software&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/232/ubuntu-actualizaciones-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Instalar actualizaciones de seguridad y software&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;ayuda&#34;&gt;Ayuda&lt;/h3&gt;

&lt;p&gt;En internet hay cantidad de artículos en blogs o foros con ayuda que puedes encontrar con un buscador web como &lt;a href=&#34;https://www.google.es/&#34;&gt;Google&lt;/a&gt; o &lt;a href=&#34;https://duckduckgo.com/&#34;&gt;DuckDuckGo&lt;/a&gt;. En ellos seguramente encontrarás una respuesta que te resuelva o ayude en cualquier problema que se te presente o duda que te surja. Y si después de haber buscado no encuentras la solución deja un comentario en este blog e intentaré ayudarte.&lt;/p&gt;



        </content>
        
            
                <category term="blog"/>
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="software"/>
            
                <category term="software-libre"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/05/controlar-un-servomotor-con-la-raspberry-pi-y-java/</id>
        <title>Controlar un servomotor con la Raspberry Pi y Java</title>        
        <updated>2017-05-13T11:40:00+02:00</updated>
        <published>2017-05-07T11:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/05/controlar-un-servomotor-con-la-raspberry-pi-y-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/raspberrypi.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Raspberry Pi&#34; title=&#34;Raspberry Pi&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Otro de los elementos que incluye el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/&#34;&gt;kit de iniciación a la Raspberry Pi&lt;/a&gt; es un &lt;a href=&#34;https://es.wikipedia.org/wiki/Servomotor&#34;&gt;servomotor&lt;/a&gt;, en concreto uno del modelo SG90. En la &lt;a href=&#34;http://akizukidenshi.com/download/ds/towerpro/SG90_a.pdf&#34;&gt;especificación del servomotor SG90&lt;/a&gt; está detallado cual es el código de colores de los cables. Rojo para la corriente de 5V, marrón para tierra y naranja para el &lt;em&gt;pin&lt;/em&gt; &lt;abbr title=&#34;Pulse Width Modulated&#34;&gt;PWM&lt;/abbr&gt; con el que se controlará el servo motor, el diodo led es simplemente para saber que cuando se enciende el programa Java se ha iniciado. La Raspberry Pi tiene algunos pines con soporte hardware para realizar PWM.&lt;/p&gt;

&lt;p&gt;Un servomotor es un elemento distinto de un motor, un motor usa dos cables uno para mover el motor hacia adelante y otro cable para mover el motor hacia atrás. Los servomotores además de utilizar un único cable para controlarlo su funcionalidad es distinta usándose para posicionar el motor en un determinado ángulo que en el caso del SG90 tiene un ángulo de funcionamiento de 180º. Además el servomotor es más complejo, como se explica en el siguiente artículo de título &lt;a href=&#34;http://handyboard.com/hb/faq/hardware-faqs/dc-vs-servo/&#34;&gt;¿Cual es la diferencia entre un motor DC y servo motor?&lt;/a&gt; el servomotor se compone de varios elementos empaquetados como una pieza. Se compone de un motor DC normal, una unidad de reducción, un sensor de posicionamiento y un circuito de control.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/230/servomotor.jpg&#34; title=&#34;Servomotor&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/230/servomotor-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/230/cableado.jpg&#34; title=&#34;Cableado en la breadboard&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/230/cableado-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Servomotor y cableado&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;La función del servomotor es recibir la señal de control y aplicar corriente al motor hasta que que esté en la posición indicada por la señal. Un servomotor no rota libremente sino que como he comentado en el caso del SG90 tiene un ángulo de funcionamiento de entre 0º y 180º. La señal de control es un pulso de anchura modulada o PWM.&lt;/p&gt;

&lt;p&gt;Usando la librería &lt;a href=&#34;http://rtd.diozero.com/en/latest/&#34;&gt;Diozero&lt;/a&gt; es sencillo controlar un servomotor a través de la clase &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/sandpit/Servo.html&#34;&gt;Servo&lt;/a&gt;. El constructor recibe tres datos el &lt;em&gt;pin&lt;/em&gt; de la Raspberry Pi que controlará el servomotor, según la nomenclatura Broadcom que usa la librería Diozero, la frecuencia del pulso PWD que sirve para controlar la velocidad de rotación y finalmente la posición inicial a establecer. Con el método &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/sandpit/Servo.html#getPulseWidthMs--&#34;&gt;pulseWidthMs&lt;/a&gt; y un rango de un valor &lt;em&gt;float&lt;/em&gt; entre 0.6 y 2.4 controlaremos la posición o ángulo del servomotor.&lt;/p&gt;

&lt;p&gt;El siguiente programa Java cambia en un bucle la posición del servo desde la posición mínima a la máxima. En él he utilizado el &lt;em&gt;pin&lt;/em&gt; 18 que en la Raspberry Pi 1 soporta PWD, en las versiones 2 y 3 podríamos haber usado los &lt;em&gt;pines&lt;/em&gt; 18 o 19.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/92cd41d20e45e50a7657e219789c0e81.js?file=Servomotor.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;video-post&#34; style=&#34;text-align: center;&#34;&gt;
  &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;https://www.youtube.com/embed/g8RsvZ26Cqg&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Aunque he conseguido hacer funcionar el servomotor con este programa no ha sido exento de problemas. Y es que cuando el programa finaliza la Raspberry Pi se me bloquea o se pierde la conectividad de red. No se si por algún &lt;em&gt;bug&lt;/em&gt; en la librería Diozero o alguna incompatibilidad con la Raspberry Pi 1 B, quizá en otro modelo de la Raspberry Pi no dé los problemas que a mi me da.&lt;/p&gt;

&lt;p&gt;En otros artículos de la serie puedes consultar cómo usar otros &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/&#34;&gt;elementos de kit con Java y la Raspberry Pi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaRaspberryPi&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew executeServomotor&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://akizukidenshi.com/download/ds/towerpro/SG90_a.pdf&#34;&gt;Especificación SG90 servomotor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://es.wikipedia.org/wiki/Servomotor&#34;&gt;Servomotor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/04/3-office-alternative-options-to-microsoft-office/</id>
        <title>3 office alternative options to Microsoft Office</title>        
        <updated>2017-04-14T12:15:00+02:00</updated>
        <published>2017-04-14T12:15:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/04/3-office-alternative-options-to-microsoft-office/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Microsoft Office is the office suite with a great margin of difference in the usage quota with the next option on Windows systems. It is very complete and includes more features that most users know but it is also a more expensive option than other alternatives that are free without having anything to envy for most users and use cases.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/microsoft.svg&#34; class=&#34;right&#34; width=&#34;300&#34; alt=&#34;Microsoft&#34; title=&#34;Microsoft&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/libreoffice.svg&#34; class=&#34;right&#34; width=&#34;300&#34; alt=&#34;LibreOffice&#34; title=&#34;LibreOffice&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;In the first article of this 2016 I commented that &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/04/windows-10-and-office-2016-as-easy-to-use-without-license-as-always/&#34;&gt;Windows and Office are still easy to use without a license&lt;/a&gt;. License that costs nothing more than 125€ for &lt;a href=&#34;http://amzn.to/2bg4CR2&#34;&gt;home and students&lt;/a&gt; and about 250€ for &lt;a href=&#34;http://amzn.to/2bNf5Bx&#34;&gt;home and business&lt;/a&gt;, by computer. If the computer is renewed or damaged requiring a change of components, a new license must be purchased. Given the negligible cost of the license it is not surprising that both Windows and Office are among the most used unlicensed or pirated products.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B00HC6QQQM&amp;linkId=762b16ff0b7f340317343dc4a24097ab&amp;internal=1&#34;&gt;&lt;/iframe&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01FNRXAZG&amp;linkId=1f45d19184a5ea936b680670062a7fad&amp;internal=1&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Given how easy it is to use Windows and Office without license along with the &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2011/05/impuesto-windows.html&#34;&gt;Windows tax&lt;/a&gt; they have a market share in virtually monopoly numbers, that will not change in the short term. Sometimes I think that &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/07/a-microsoft-no-le-importa-que-uses-windows-u-office-sin-licencia/&#34;&gt;Microsoft does not care if Windows or Office users uses them without a license&lt;/a&gt; for personal use. However, there are alternatives for both Windows and Office that have little to envy, much cheaper or even free and libre software even with better support than &lt;a href=&#34;http://www.microsoft.com/&#34;&gt;Microsoft&lt;/a&gt; offers for its own software.&lt;/p&gt;

&lt;p&gt;The alternatives to Windows are the expensive &lt;a href=&#34;http://www.apple.com/&#34;&gt;Apple&lt;/a&gt; products very oriented to the high ranges especially for the price or some of the many distributions GNU/Linux that are almost totally free and libre software, although the libre software does not have to be free in most cases.&lt;/p&gt;

&lt;p&gt;In this article I will focus on alternatives to Office that are also several. Bypassing the issue of libre software, Office is a good and complete office suite with more options than many users will need.&lt;/p&gt;

&lt;h3 id=&#34;microsoft-office&#34;&gt;Microsoft Office&lt;/h3&gt;

&lt;p&gt;Microsoft Office includes Word as word processor, Powerpoint for presentations, Excel for spreadsheets, Access for databases, Outlook as an e-mail client, OneNote for taking notes or Publisher for publications. It is only available for Windows and Mac for desktop and web versions for these and other systems. &lt;a href=&#34;https://products.office.com/es-es/home&#34;&gt;Office 365&lt;/a&gt; has a cost of 8.80€ per user and according to the plan that includes more or fewer applications.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/microsoftoffice-word.png&#34; title=&#34;Microsoft Office Word&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/microsoftoffice-word-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/microsoftoffice-excel.png&#34; title=&#34;Microsoft Office Excel&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/microsoftoffice-excel-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/microsoftoffice-powerpoint.png&#34; title=&#34;Microsoft Office Powerpoint&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/microsoftoffice-powerpoint-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;libreoffice&#34;&gt;LibreOffice&lt;/h3&gt;

&lt;p&gt;The free and libre alternative of Office is &lt;a href=&#34;https://es.libreoffice.org/&#34;&gt;LibreOffice&lt;/a&gt;. It includes a text editor with Writing, spreadsheets with Calc, presentations with Impress, Drawing to create graphs and Base for simple databases. However, the interface is similar to the Office in the previous editions incorporated with an aesthetic and without the feeling of being taken care of. The menus are long and find a choice among the many is not easy, opening a menu option can be feel intimidated by the length of it and somewhat more difficult to quickly find the desired option among all shown. There will be users who prefer the menu interface and toolbars, I am the ones who like ribbon. It is available for Windows, Linux and Mac.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/libreoffice-writer.png&#34; title=&#34;LibreOffice Writer&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/libreoffice-writer-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/libreoffice-calc.png&#34; title=&#34;LibreOffice Calc&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/libreoffice-calc-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/libreoffice-impress.png&#34; title=&#34;LibreOffice Impress&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/libreoffice-impress-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;wps-office&#34;&gt;WPS Office&lt;/h3&gt;

&lt;p&gt;If you like the ribbon interface without menus with a multitude of options and that is more careful in a design than LibreOffice similar to the one used in Microsoft Office, &lt;a href=&#34;https://www.wps.com/&#34;&gt;WPS Office&lt;/a&gt; is a great option to take into account, it can also be activated in classic mode menus and toolbars, it can edit multiple documents in tabs. It offers the basic programs of an office suite: text editor, spreadsheets and presentations. For personal use it is available with some limitations when printing and exporting documents to PDF format.&lt;/p&gt;

&lt;p&gt;For the business environments with all its options its license has a much more reasonable cost than Microsoft Office, 30€ for a one year subscription license and 80€ for the perpetual license.&lt;/p&gt;

&lt;p&gt;It is available for Windows (XP, Vista, 7, 8, 10) even in versions for which Microsoft Office does not already offer support, Linux, Android and iOS. Its installer occupies only 80 MB against more than 3 gigas of Office.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/wpsoffice-writer.png&#34; title=&#34;WPS Writer&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/wpsoffice-writer-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/wpsoffice-spreadsheets.png&#34; title=&#34;WPS Spreadsheets&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/wpsoffice-spreadsheets-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/wpsoffice-presentation.png&#34; title=&#34;WPS Office Presentation&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/wpsoffice-presentation-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;h3 id=&#34;google-docs&#34;&gt;Google Docs&lt;/h3&gt;

&lt;p&gt;Another alternative to Office is &lt;a href=&#34;https://www.google.es/intl/es/docs/about/&#34;&gt;Google Docs&lt;/a&gt;, it does not have all the options that Office has but for most users it is enough. Simply have a Google account to use that includes a text editor, spreadsheets, presentations and the ability to make forms. It runs in the browser and although it is possible to work without internet connection at specific times is required. The documents are stored in the cloud so we will not lose them in case of spoiling our computer, we can access the documents from any of our devices as a smartphone o tablet, edit the same document by two or more persons simultaneously or share the documents with other people. Being based on the cloud we do not need to perform software updates except the browser.&lt;/p&gt;

&lt;p&gt;For companies it is offered at the price of 4€ per user per month which includes the Gmail email client, calendars, video calls and 30GB of storage. There will be 8€ with more storage options and message retention.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/googledocs-documento.png&#34; title=&#34;Documento Google Docs&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/googledocs-documento-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/googledocs-hoja-de-calculo.png&#34; title=&#34;Hoja de cálculo Google Docs&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/googledocs-hoja-de-calculo-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/googledocs-presentacion.png&#34; title=&#34;Presentación Google Docs&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/143/googledocs-presentacion-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Some other options that deserves to be commented is &lt;a href=&#34;https://www.calligra.org/&#34;&gt;Calligra&lt;/a&gt; the &lt;a href=&#34;https://www.kde.org/&#34;&gt;KDE desktop environment&lt;/a&gt; suite, &lt;a href=&#34;http://www.abiword.org/&#34;&gt;Abiword&lt;/a&gt;, &lt;a href=&#34;http://www.lyx.org/&#34;&gt;Lyx&lt;/a&gt; or &lt;a href=&#34;http://www.gnumeric.org/&#34;&gt;Gnumeric&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The next time I&amp;rsquo;m asked to reinstall Windows or Office instead of installing the Microsoft Office suite without a license I think I will install the WPS Office personal use option, I will recommend using Google Docs or LibreOffice, I hope them improve and update to modern times its interface when I have to install it again.&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/07/a-microsoft-no-le-importa-que-uses-windows-u-office-sin-licencia/&#34;&gt;A Microsoft no le importa que uses Windows u Office sin licencia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/04/windows-10-and-office-2016-as-easy-to-use-without-license-as-always/&#34;&gt;Windows 10 and Office 2016 as easy to use without license as always&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2011/05/impuesto-windows.html&#34;&gt;Windows tax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://libreoffice.org/&#34;&gt;LibreOffice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.wps.com/&#34;&gt;WPS Office&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.google.es/intl/es/docs/about/&#34;&gt;Google Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="microsoft"/>
            
                <category term="software"/>
            
                <category term="software-libre"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/04/ejemplo-sensor-de-golpes-y-detector-de-movimiento-en-la-raspberry-pi-con-java/</id>
        <title>Ejemplo sensor de golpes y detector de movimiento en la Raspberry Pi con Java</title>        
        <updated>2017-04-13T11:00:00+02:00</updated>
        <published>2017-04-13T11:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/04/ejemplo-sensor-de-golpes-y-detector-de-movimiento-en-la-raspberry-pi-con-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/raspberrypi.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Raspberry Pi&#34; title=&#34;Raspberry Pi&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Otro par de sensores que incluye el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/&#34;&gt;kit de introducción a la electrónica para la Raspberry Pi&lt;/a&gt; son un sensor de golpes o &lt;em&gt;tilt&lt;/em&gt; y un detector de movimiento. El funcionamiento de ambos es muy similar, utilizando un &lt;em&gt;pin&lt;/em&gt; &lt;abbr title=&#34;General Purpose Input Output&#34;&gt;GPIO&lt;/abbr&gt; como entrada se recibe si el sensor de golpes está activo o si el detector de movimiento ha detectado movimiento. El sensor de golpes es una bolita de mercurio encerrada en una ampolla de cristal. Como el mercurio a temperatura ambiente su estado es líquido puede moverse y como es un metal puede conducir la electricidad cuando está en una determinada posición entre dos filamentos.&lt;/p&gt;

&lt;p&gt;El sensor de golpes necesita de tres cables uno para la corriente de 3.3V, otro para tierra y finalmente otro que se conecta como entrada a un &lt;em&gt;pin&lt;/em&gt; GPIO. Usando varios cables hembra-hembra y macho-macho hacemos las conexiones entre el sensor y la placa de pruebas sin soldadura o &lt;em&gt;breadboard&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/224/sensores-1.jpg&#34; title=&#34;Sensor de golpes y detector de movimiento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/224/sensores-1-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/224/sensores-2.jpg&#34; title=&#34;Sensor de golpes y detector de movimiento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/224/sensores-2-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Sensor de golpes y detector de movimiento&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Usando la librería &lt;a href=&#34;http://rtd.diozero.com/en/latest/&#34;&gt;diozero&lt;/a&gt; para controlar los &lt;em&gt;pines&lt;/em&gt; GPIO desde un programa implementado con Java detectamos si el sensor está activo o no según la posición de la bolita de mercurio. El ejemplo consiste en &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/03/ejemplo-encender-y-apagar-diodo-led-con-la-raspberry-pi-en-java/&#34;&gt;encender un diodo LED&lt;/a&gt; que ya mostré en un artículo anterior de esta &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/electronica/&#34;&gt;serie sobre electrónica&lt;/a&gt; cuando el sensor &lt;em&gt;tilt&lt;/em&gt; esté activo. Usaré el &lt;em&gt;pin&lt;/em&gt; 18 para el diodo LED y el &lt;em&gt;pin&lt;/em&gt; 21 para el sensor según la nomenclatura de Broadcom. Los &lt;em&gt;pines&lt;/em&gt; serían el 12 según la nomenclatura del &lt;em&gt;header&lt;/em&gt; y 1 según la nomenclatura de wiringPi para el diodo LED y 13 y 2 para el sensor &lt;em&gt;tilt&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/224/cableado-tilt.jpg&#34; title=&#34;Cableado sensor de golpes&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/224/cableado-tilt-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Cableado sensor de golpes&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/ec8532262fcc92e4862a2cd4c294b073.js?file=Tilt.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;En el siguiente vídeo se aprecia como cuando al cambiar de posición del sensor de movimiento se mueve la bolita de mercurio y el diodo LED de ejemplo se enciende y apaga.&lt;/p&gt;

&lt;div class=&#34;video-post&#34; style=&#34;text-align: center;&#34;&gt;
  &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;https://www.youtube.com/embed/7Rkou-pJWFY&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;El detector de movimiento en teoría es similar en funcionamiento al &lt;em&gt;tilt&lt;/em&gt; y la librería diozero proporciona la clase &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/sandpit/MotionSensor.html&#34;&gt;MotionSensor&lt;/a&gt; para hacer más sencillo su uso. Digo en teoría porque no he conseguido hacerlo funcionar y he revisado varias veces las conexiones mostradas en otros ejemplos incluido el &lt;a href=&#34;http://osoyoo.com/2016/07/14/motionsensor-pi/&#34;&gt;ejemplo de osoyoo&lt;/a&gt;, no se si es porque me falta algo más que debo tener en cuenta y que no conozco o el sensor no funciona viniendome estropeado. Cuando el sensor detecta movimiento cambia el voltaje de su &lt;em&gt;pin&lt;/em&gt; GPIO de datos. Los otros dos &lt;em&gt;pines&lt;/em&gt; que utiliza son uno para el voltaje de 5V y el de tierra.&lt;/p&gt;

&lt;p&gt;El programa Java para el sensor de movimiento es similar al sensor &lt;em&gt;tilt&lt;/em&gt; e igualmente encendería o apagaría un diodo LED cuando detecta movimiento.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/224/cableado-motion.jpg&#34; title=&#34;Cableado sensor de movimiento&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/224/cableado-motion-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Cableado sensor de movimiento&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/ec8532262fcc92e4862a2cd4c294b073.js?file=Motion.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Ambos ejemplos pueden usarse con los siguientes comandos cambiando la dirección IP de la Raspberry Pi y el directorio de la misma a donde se suben los ejemplos.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/ec8532262fcc92e4862a2cd4c294b073.js?file=execute.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;El siguiente artículo de la sería será sobre cómo usar un &lt;em&gt;servo motor&lt;/em&gt; que es diferente de un motor que gira constantemente.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaRaspberryPi&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pimylifeup.com/raspberry-pi-motion-sensor/&#34;&gt;Raspberry Pi Motion Sensor using a PIR Sensor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.meccanismocomplesso.org/en/pir-motion-detector/&#34;&gt;PIR motion detector – a sensor for Arduino and Raspberry Pi (1st part)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/04/como-usar-un-diodo-led-un-pulsador-y-un-zumbador-con-la-raspberry-pi-y-java/</id>
        <title>Cómo usar un diodo LED, un pulsador y un zumbador con la Raspberry Pi y Java</title>        
        <updated>2017-04-09T12:00:00+02:00</updated>
        <published>2017-04-09T12:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/04/como-usar-un-diodo-led-un-pulsador-y-un-zumbador-con-la-raspberry-pi-y-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;El &lt;em&gt;kit&lt;/em&gt; de electrónica para la Raspberry Pi incluye varios dispositivos controlables con lo &lt;em&gt;pines&lt;/em&gt; GPIO. En el caso de este ejemplo usaré un diodo LED, un zumbador y un pulsador para crear un ejemplo en el que el diodo LED se enciendan y el zumbador emita un sonido cuando el pulsador se active.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/raspberrypi.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Raspberry Pi&#34; title=&#34;Raspberry Pi&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En artículos anteriores ya he comentado &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/03/ejemplo-encender-y-apagar-diodo-led-con-la-raspberry-pi-en-java/&#34;&gt;como hacer parpadear un diodo LED&lt;/a&gt;, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/03/controlar-un-display-lcd-1602-para-mostrar-texto-con-la-raspberry-pi-y-java/&#34;&gt;como usar un display LCD de 16 columnas y 2 filas&lt;/a&gt; y &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/03/obtener-la-temperatura-y-humedad-con-el-sensor-dht11-la-raspberry-pi-c-y-java/&#34;&gt;como obtener la temperatura y humedad de un sensor DHT11&lt;/a&gt;, todo estos ejemplo usando varios elementos de &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/&#34;&gt;kit de iniciación a la electrónica para la Raspberry Pi 3&lt;/a&gt;. En este artículo en el que mostraré cómo usar un LED, un pulsador y un zumbador es mucho más sencillo que los casos del &lt;em&gt;display&lt;/em&gt; LCD de 16 filas y 2 columnas y del sensor DHT11. Vistos los ejemplos de artículos anteriores lo más difícil de este es hacer el conexionado con los cables. Para controlar los pines usaré la librería &lt;a href=&#34;http://rtd.diozero.com/en/latest/&#34;&gt;diozero&lt;/a&gt; que proporciona clases de alto nivel para cada uno de estos elementos para que desde código Java sea bastante sencillo controlarlos.&lt;/p&gt;

&lt;p&gt;El ejemplo consistirá en que cuando se presione el pulsador se encienda el diodo LED y el zumbador se active emitiendo un zumbido audible. Cada uno de estos elementos requiere usar un &lt;em&gt;pin&lt;/em&gt; &lt;abbr title=&#34;General Purpose Input Output&#34;&gt;GPIO&lt;/abbr&gt; de los 17 que hay disponibles en la Raspberry Pi 1 que es el modelo que tengo yo o de los 26 &lt;em&gt;pines&lt;/em&gt; que poseen versiones posteriores de la Raspberry Pi como la B+, 2 y 3.&lt;/p&gt;

&lt;p&gt;Este sería el esquema de conexionado de los elementos. El diodo LED tiene una polaridad de modo que la patita larga que es la parte positiva se conectará al &lt;em&gt;pin&lt;/em&gt; GPIO 1 según la nomenclatura de wiringPi o el 18 según la de Broadcom con una resistencia de 200 ohmios entre el &lt;em&gt;pin&lt;/em&gt; GIPO y la patita de diodo para que la intensidad que atraviesa el diodo sea menor y no se desgaste. El zumbador también tiene una polaridad que en el caso del &lt;em&gt;kit&lt;/em&gt; que he usado viene serigrafiado y con una etiqueta, la parte positiva se conectará a otro &lt;em&gt;pin&lt;/em&gt; GPIO y usaré el &lt;em&gt;pin&lt;/em&gt; GPIO 2. Para que el pulsador haga contacto bien en la placa de conexiones para hacer pruebas sin soldadura hay que presionar sin forzar pero hasta que quede bien encadado y sin fijo, usaré el &lt;em&gt;pin&lt;/em&gt; GPIO 3.&lt;/p&gt;

&lt;p&gt;Para el pulsador usaré el método &lt;em&gt;PULL UP&lt;/em&gt; (el otro es &lt;em&gt;PULL DOWN&lt;/em&gt;) donde conectaré una patita del pulsador a tierra y la adyacente al &lt;em&gt;pin&lt;/em&gt; GPIO, en &lt;a href=&#34;https://grantwinney.com/using-pullup-and-pulldown-resistors-on-the-raspberry-pi/&#34;&gt;algunas páginas&lt;/a&gt; se explica haciendo uso de resistencias, sin embargo, el uso de resistencias en la Raspberry Pi no es necesario ya que los &lt;em&gt;pines&lt;/em&gt; ya &lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/special-pin-functions/&#34;&gt;las tienen incorporadas internamente&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/cableado.jpg&#34; title=&#34;cableado en la breadboard&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/cableado-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/esquema-cableado.png&#34; title=&#34;Esquema del cableado&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/esquema-cableado-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Esquema del cableado&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;La librería diozeo para identificar los pines usa la nomenclatura de Broadcom, otras son las nomenclaturas del &lt;em&gt;header&lt;/em&gt; o de wiringPi. Hay que tener en cuenta la nomenclatura que se use ya que el número del &lt;em&gt;pin&lt;/em&gt; variará en cada una de ellas, también hay que tener en cuenta la versión de la Raspberry Pi ya que hay pequeñas variaciones según la versión. Por ejemplo, según la tabla de referencia siguiente, para la Raspberry Pi 1 y según la nomenclatura de Brodacom el &lt;em&gt;pin&lt;/em&gt; GPIO 18 corresponde al número 12 de &lt;em&gt;header&lt;/em&gt;, el GPIO 21 al número 13 y el GPIO 22 al número 15. Según la nomenclatura de wiringPi el GPIO 1 corresponde al número 1, el GPIO 2 al número 2 y el GPIO 3 al número 3.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/raspberrypi1b-header-rev1.png&#34; title=&#34;Header de pines Raspberry Pi 1 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/raspberrypi1b-header-rev1-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/raspberrypi3b-header.png&#34; title=&#34;Header de pines Raspberry Pi 3 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/raspberrypi3b-header-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Header de pines Raspberry Pi 1 B y Raspberry Pi 3 B, nomenclatura wiringPi&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/raspberrypi1b-header-rev1-broadcom.png&#34; title=&#34;Header de pines Raspberry Pi 1 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/raspberrypi1b-header-rev1-broadcom-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/raspberrypi3b-header-broadcom.png&#34; title=&#34;Header de pines Raspberry Pi 3 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/221/raspberrypi3b-header-broadcom-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Headers de pines Raspberry Pi 1 B y Raspberry Pi 3 B, nomenclatura Broadcom&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Usando la librería diozero el código Java para realizar el ejemplo no necesita excesiva explicación. Es posible hacer uso de las &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/03/novedades-y-nuevas-caracteristicas-de-java-8/&#34;&gt;funciones lambdas que incorporó el lenguaje Java en la versión de Java 8&lt;/a&gt; y con la sentencia &lt;em&gt;try-with-resources&lt;/em&gt; del lenguaje los elementos se finalizará correctamente en caso de producirse alguna excepción, por ejemplo apagando el diodo en caso de que estuviese encendido o apagando el zumbador en su caso.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/0d5bb399bc7a20b903ee54ec41dee8e1.js?file=LedButtonBuzzer.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Este es un pequeño vídeo en el que muestro su funcionamiento.&lt;/p&gt;

&lt;div class=&#34;video-post&#34; style=&#34;text-align: center;&#34;&gt;
  &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;https://www.youtube.com/embed/jaqMi53pjf0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaRaspberryPi&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew executeLedButtonBuzzer&lt;/code&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/03/obtener-la-temperatura-y-humedad-con-el-sensor-dht11-la-raspberry-pi-c-y-java/</id>
        <title>Obtener la temperatura y humedad con el sensor DHT11, la Raspberry Pi, C y Java</title>        
        <updated>2017-04-02T10:15:00+02:00</updated>
        <published>2017-03-31T19:00:00+02:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/03/obtener-la-temperatura-y-humedad-con-el-sensor-dht11-la-raspberry-pi-c-y-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;El &lt;em&gt;kit&lt;/em&gt; de iniciación a la electrónica para la Raspberry Pi tiene un sensor para la temperatura y humedad, el modelo DHT11. Obtener la información requiere restricciones de tiempo, este es un caso de uso justificado para usar lenguaje C y JNI para integrarlo con Java. En el ejemplo el código C llama a un método de una clase Java con dos valores enteros o lanza una excepción en caso de que al realizar la lectura haya habido algún error en la transmisión de los bits.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/raspberrypi.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Raspberry Pi&#34; title=&#34;Raspberry Pi&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Entre los varios sensores incluídos en el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/&#34;&gt;kit de iniciación para la Raspberry Pi&lt;/a&gt; está el sensor de temperatura y humedad con el modelo DHT11. El DHT11 es un sensor muy básico pero suficiente y válido si el objetivo es trastear un poco con hardware.&lt;/p&gt;

&lt;p&gt;En la &lt;a href=&#34;http://www.micropik.com/PDF/dht11.pdf&#34;&gt;especificación del sensor DHT11&lt;/a&gt; está descrita su funcionamiento y forma de comunicación. Utiliza 3 cables, uno para la corriente de 3.3V, otro para tierra y finalmente uno de datos que se conecta a cualquier &lt;em&gt;pin&lt;/em&gt; &lt;abbr title=&#34;General Purpose Input Output&#34;&gt;GPIO&lt;/abbr&gt; de la Raspberry Pi. Según la especificación el sensor proporciona sus datos en unos 4 ms cuando se le emite un pulso bajo durante unos pocos microsegundos y a continuación uno alto durante otros pocos microsegundos, momento a partir del cual el sensor emite 40 bits de información empezando por un pulso bajo de inicio y a continuación el propio bit con un pulso alto, según sea la duración del pulso alto el bit se considera un 0 si es menor de unos 27μs y un 1 si dura más de ese tiempo hasta unos 80μs momento en el que se emite el siguiente bit de información. Los primeros 8 bits corresponden a la parte entera de la humedad, los siguientes 8 bits a la parte decimal de la humedad, el tercer grupo de 8 bits a la parte entera de la temperatura y 8 bits más para la parte decimal. El último grupo de 8 bits hasta completar los 40 bits son de &lt;em&gt;checksum&lt;/em&gt; para detectar errores en la transmisión. El porcentaje de errores en la transmisión significativo en este sensor y quizá haya que realizar varias lecturas del sensor para obtener una correcta.&lt;/p&gt;

&lt;p&gt;Dada las restricciones de tiempo que utiliza el sensor en el ejemplo usaré el lenguaje C para obtener los valores de temperatura y humedad y &lt;abbr title=&#34;Java Native Interface&#34;&gt;JNI&lt;/abbr&gt; para acceder a ellos desde Java. Aún usando C se producen errores en la obtención de los valores ya que el método usado por el sensor y transmitir los datos basados en tiempo de microsegundos no es muy fiable. Usando Java la situación sería peor por las restricciones que impone la máquina virtual con sus paradas para la recolección de basura por ejemplo. Así que el ejemplo consistirá en una combinación de C y Java con JNI un poco más avanzado que el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/03/ejemplo-de-jni-usar-codigo-en-c-desde-java/&#34;&gt;Ejemplo de JNI, usar código en C desde Java&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/219/dht11-1.jpg&#34; title=&#34;Sensor DHT11&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/219/dht11-1-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/219/dht11-2.jpg&#34; title=&#34;Sensor DHT11&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/219/dht11-2-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Sensor DHT11&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Lo primero que deberemos hacer para acceder a la información del sensor desde Java es crear una clase que contenga un método nativo que realizará la lectura de la información en C. Con la utilidad &lt;em&gt;javah&lt;/em&gt; obtendremos el archivo de cabecera que implementará el programa en C. Finalmente, siguiendo la especificación se escribe el código C que realice la lectura que en este caso usará la librería &lt;a href=&#34;http://wiringpi.com/&#34;&gt;wiringPi&lt;/a&gt; para la interacción con los pines GPIO de la Raspberry Pi.&lt;/p&gt;

&lt;p&gt;El código en C invocará el método &lt;em&gt;setTemperatureHumidity&lt;/em&gt; pasando como parámetros los datos de temperatura y humedad leídos del sensor, el método nativo &lt;em&gt;read&lt;/em&gt; es utilizado por el código Java que controla el sensor para realizar la lectura en el código C.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c77e19703a53924171a6a4144a1b46a7.js?file=Dht11.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/c77e19703a53924171a6a4144a1b46a7.js?file=Dht11.h&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/c77e19703a53924171a6a4144a1b46a7.js?file=Dht11.c&#34;&gt;&lt;/script&gt;

&lt;p&gt;El código en C del sensor hay que compilarlo en la Raspberry Pi con el compilador &lt;a href=&#34;https://gcc.gnu.org/&#34;&gt;gcc&lt;/a&gt; obteniendo una librería con código nativo que Java y JNI cargará y enlazará de forma dinámica en el programa Java. Ya que el código C usa la librería wiringPi ha de instalarse previamente junto con el compilador gcc. Obtenida la librería la copiamos mediante FTP o SSH de la Raspberry Pi a nuestro equipo de desarrollo. El código C realiza la lectura usando la librería wiringPi siguiendo la especificación de como se transmiten los datos por el sensor, realizada una lectura correcta usa varias de las funciones de la estructura &lt;a href=&#34;http://xdprof.sourceforge.net/doxygen/structJNIEnv__.html&#34;&gt;JNIEnv&lt;/a&gt; para obtener la referencia a un método de la clase DHT11 e invocarlo con los valores obtenidos del sensor o lanza una excepción si la lectura ha sido errónea.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c77e19703a53924171a6a4144a1b46a7.js?file=install-packages.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;El comando para compilar la librería de código nativo a partir del código en C y el archivo de cabecera generado con &lt;em&gt;javah&lt;/em&gt; es el siguiente.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c77e19703a53924171a6a4144a1b46a7.js?file=compile.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para facilitar la ejecución la librería la proporcionó ya compilada y ubicada en el directorio &lt;em&gt;src/main/resources&lt;/em&gt; de modo que será incluida en el archivo &lt;em&gt;jar&lt;/em&gt; generado por &lt;a href=&#34;http://gradle.org/&#34;&gt;Gradle&lt;/a&gt; en el ejemplo y que la clase DHT11 extraerá al directorio temporal del sistema y cargará para su uso.&lt;/p&gt;

&lt;p&gt;La clase Java del ejemplo que hace uso del sensor realiza una lectura cada 3 segundos e imprime en la terminal y en el &lt;em&gt;display&lt;/em&gt; 1602 el último valor obtenido correctamente de la temperatura y humedad.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c77e19703a53924171a6a4144a1b46a7.js?file=TemperatureHumidity.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Este es el esquema de conexiones que he utilizado para el ejemplo y una foto del cableado real, he usado del &lt;em&gt;pin&lt;/em&gt; GPIO número 2 según la nomenclatura de wiringPi para el cable de datos del sensor DHT11 que se corresponde con pin número 13 según la nomenclatura del &lt;em&gt;header&lt;/em&gt; de la Raspberry Pi. Para ver el cableado del &lt;em&gt;display&lt;/em&gt; 1602 más detalladamente y la activación del bus de comunicación I2C que necesita consulta el artículo &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/03/controlar-un-display-lcd-1602-para-mostrar-texto-con-la-raspberry-pi-y-java/&#34;&gt;Controlar un display LCD 1602 para mostrar texto con la Raspberry Pi y Java&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/219/cableado.jpg&#34; title=&#34;Cableado sensor DHT11 y display 1602&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/219/cableado-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Cableado sensor DHT11 y display 1602&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Ejecutando el programa del ejemplo y usando el display 1602 (16 columnas y 2 filas) se muestra la temperatura y humedad obtenida del sensor.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/219/temperature-humidity.jpg&#34; title=&#34;Cableado ejemplo y funcionando&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/219/temperature-humidity-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/219/display.jpg&#34; title=&#34;Cableado ejemplo y funcionando&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/219/display-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Cableado ejemplo y funcionando&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;En el kernel de Linux hay un módulo que proporciona también los valores del sensor, sin embargo, no he conseguido obtener la temperatura y humedad usándolo. Lo he probado con el kernel 4.4 de Arch Linux ARM y en la versión 4.9 veo que hay cambios en este módulo que quizá lo hagan funcionar. Para usar el módulo del kernel hay que añadir un poco de configuración para el inicio de la Raspberry Pi. En los archivos &lt;em&gt;/sys/devices/platform/dht11@0/iio:device0/in_temp_input&lt;/em&gt; y &lt;em&gt;/sys/devices/platform/dht11@0/iio:device0/in_temp_input&lt;/em&gt; estarán la temperatura y humedad respectivamente.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c77e19703a53924171a6a4144a1b46a7.js?file=kernel-module-config.txt&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/c77e19703a53924171a6a4144a1b46a7.js?file=cat.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Para ejecutar el ejemplo con ya todo instalado uso uno de los siguientes dos comandos.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/c77e19703a53924171a6a4144a1b46a7.js?file=execute.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaRaspberryPi&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew executeTemperatureHumidity&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html&#34;&gt;Java programming with JNI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hirt.se/blog/?p=493&#34;&gt;Accessing 1-wire Protocol Devices from Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.circuitbasics.com/how-to-set-up-the-dht11-humidity-sensor-on-the-raspberry-pi/&#34;&gt;How to Set Up the DHT11 Humidity Sensor on the Raspberry Pi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.prometec.net/sensores-dht11/&#34;&gt;Sensores de temperatura DHT11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Hexalyse/RPi-weather-log/blob/master/dht11.c&#34;&gt;dht11.c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.uugear.com/portfolio/read-dht1122-temperature-humidity-sensor-from-raspberry-pi/&#34;&gt;Read DHT11/22 Temperature &amp;amp; Humidity Sensor from Raspberry Pi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://arduino-info.wikispaces.com/DHT11-Humidity-TempSensor&#34;&gt;Digital output temperature and humidity sensor DHT11 - DHT22&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://playground.arduino.cc/Main/DHT11Lib&#34;&gt;A DHT11 Class for Arduino&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/master/drivers/iio/humidity/dht11.c&#34;&gt;torvalds/linux/blob/master/drivers/iio/humidity/dht11.c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tortosaforum.com/raspberrypi/dht11driver.htm&#34;&gt;RaspberryPi DHT11 temperature and humidity sensor driver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/03/ejemplo-de-jni-usar-codigo-en-c-desde-java/</id>
        <title>Ejemplo de JNI, usar código en C desde Java</title>        
        <updated>2017-03-25T10:05:00+01:00</updated>
        <published>2017-03-25T10:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/03/ejemplo-de-jni-usar-codigo-en-c-desde-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Para tareas muy específicas que requieran alto rendimiento, baja latencia, tiempo real o haya restricciones de tiempo el lenguaje Java y la JVM pueden mostrar algunas limitaciones obligando a escribir alguna sección crítica de un programa en un lenguaje nativo como C o C++. Para hacer posible la integración entre Java y C existe en Java la API JNI. En este artículo mostraré como realizar un programa Java que emite el mensaje Hola Mundo desde una biblioteca compartida en C y usando JNI.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/gnu.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;SVG&#34; title=&#34;SVG&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/linux.png&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Linux&#34; title=&#34;Linux&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Nunca hasta ahora había tenido necesidad de crear un programa que no estuviese completamente escrito en el lenguaje Java. La &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/overview-summary.html&#34;&gt;API de Java&lt;/a&gt; ofrece multitud de clases para cualquier funcionalidad que necesitemos desde estructuras de datos hasta algoritmos de búsqueda o criptografía. También porque el rendimiento de un programa en Java es suficiente y similar a un programa equivalente escrito en C o C++ gracias a las optimizaciones que implementa la máquina virtual de Java o &lt;abbr title=&#34;Java Virtual Machine&#34;&gt;JVM&lt;/abbr&gt; aún siendo los programas Java compilados a una representación intermedia de &lt;em&gt;bytecode&lt;/em&gt; independiente de la arquitectura de procesador y sistema operativo en archivos de extensión &lt;em&gt;class&lt;/em&gt; y posteriormente interpretados y traducidos a la arquitectura de ejecución, lo que le proporciona a Java la conocida frase &lt;em&gt;&amp;ldquo;Write once, run anywhere&amp;rdquo;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Sin embargo, en casos que se necesita un alto rendimiento para tareas muy específicas o evitar las imposiciones de la máquina virtual como las paradas que realiza para el recolector de basura una solución es escribir esa funcionalidad crítica en lenguaje C, C++ e incluso en &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt;. El caso de necesidad que me he encontrado es acceder a un sensor de temperatura DHT11 del &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/&#34;&gt;kit de iniciación a la electrónica para la Raspberry Pi&lt;/a&gt; para leer de él la temperatura y humedad. La forma que tiene el sensor DHT11 de proporcionar los datos tiene restricciones de tiempo, cuando se le requieren los valores envía 80 bits de datos donde un pulso de 27μs significa un 0 y un pulso de más de ese tiempo hasta 70μs significa un 1. Estas restricciones de tiempo del sensor y el hecho de que es en una modesta en potencia &lt;a href=&#34;http://www.raspberrypi.org/&#34;&gt;Raspberry Pi&lt;/a&gt; 1 donde lo usaré hace que Java no sea capaz de leer correctamente los valores del sensor.&lt;/p&gt;

&lt;p&gt;Acceder desde Java a código nativo en C requiere usar &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html&#34;&gt;Java Native Interface o por sus siglas JNI&lt;/a&gt;. Lo primero que hay que realizar es crear una clase que declare los métodos que serán implementados de forma nativa declarando estos métodos usando la palabra reservada &lt;em&gt;native&lt;/em&gt; y que serán enlazados por la JVM cargando una librería compartida con &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#loadLibrary-java.lang.String-&#34;&gt;System.loadLibrary()&lt;/a&gt;. Creada la clase Java se ha de generar el archivo de cabecera &lt;em&gt;.h&lt;/em&gt; propia del lenguaje C con el programa de utilidad del JDK &lt;em&gt;javah&lt;/em&gt;. Con el archivo de cabecera se implementa la función y se crea una librería compartida en &lt;a href=&#34;https://www.gnu.org/&#34;&gt;GNU&lt;/a&gt;/&lt;a href=&#34;http://www.linux.com/&#34;&gt;Linux&lt;/a&gt; usando el &lt;a href=&#34;https://gcc.gnu.org/&#34;&gt;compilador gcc&lt;/a&gt;. Con la librería compartida se puede iniciar el programa Java. Si la biblioteca compartida no se encuentra se lanzará una excepción del tipo &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/lang/UnsatisfiedLinkError.html&#34;&gt;UnsatisfiedLinkError&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/217/UnsatisfiedLinkError.png&#34; title=&#34;Excepción UnsatisfiedLinkError cuando no se encuentra la librería de código nativo&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/217/UnsatisfiedLinkError-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Excepción UnsatisfiedLinkError cuando no se encuentra la librería de código nativo&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Algunas otras necesidades para hacer uso de JNI son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Acceder a características dependientes de la plataforma necesitadas por la aplicación que no están soportadas en la librería estándar de Java.&lt;/li&gt;
&lt;li&gt;Ya hay una librería escrita en otro lenguaje y se quiere hacer accesible a código Java a través de JNI.&lt;/li&gt;
&lt;li&gt;Se quiere implementar una pequeña parte de código crítico en un lenguaje de bajo nivel como ensamblador.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Desde los métodos de código nativo se puede:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Crear, inspeccionar y actualizar objetos Java (incluyendo arrays y strings).&lt;/li&gt;
&lt;li&gt;Llamar a métodos Java.&lt;/li&gt;
&lt;li&gt;Capturar y lanzar excepciones.&lt;/li&gt;
&lt;li&gt;Cargar y obtener información de clases.&lt;/li&gt;
&lt;li&gt;Realizar validación de tipos en tiempo de ejecución.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los comandos para generar el archivo de cabecera de C y compilarlo con el código nativo en una librería compartida con gcc son:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/94e61b21e8d1378384e363879df5be31.js?file=build.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/94e61b21e8d1378384e363879df5be31.js?file=build.gradle&#34;&gt;&lt;/script&gt;

&lt;p&gt;La cabecera usa varias definiciones de tipos definidas en los archivos &lt;em&gt;jni.h&lt;/em&gt; y el archivo que variará según el sistema operativo &lt;em&gt;jni_md.h&lt;/em&gt;. En la &lt;a href=&#34;http://xdprof.sourceforge.net/doxygen/structJNIEnv__.html&#34;&gt;estructura JNIEnv&lt;/a&gt; con múltiples funciones de integración en C y Java, también varias definiciones de los tipos Java para usarlos en C como &lt;em&gt;jobject&lt;/em&gt;, &lt;em&gt;jstring&lt;/em&gt;, &lt;em&gt;jint&lt;/em&gt;, &lt;em&gt;jboolean&lt;/em&gt;, &lt;em&gt;jlong&lt;/em&gt;, &lt;em&gt;jdouble&lt;/em&gt;, &lt;em&gt;jchar&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;El programa que emite el mensaje &lt;em&gt;Hello World!&lt;/em&gt; desde código nativo en C debe cargar y enlazar la librería de código nativo con el código de la clase Java. Esto se muestra en el bloque de inicialización &lt;em&gt;static&lt;/em&gt; de la clase, en este caso usándo el método &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#load-java.lang.String-&#34;&gt;System.load()&lt;/a&gt;, la librería de código nativo de extensión &lt;em&gt;.so&lt;/em&gt; en GNU/Linux como en este caso al construirse el proyecto se incluye en el archivo &lt;em&gt;.jar&lt;/em&gt; del artefacto resultante se extráe al directorio temporal y se carga desde esa ubicación temporal. En el programa se llama al método &lt;em&gt;print&lt;/em&gt; implementado en código nativo y en el código C se usa la función &lt;em&gt;printf&lt;/em&gt; de la librería &lt;em&gt;stdio&lt;/em&gt; para emitir el mensaje:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/94e61b21e8d1378384e363879df5be31.js?file=JniHelloWorld.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/94e61b21e8d1378384e363879df5be31.js?file=JniHelloWorld.c&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/94e61b21e8d1378384e363879df5be31.js?file=JniHelloWorld.h&#34;&gt;&lt;/script&gt;

&lt;p&gt;La librería compartida para un sistema &lt;em&gt;amd64&lt;/em&gt; la he compilado en mi equipo de escritorio y para la versión &lt;em&gt;arm&lt;/em&gt; en la Raspberry Pi e incluido en el directorio &lt;em&gt;src/main/resources&lt;/em&gt; de código fuente del ejemplo.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/94e61b21e8d1378384e363879df5be31.js?file=execute.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/217/JniHelloWorld-amd64.png&#34; title=&#34;Mensaje en la terminal emitido desde código nativo (amd64)&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/217/JniHelloWorld-amd64-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/217/JniHelloWorld-arm.png&#34; title=&#34;Mensaje en la terminal emitido desde código nativo (ARM)&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/217/JniHelloWorld-arm-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Mensaje en la terminal emitido desde código nativo en un sistema amd64 y ARM&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Ente ejemplo usa Java 8 y requiere instalar el compilador gcc para compilar la librería con código nativo. &lt;a href=&#34;http://gradle.org/&#34;&gt;Gradle&lt;/a&gt; ofrece soporte para &lt;a href=&#34;https://docs.gradle.org/3.4.1/userguide/native_software.html&#34;&gt;compilar código nativo con su plugin&lt;/a&gt;, sin embargo, he preferido usar y conocer los comandos javah y gcc sin usar Gradle. En el siguiente artículo mostraré el ejemplo del sensor DHT11 usando JNI y código nativo en C llamando a métodos de un objeto Java desde código C.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaRaspberryPi&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew executeJniHelloWorldLocal&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.dogan.io/2015/08/15/java-jni-jnr-go/&#34;&gt;GO: Call me maybe, Java!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html&#34;&gt;Java Native Interface Specification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html&#34;&gt;Java Programming Tutorial, Java Native Interface (JNI)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/</id>
        <title>Introducción y ejemplo de cluster de contenedores con Docker Swarm</title>        
        <updated>2017-03-19T12:00:00+01:00</updated>
        <published>2017-03-19T12:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/03/introduccion-y-ejemplo-de-cluster-de-contenedores-con-docker-swarm/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Las funcionalidades de Docker Swarm están incorporadas en Docker para gestionar &lt;em&gt;clusters&lt;/em&gt; de nodos con contenedores de los servicios que deseemos. En artículo comentaré algunas de las propiedades de &lt;em&gt;networkning&lt;/em&gt; distribuido incorporado en Docker, como crear un &lt;em&gt;cluster&lt;/em&gt; de nodos Docker usando VirtualBox con máquinas virtuales para simular múltiples máquinas junto con como lanzar un servicio en el &lt;em&gt;cluster&lt;/em&gt; que en este caso consistirá en un servidor web nginx.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/docker.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Docker&#34; title=&#34;Docker&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/series/docker/&#34;&gt;artículos anteriores de la serie sobre Docker&lt;/a&gt; comentaba varias de las herramientas de &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; como &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker Compose&lt;/a&gt;, Dockerfile o &lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker Machine&lt;/a&gt; con ejemplos de como usarlo en local. Una de las herramientas que me quedaba por investigar era &lt;a href=&#34;https://docs.docker.com/swarm/&#34;&gt;Docker Swarm&lt;/a&gt; para crear &lt;em&gt;clusters&lt;/em&gt; de nodos para contenedores Docker en un entorno de producción. A partir de la versión 1.12 de Docker se han incorporado varias características a Docker para usaar contenedores de forma distribuida y que a pesar de la complejidad subjacente que debe haber es realmente simple usarlo.&lt;/p&gt;

&lt;p&gt;Una de las características es el &lt;em&gt;networking&lt;/em&gt; que hace trasnparente la comunicación en red distribuida que se hace entre los nodos y los contenedores de esos nodos. Además permite crear redes por software para que los contenedores conectados a esas redes se comuniquen de forma privada. Otra característica interesante de Docker Swarm es que se encarga de monitorizar el estado de los servicios recreando contendores si alguno deja de funcionar. También a través del denominado &lt;em&gt;routing mesh&lt;/em&gt; da igual al nodo del &lt;em&gt;cluster&lt;/em&gt; por el que se acceda y da igual en que nodo esté el contenedor que Docker Swarm con esta propiedad se encargará de hacer llegar la petición al contenedor. Además, a lo que en Docker Swarm se denomina servicio se realiza balanceo de carga entre la instancias del mismo que haya en el &lt;em&gt;cluster&lt;/em&gt; y al servicio se le asigna un DNS y dirección IP por el que puede ser accedido por otros servicios.&lt;/p&gt;

&lt;p&gt;En el siguiente ejemplo para crear el &lt;em&gt;cluster&lt;/em&gt; de nodos Docker usaré Docker Machine para crear las máquinas de los nodos en máquinas virtuales de &lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt; aunque su funcionamiento es similar si usásemos la nube de &lt;a href=&#34;http://aws.amazon.com/es/ec2/&#34;&gt;Amazon EC2&lt;/a&gt;, &lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;Digital Ocean&lt;/a&gt; u otros.&lt;/p&gt;

&lt;p&gt;El siguiente &lt;em&gt;script&lt;/em&gt; crea primeramente varios nodos cada uno en una máquina virtual, luego establece el nodo 01 como &lt;em&gt;manager&lt;/em&gt; y los nodos 02 y 03 como &lt;em&gt;workers&lt;/em&gt; usando un &lt;em&gt;token&lt;/em&gt; para unirlos al &lt;em&gt;cluster&lt;/em&gt; según su rol. Los nodos &lt;em&gt;manager&lt;/em&gt; se encargan de mantener el estado del &lt;em&gt;cluster&lt;/em&gt; y los que a través de ellos los comandos de los servicios deben ser lanzados, en un entorno de producción posiblemente tendríamos 3 nodos &lt;em&gt;manager&lt;/em&gt; para soportar tolerancia a fallos. Finalmente, se obtiene lista los nodos del &lt;em&gt;cluster&lt;/em&gt;. El comando &lt;em&gt;docker-machine env node-01&lt;/em&gt; permite establecer el entorno contra el que el comando &lt;em&gt;docker&lt;/em&gt; lanzará las operaciones como si de la máquina local se tratase.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=01-cluster-create.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una vez creado los nodos es cuando podemos empezar a crear servicios en el &lt;em&gt;cluster&lt;/em&gt;. Los servicios son una definición de los contenedores de Docker que queremos que el &lt;em&gt;cluster&lt;/em&gt; ejecute. En el ejemplo definiré el servicio de un servidor web &lt;a href=&#34;http://nginx.org/&#34;&gt;nginx&lt;/a&gt;, primeramente crearé una red por software en el &lt;em&gt;cluster&lt;/em&gt; a la que los servicios pueden conectarse que en el ejemplo (aunque para este no es necesario) utilizaré para hacer una consulta DNS con la herramienta &lt;a href=&#34;https://linux.die.net/man/1/drill&#34;&gt;drill&lt;/a&gt; para ver el nombre de dominio y dirección IP que asigna Docker Swarm al servicio del servidor web. Con &lt;em&gt;docker service create&lt;/em&gt; se crean los servicios, algunos de los parámetros del comando son el nombre del servicio que queremos asignarle, los puertos que expone en este caso el 80 y 443 en el &lt;em&gt;host&lt;/em&gt; para que sea accesible desde fuera del &lt;em&gt;cluster&lt;/em&gt;, la redes a las que está conectado y finalmente la imagen del contenedor del servicio que en este caso será la versión de &lt;a href=&#34;https://hub.docker.com/_/nginx/&#34;&gt;nginx con Alpine para Docker&lt;/a&gt;. Se pueden listar los servicios que contiene el &lt;em&gt;cluster&lt;/em&gt; con &lt;em&gt;docker service ls&lt;/em&gt; y los procesos de cada nodo donde podemos ver en que nodos se está ejecutando los contenedores con &lt;em&gt;docker ps&lt;/em&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=06-nginx-create.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una de las propiedades interesantes del &lt;em&gt;networking&lt;/em&gt; de Docker Swarm es que ofrece incorporado balanceo de carga, esto es, si el servicio de nginx del ejemplo estuviese formado por dos instancias las peticiones se distribuirían entre las instancias usando el método &lt;em&gt;round-robin&lt;/em&gt;. Otra característica interesante si se observa el ejemplo con detalle es que da igual el nodo al que hagamos la petición que la respuesta se obtendrá igualmente, esto es, aunque la petición se haga al nodo 01 y realmente el contenedor del servidor nginx se esté ejecutando en el nodo 02 la petición se realizará correctamente gracias al &lt;em&gt;routing mesh&lt;/em&gt; del &lt;em&gt;neworking&lt;/em&gt; de Docker Swarm, esto es gracias a que cada servicio tiene asignada una dirección IP, como se ha visto anteriormente en la salida del comando &lt;em&gt;drill&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;En este vídeo de &lt;a href=&#34;https://asciinema.org/&#34;&gt;asciinema&lt;/a&gt; se ve en funcionamiento todos los anteriores comandos. Y en la aplicación de VirtualBox estarán las máquinas virtuales de cada uno de los nodos que crea el ejemplo. En el vídeo se aprecia que el servicio de nginx se está ejecutando en el nodo 02 cuando se listan los procesos de Docker de cada nodo con &lt;em&gt;docker ps&lt;/em&gt;, nótese sin embargo que al hacer un petición HTTP a cualquiera de los nodos se devuelve la página de inicio de nginx ya que gracias al &lt;em&gt;routing mesh&lt;/em&gt; de Docker Swarm la petición se redirige de forma transparente para el cliente y el servicio al nodo donde realmente se está ejecutando el contenedor de nginx.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/107868.js&#34; id=&#34;asciicast-107868&#34; async&gt;&lt;/script&gt;
        &lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/107868&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/107868.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
        
        &lt;figcaption&gt;Introducción y ejemplo de cluster de contenedores con Docker Swarm&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/div&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/216/maquinas-virtuales-cluster.png&#34; title=&#34;Máquinas virtuales de los nodos del _cluster_ de Docker Swarm&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/216/maquinas-virtuales-cluster-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Máquinas virtuales de los nodos del cluster de Docker Swarm&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Los comandos para eliminar un servicio del &lt;em&gt;cluster&lt;/em&gt; y eliminar completamente el &lt;em&gt;cluster&lt;/em&gt; son los siguientes.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=nginx-remove.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=cluster-remove.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Un libro que me ha gustado mucho y que recomiendo leer sobre Docker Swarm es &lt;a href=&#34;http://amzn.to/2mIirti&#34;&gt;The Devops 2.1 Toolkit&lt;/a&gt; que lo explica detalladamente y todo el libro está orientado a como usarlo en un entorno de producción. Un libro más introductorio que también he leído y que está bastante bien es &lt;a href=&#34;http://amzn.to/2mF3Xtj&#34;&gt;Docker in Action&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1633430235&amp;linkId=a6c4acab72c208d29232f2e0a8edb8ee&#34;&gt;&lt;/iframe&gt;
    &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=1542468914&amp;linkId=2101ae950cfcfe9e69b6cc1210e4bf2c&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Finalmente, quizás si estás usando GNU/Linux y VirtualBox como yo al crear los nodos con el comando &lt;em&gt;docker-machine&lt;/em&gt; te produzca el siguiente error (quizá se corrija en futuras versiones de Docker o VirtualBox).&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=vboxnet0-error.out&#34;&gt;&lt;/script&gt;

&lt;p&gt;La solución que he encontrado para que funcione es asignar una dirección IP al adaptador puente solo-anfitrión y levantar la interfaz que usa Docker para comunicarse con las máquinas virtuales previamente a crear el nodo. En &lt;a href=&#34;https://www.archlinux.org/&#34;&gt;Arch Linux&lt;/a&gt; con los siguientes comandos.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/f9b48124e3bf0cde0cd88a198bda90e8.js?file=01-vboxnet0-configure.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Se puede definir un conjunto de servicios como una unidad en un archivo en &lt;em&gt;stacks&lt;/em&gt; de forma similar a como es posible hacer con Docker Compose cosa que mostraré en otro artículo.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/DockerSwarm&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/03/controlar-un-display-lcd-1602-para-mostrar-texto-con-la-raspberry-pi-y-java/</id>
        <title>Controlar un display LCD 1602 para mostrar texto con la Raspberry Pi y Java</title>        
        <updated>2017-03-19T02:00:00+01:00</updated>
        <published>2017-03-18T10:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/03/controlar-un-display-lcd-1602-para-mostrar-texto-con-la-raspberry-pi-y-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/raspberrypi.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Raspberry Pi&#34; title=&#34;Raspberry Pi&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Uno de los motivos por los que compré el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/&#34;&gt;kit de iniciación a la electrónica para la Raspberry Pi&lt;/a&gt;, además de cacharrear un poco, era en concreto controlar el &lt;em&gt;display&lt;/em&gt; LCD de 16 columnas y 2 filas. En el &lt;em&gt;kit&lt;/em&gt; el &lt;em&gt;display&lt;/em&gt; viene con un adaptador con el bus de comunicación I2C. El &lt;em&gt;display&lt;/em&gt; se puede usar sin este bus pero requiere utilizar muchos más pines GPIO de datos de los limitados 17 que ofrece la Raspberry Pi 1 y los 26 de las Raspberry Pi B+, 2  y 3. Controlar el &lt;em&gt;display&lt;/em&gt; con I2C requiere únicamente 2 pines, por contra sin usar I2C requiere un número significativamente mayor 4 u 8 pines.&lt;/p&gt;

&lt;p&gt;El &lt;em&gt;display&lt;/em&gt; 1602 con su adaptador para el bus I2C que viene con el &lt;em&gt;kit&lt;/em&gt; ya incorporado en la parte trasera es el siguiente.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/display-lcd-1602.jpg&#34; title=&#34;Display LCD 16 columnas y 2 filas&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/display-lcd-1602-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/adaptador-bus-i2c-1602.jpg&#34; title=&#34;Adaptador bus I2C para display 1602&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/adaptador-bus-i2c-1602-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Display LCD 1602 y adaptador bus I2C&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;El esquema de conexionado para controlar el &lt;em&gt;display&lt;/em&gt; requiere usar los pines de la Raspberry Pi &lt;em&gt;SDA&lt;/em&gt; y &lt;em&gt;SDL&lt;/em&gt; además de un &lt;em&gt;pin&lt;/em&gt; para proporcionar un voltaje de 5V y otro &lt;em&gt;pin&lt;/em&gt; para la tierra. El &lt;em&gt;pin&lt;/em&gt; &lt;em&gt;SDA&lt;/em&gt; es el número 2 según la numeración de pines de la Raspberry Pi y el &lt;em&gt;SDL&lt;/em&gt; es el 5. El &lt;em&gt;pin&lt;/em&gt; &lt;em&gt;SDA&lt;/em&gt; es utilizado en el bus I2C para transmitir los datos y el &lt;em&gt;SDL&lt;/em&gt; para la señal de reloj o sincronización. Utilizando la placa de extensión wiringPi de 26 &lt;em&gt;pines&lt;/em&gt; los &lt;em&gt;pines&lt;/em&gt; &lt;em&gt;SDA&lt;/em&gt; y &lt;em&gt;SDL&lt;/em&gt; se encuentran identificados por su nombre y el de la placa de extensión de 40 &lt;em&gt;pines&lt;/em&gt; que viene con el &lt;em&gt;kit&lt;/em&gt; de iniciación también, deberemos identificar estos pines y realizar las conexiones adecuadamente.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/breadboard-cableado.jpg&#34; title=&#34;Cableado en la breadboard&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/breadboard-cableado-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/esquema-cableado.png&#34; title=&#34;Esquema del cableado&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/esquema-cableado-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Cableado en la breadboard&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Hay que emplear varios cables macho-macho y hembra-hembra para conectar a los pines del adaptador I2C del &lt;em&gt;display&lt;/em&gt;  a los &lt;em&gt;pines&lt;/em&gt; del voltaje de 5V, tierra, &lt;em&gt;SDA&lt;/em&gt; y &lt;em&gt;SDL&lt;/em&gt; de la placa de pruebas sin soldadura.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/cables-macho-macho-hembra-hembra.jpg&#34; title=&#34;Unión cables macho-macho y hembra-hembra&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/cables-macho-macho-hembra-hembra-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Unión cables macho-hembra&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;El siguiente paso será activar el bus I2C en la Raspberry Pi que por defecto está desactivado. Esto requiere añadir unos parámetros en la configuración de arranque y cargar unos módulos del kernel que finalmente crearán un dispositivo tal que en &lt;em&gt;/dev/i2c-0&lt;/em&gt; o &lt;em&gt;/dev/i2c-0&lt;/em&gt;. Si instalamos el paquete &lt;em&gt;i2c-tools&lt;/em&gt; podremos detectar el &lt;em&gt;display&lt;/em&gt; en el bus I2C, en la captura de pantalla en la dirección 27 que hay que usar al construir la instancia del controlador del &lt;em&gt;display&lt;/em&gt;. Estos cambios en la configuración de inicio requieren reiniciar la Raspberry Pi. En un sistema con la distribución &lt;a href=&#34;http://archlinuxarm.org/&#34;&gt;Arch Linux ARM&lt;/a&gt; los cambios son los siguientes.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1ab3b748f7e9cc0c60cbc7c21531f21f.js?file=configuration.txt&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/i2cdetect.png&#34; title=&#34;Detectción del display 1602 en el bus I2C&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/215/i2cdetect-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Detectción del display 1602 en el bus I2C&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Según la &lt;a href=&#34;https://www.sparkfun.com/datasheets/LCD/HD44780.pdf&#34;&gt;especificación del &lt;em&gt;display&lt;/em&gt; 1602&lt;/a&gt; este componente soporta varios comandos para controlarlo, algunos son para limpiar el texto, cambiar la dirección de escritura, añadir caracteres personalizados y emitir texto en la línea o posición del &lt;em&gt;display&lt;/em&gt; que queramos. No es simple el controlar el &lt;em&gt;display&lt;/em&gt; a bajo nivel ya que hay que trabajar en momentos con binario y usar bytes, por ello para el ejemplo usaré la librería &lt;a href=&#34;http://rtd.diozero.com/en/latest/&#34;&gt;diozero&lt;/a&gt; que ya trae una implementación de controlador con funciones de alto nivel &lt;em&gt;I2CLcd&lt;/em&gt; que en versiones más recientes de la librería ha sido renombrada a &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html&#34;&gt;HD44780Lcd&lt;/a&gt; mucho más cómoda que enviar &lt;em&gt;bytes&lt;/em&gt; a bajo nivel al bus I2C, el &lt;a href=&#34;https://github.com/mattjlewis/diozero/blob/master/diozero-core/src/main/java/com/diozero/HD44780Lcd.java&#34;&gt;código fuente de la clase HD44780Lcd&lt;/a&gt; está disponible y podemos verlo si hay curiosidad.&lt;/p&gt;

&lt;p&gt;En mi caso con la Raspberry Pi 1 he tenido que utilizar la versión 0.9 de la librería diozero porque la 0.8 me generaba un &lt;em&gt;stacktrace&lt;/em&gt; de una excepción &lt;em&gt;java.lang.UnsupportedOperationException&lt;/em&gt;. Obtener esta versión de la librería como aún era de desarrollo y no estaba publicada en &lt;a href=&#34;https://search.maven.org/&#34;&gt;Maven Central&lt;/a&gt; la he descargado de un &lt;a href=&#34;https://drive.google.com/drive/u/0/folders/0B2Kd_bs3CEYaZ3NiRkd4OXhYd3c&#34;&gt;google drive que ha creado el autor&lt;/a&gt; y usado en &lt;a href=&#34;http://gradle.org/&#34;&gt;Gradle&lt;/a&gt; como una dependencia del sistema de ficheros. Como librería subyacente de diozero para controlar los pines GPIO he usado &lt;a href=&#34;http://abyz.co.uk/rpi/pigpio/&#34;&gt;pigpio&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1ab3b748f7e9cc0c60cbc7c21531f21f.js?file=java.lang.UnsupportedOperationException&#34;&gt;&lt;/script&gt;

&lt;p&gt;En el ejemplo mostraré un texto en cada una de las lineas del &lt;em&gt;display&lt;/em&gt; y usaré una de las funciones del para mostrar caracteres personalizados con los que es posible crear &lt;em&gt;emojis&lt;/em&gt; o caracteres nuevos. El controlador de diozero ya contiene una buena colección de caracteres personalizados que definen el patrón de 5x8 puntos que siguen, los nombres de estos caracteres personalizados están en la clase interna &lt;em&gt;Characters&lt;/em&gt; de &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html&#34;&gt;HD44780Lcd&lt;/a&gt; aunque también podemos definir nuevos. El ejemplo es el siguiente donde se muestra el uso de los métodos &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html#setText-int-java.lang.String-&#34;&gt;setText&lt;/a&gt; y &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html#setCharacter-int-int-char-&#34;&gt;setCharacter&lt;/a&gt;, también el constructor donde hay que indicar la dirección asignada al dispositivo en el bus I2C que siendo la 27 corresponde con el valor definido en una constante. Pero también hay otros métodos como &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html#clear--&#34;&gt;clear&lt;/a&gt;, &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html#cursorOff--&#34;&gt;cursorOff&lt;/a&gt; y &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html#cursorOn--&#34;&gt;cursorOn&lt;/a&gt; para apagar y encender el cursor, &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html#displayOff--&#34;&gt;displayOff&lt;/a&gt;
&lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html#displayOn--&#34;&gt;displayOn&lt;/a&gt; para apgar y encender el &lt;em&gt;display&lt;/em&gt; y &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html#createChar-int-byte:A-&#34;&gt;createChar&lt;/a&gt; para crear nuevos caracteres definidos como una &lt;em&gt;array&lt;/em&gt; de 8 posiciones donde cada &lt;em&gt;byte&lt;/em&gt; indica los pixeles encendidos de cada fila del caracter de 5x8 y con &lt;a href=&#34;http://static.javadoc.io/com.diozero/diozero-core/0.9/com/diozero/HD44780Lcd.html#setCharacter-int-int-char-&#34;&gt;setCharacter&lt;/a&gt; para emitir uno de los 8 posibles que se pueden usar al mismo tiempo. Además de estos también hay otros pocos métodos más relacionados con el cursor.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1ab3b748f7e9cc0c60cbc7c21531f21f.js?file=Lcd.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/1ab3b748f7e9cc0c60cbc7c21531f21f.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/1ab3b748f7e9cc0c60cbc7c21531f21f.js?file=executeSSH.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/1ab3b748f7e9cc0c60cbc7c21531f21f.js?file=executeGradle.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/mensaje-lcd-1602.jpg&#34; title=&#34;Mensaje en LCD 1602&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/mensaje-lcd-1602-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Mensaje en LCD 1602&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;
&lt;div class=&#34;video-post&#34; style=&#34;text-align: center;&#34;&gt;
  &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;https://www.youtube.com/embed/V6msjQNDPuU&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Pudiendo mostrar mensajes en &lt;em&gt;display&lt;/em&gt; es posible mostrar cualquier información que un programa sea capaz de capturar como temperatura y humedad del correspondiente sensor en el mismo &lt;em&gt;kit&lt;/em&gt;, estado de un pulsador, espacio disponible en el disco del sistema, y memoria libre, &lt;em&gt;uptime&lt;/em&gt; del sistema, fecha y hora, &amp;hellip; cualquier cosa que se nos ocurra.&lt;/p&gt;

&lt;p&gt;El ejemplo parece simple, y el programa Java lo es, pero requiere conocer varias cosas que en internet está dispersas como activar el bus I2C o conocer la librería diozero para controlar el &lt;em&gt;display&lt;/em&gt; que simplifica enormemente el código y nos evita comunicarnos a más bajo nivel con el &lt;em&gt;display&lt;/em&gt;, realizar las conexiones eléctricas también requiere algo de conocimiento. Averiguar todo esto me costó una buena cantidad de tiempo.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaRaspberryPi&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew executeLcd&lt;/code&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/03/ejemplo-encender-y-apagar-diodo-led-con-la-raspberry-pi-en-java/</id>
        <title>Ejemplo encender y apagar diodo LED con la Raspberry Pi en Java</title>        
        <updated>2017-03-12T00:15:00+01:00</updated>
        <published>2017-03-11T10:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/03/ejemplo-encender-y-apagar-diodo-led-con-la-raspberry-pi-en-java/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/raspberrypi.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Raspberry Pi&#34; title=&#34;Raspberry Pi&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;El primer ejemplo que haré de un programa Java que usa los &lt;em&gt;pines&lt;/em&gt; GPIO para realizar algo con el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/&#34;&gt;kit de inicialización a la electrónica con la Raspberry Pi&lt;/a&gt; consiste en un pequeño programa Java que hace parpadear un diodo LED. La librería &lt;a href=&#34;http://rtd.diozero.com/en/latest/&#34;&gt;Diozero&lt;/a&gt; ofrece a los programas Java el acceso a los &lt;em&gt;pines&lt;/em&gt; GPIO de la diferentes versiones de la Raspberry Pi desde la 1 (rev 1 y rev 2) pasando por los modelos B+, 2 y 3. Otra librería que se puede usar con el lenguaje de programación Java es &lt;a href=&#34;http://pi4j.com/&#34;&gt;Pi4J&lt;/a&gt; aunque personalmente Diozero me ha gustado más por ser de más alto nivel.&lt;/p&gt;

&lt;p&gt;Algunas de las características que ofrece la librería Diozero son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Soporta dispositivos GPIO / I2C / SPI (LEDs, botones, sensores, motores, pantallas, etc).&lt;/li&gt;
&lt;li&gt;Soporta todos los modelos de las placas Raspberry Pi, Odroid C2, BeagleBone Black, C.H.I.P y Asus Tinker.&lt;/li&gt;
&lt;li&gt;Usa caracterśiticas de Java como &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html&#34;&gt;gestión automática de recursos&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&#34;&gt;expresiones lambda&lt;/a&gt; y &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html&#34;&gt;referencias a métodos&lt;/a&gt; que simplifican el desarrollo y mejoran la legibilidad.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rtd.diozero.com/en/latest/#devices&#34;&gt;Lista de deipositivos&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Soporta varios proveedores para el acceso al los dispositivos con &lt;a href=&#34;http://rtd.diozero.com/en/latest/#performance&#34;&gt;diferentes grados de rendimiento&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Una de las primeras cosas a conocer es como se numeran los &lt;em&gt;pines&lt;/em&gt; en la Raspberry Pi ya que hay varias nomenclaturas (&lt;em&gt;header&lt;/em&gt;, wiringPi y Broadcom) y que nomenclatura utiliza la librería Diozero. También deberemos tener en cuenta el modelo de la Raspberry Pi que poseamos ya que según el modelo hay pequeñas diferencias en algunos &lt;em&gt;pines&lt;/em&gt;. Además si usamos una placa de extensión para pruebas sin sodadura como la &lt;a href=&#34;http://wiringpi.com/&#34;&gt;wiringPi&lt;/a&gt; deberemos identificarlos por su nombre. Yo que poseo una de las primeras Raspberry Pi (la 1, rev1) el correspondiente su &lt;a href=&#34;https://www.raspberrypi.org/documentation/usage/gpio/&#34;&gt;esquema de &lt;em&gt;pines&lt;/em&gt; Raspberry Pi 1 (rev. 1)&lt;/a&gt; es el del enlace. En ese esquema se define que el &lt;em&gt;pin&lt;/em&gt; número 12 según el conteo del &lt;em&gt;header&lt;/em&gt; corresponde a GPIO 18 según la nomenclatura Broadcom y la librería Diozero y al GPIO 1 en la librería Pi4J y en la placa de extensión wiringPi.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/raspberrypi1b.jpg&#34; title=&#34;Raspberry Pi 1 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/raspberrypi1b-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/raspberrypi3b.jpg&#34; title=&#34;Raspberry Pi 3 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/raspberrypi3b-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Placas modelos Raspberry Pi 1 B y 3 B&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/breadboard-cableado.jpg&#34; title=&#34;Breadboard y placa extesión GPIO wiringPi de 26 pines&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/breadboard-cableado-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/gpio-extension-40-pines-board.jpg&#34; title=&#34;Placa extesión GPIO de 40 pines&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/gpio-extension-40-pines-board-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Breadboard y placa extesión GPIO wiringPi de 26 pines y 40 pines&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/esquema-cableado.png&#34; title=&#34;Esquema del cableado&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/esquema-cableado-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Esquema del cableado&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Como uso la placa de extensión wiringPi para conectar los &lt;em&gt;pines&lt;/em&gt; de la Raspberry Pi a otra placa para hacer pruebas sin soldadura también conocidas como &lt;em&gt;breadboard&lt;/em&gt;  resultará que en el programa Java al usar Diozero uso la nomenclatura Broadcom para identificar los pines pero al conectar los cables en la placa de pruebas uso la nomenclatura de wiringPi.&lt;/p&gt;

&lt;p&gt;Para el ejemplo utilizaré la placa de extensión sin soldadura, una resistencia de 200 ohmios (dadas sus bandas de colores rojo, negro, marrón y dorado) y un diodo LED además de un par de cables macho-macho para realizar las conexiones electrónicas entre el GPIO 18 (según la nomenclatura de la librería Diozero y Broadcom, 12 según la nomenclatura del &lt;em&gt;header&lt;/em&gt; y 1 según la de wiringPi) y la resistencia además de entre el diodo y la línea de tierra. Los diodos LED poseen una orientación y hay que conectar la resistencia con el polo positivo del diodo LED, el polo positivo del diodo LED identifica porque es la patita larga y el negativo con tierra es la patita corta. Si realizamos la conexión al revés solo pasará que el diodo no se enciende pero no lo estropeará, la resistencia si es necesaria para no hacer que pase por el diodo una intensidad que lo estropee como se explica en
&lt;a href=&#34;http://www.educachip.com/resistencia-led/&#34;&gt;¿Qué resistencia ooner a un LED?&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/diodo-resistencia.jpg&#34; title=&#34;Diodo blanco y resistencia de 200 ohmios&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/diodo-resistencia-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Diodo blanco y resistencia de 200 ohmios&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Las resistencias poseen cuatro bandas de colores que indican el valor en ohmios de esa resistencia, la tabla de colores es el siguiente:&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/codigo-colores-resistencias.jpg&#34; title=&#34;Código de colores de las resistencias&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/214/codigo-colores-resistencias-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Código de colores de las resistencias&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;El programa Java para hacer parpadear el diodo LED con la librería Diozero con el proveedor &lt;a href=&#34;http://abyz.co.uk/rpi/pigpio/&#34;&gt;pigpio&lt;/a&gt;. El ejemplo consiste en activar y apagar el &lt;em&gt;pin&lt;/em&gt; sucesivamente en un bucle y usar el método &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#sleep-long-&#34;&gt;Thread.sleep&lt;/a&gt; para que pase unos segundos entre uno y otro y nos de tiempo a ver el encendido y apagado. El nada complejo programa Java para controlar el diodo y un vídeo de su funcionamiento están a continuación.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/1fda899b7fbbc19a82bb397d525927f2.js?file=PinBlink.java&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/1fda899b7fbbc19a82bb397d525927f2.js?file=executeSSH.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/1fda899b7fbbc19a82bb397d525927f2.js?file=executeGradle.sh&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;video-post&#34; style=&#34;text-align: center;&#34;&gt;
  &lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;https://www.youtube.com/embed/NX5tBxWuzFA&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;En un artículo anterior comento &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/03/ejemplo-hello-world-y-java-con-la-raspberry-pi/&#34;&gt;como disponer de un entorno para desarrollar, desplegar las librerías &lt;em&gt;jar&lt;/em&gt; en la Raspberry Pi&lt;/a&gt; y como ejecutar los ejemplos desde la línea de comandos usando una combinación de herramientas de &lt;a href=&#34;https://es.wikipedia.org/wiki/Secure_Shell&#34;&gt;SSH&lt;/a&gt;, &lt;a href=&#34;https://rsync.samba.org/&#34;&gt;rsync&lt;/a&gt; y &lt;a href=&#34;http://www.ansible.com&#34;&gt;Ansible&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaRaspberryPi&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew executePinBlink&lt;/code&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/03/ejemplo-hello-world-con-java-en-la-raspberry-pi/</id>
        <title>Ejemplo Hello World con Java en la Raspberry Pi</title>        
        <updated>2017-03-04T23:00:00+01:00</updated>
        <published>2017-03-04T11:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/03/ejemplo-hello-world-con-java-en-la-raspberry-pi/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/raspberrypi.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Raspberry Pi&#34; title=&#34;Raspberry Pi&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Este artículo es introductorio a los siguientes que escribiré y publicaré sobre el &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/&#34;&gt;kit de iniciación a la electrónica para la Raspberry Pi&lt;/a&gt;. Antes de empezar a cacharrear con los sensores y dipositivos de entrada y salida, con los pines GPIO y para hacerlo de forma cómoda crearé un entorno de desarrollo y despliegue en la &lt;a href=&#34;http://www.raspberrypi.org/&#34;&gt;Raspberry Pi&lt;/a&gt; usando &lt;a href=&#34;https://es.wikipedia.org/wiki/Secure_Shell&#34;&gt;SSH&lt;/a&gt;, &lt;a href=&#34;https://rsync.samba.org/&#34;&gt;rsync&lt;/a&gt; para copiar los artefactos del equipo de desarrollo a la RPi y &lt;a href=&#34;http://www.ansible.com&#34;&gt;Ansible&lt;/a&gt; usándolo desde &lt;a href=&#34;http://gradle.org/&#34;&gt;Gradle&lt;/a&gt; para lanzar comandos y ejecutar los ejemplos de forma remota aunque si no se quiere usar Ansible se pueden lanzar los comandos mediante SSH.&lt;/p&gt;

&lt;p&gt;En la Raspberry Pi deberemos instalar por supuesto &lt;a href=&#34;http://www.oracle.com/technetwork/java/index.html&#34;&gt;Java&lt;/a&gt; (es posible usar Java 8) junto con SSH y rsync, configurar el servidor SSH en la RPi modificando el archivo &lt;em&gt;/etc/ssh/sshd_config&lt;/em&gt;, habilitar el servidor SSH, copiar nuestra &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/02/generar-y-convertir-claves-y-certificados-con-openssl/&#34;&gt;clave pública ssh generada previamente&lt;/a&gt; al archivo &lt;em&gt;~/.ssh/authorized_keys&lt;/em&gt; del usuario e instalar &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt; como requerimiento de Ansible. Los programas Java los escribiremos en un equipo más potente que la Raspberry Pi ya sea un portátil o un equipo de sobremesa con un IDE ya sea &lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;IntelliJ&lt;/a&gt;, &lt;a href=&#34;https://eclipse.org&#34;&gt;eclipse&lt;/a&gt; u otro, también deberemos instalar Gradle, Ansible y rsync. En Arch Linux con los siguientes comandos del gestor de paquetes:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/2a2fb6ccb095ddaee5a1df0a5ebb0cae.js?file=pacman-raspberrypi.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/2a2fb6ccb095ddaee5a1df0a5ebb0cae.js?file=authorized_keys&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/2a2fb6ccb095ddaee5a1df0a5ebb0cae.js?file=pacman.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con la ayuda de unas tareas para la herramienta de construcción Gradle haremos el despliegue y la ejecución de la librería &lt;em&gt;jar&lt;/em&gt; del proyecto de los ejemplos y de las dependencias que necesiten. El archivo de construcción de Gradle sería el siguiente en el que la tarea &lt;em&gt;copyDependencies&lt;/em&gt; copia las dependencias al directorio &lt;em&gt;build/libs&lt;/em&gt;. La tarea &lt;em&gt;upload&lt;/em&gt; ejecutan el comando &lt;em&gt;rsync&lt;/em&gt; para subir el archivo &lt;em&gt;jar&lt;/em&gt; y las dependencias del proyecto a la Raspberry Pi. Finalmente, una tarea como &lt;em&gt;executeHelloWorld&lt;/em&gt; ejecutará el comando en la Raspberry Pi para lanzar el programa Java. Con SSH también se puede lanzar el comando de forma remota cambiando la dirección IP de la Raspberry Pi por la que tenga asignada.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/2a2fb6ccb095ddaee5a1df0a5ebb0cae.js?file=build.gradle&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/2a2fb6ccb095ddaee5a1df0a5ebb0cae.js?file=executeSSH.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/2a2fb6ccb095ddaee5a1df0a5ebb0cae.js?file=executeGradle.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;El programa de ejemplo es universal gracias a la idea &lt;em&gt;«Write once, run anywhere»&lt;/em&gt; posibilitado por la máquina virtual o &lt;abbr title=&#34;Java Virtual Machine&#34;&gt;&lt;a href=&#34;http://es.wikipedia.org/wiki/M%C3%A1quina_virtual_Java&#34;&gt;JVM&lt;/a&gt;&lt;/abbr&gt; y el &lt;em&gt;bytecode&lt;/em&gt;, está compilado en un sistema con arquitectura x64 (el de mi equipo) y ejecutado en un sistema con arquitectura arm (el de la RPi). No se diferencia en nada al que usaríamos para lo mismo en cualquier otro sistema distinto de la Raspberry Pi.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/2a2fb6ccb095ddaee5a1df0a5ebb0cae.js?file=HelloWorld.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;El resultado de este ejemplo es un mensaje en la terminal que es emitido por un programa Java ejecutado en la Raspberry Pi y lanzado de forma remota.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/213/java-raspberrypi-hello-world.png&#34; title=&#34;Ejemplo Hello World con Java en la Raspberry Pi&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/213/java-raspberrypi-hello-world-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Ejemplo Hello World con Java en la Raspberry Pi&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;En los siguientes artículos de la serie mostraré ya como usar diferentes elementos de salida como diodos LED, zumbador, &lt;em&gt;display&lt;/em&gt; LCD 1602 o de entrada como un pulsador.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/JavaRaspberryPi&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;./gradlew executeHelloWorld&lt;/code&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/</id>
        <title>Desempaquetado del kit de iniciación a la electrónica para la Raspberry Pi</title>        
        <updated>2017-02-25T23:30:00+01:00</updated>
        <published>2017-02-25T11:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/02/desempaquetado-del-kit-de-iniciacion-a-la-electronica-para-la-raspberry-pi/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/raspberrypi.svg&#34; class=&#34;right&#34; width=&#34;200&#34; alt=&#34;Raspberry Pi&#34; title=&#34;Raspberry Pi&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;En el año 2012 compré una de las primeras Raspberry Pi que estuvieron disponibles a la venta, una placa modelo B de 256 MiB. La Raspberry Pi es un pequeño computador en una placa del tamaño de una tarjeta de crédito a un precio que aún se sigue manteniendo en las nuevas versiones de unos 40€ a los que hay que sumar algunos complementos necesarios como una tarjeta SD o microSD y un cargador con conector miniUSB. Las versiones iniciales que es la que tengo se componían de:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU 700 Mhz, un núcleo ARM11 de 32 bits&lt;/li&gt;
&lt;li&gt;Memoria de 256 MiB&lt;/li&gt;
&lt;li&gt;Ethernet 100 MB&lt;/li&gt;
&lt;li&gt;Lector tarjeta SD&lt;/li&gt;
&lt;li&gt;2 x USB 2.0&lt;/li&gt;
&lt;li&gt;HDMI&lt;/li&gt;
&lt;li&gt;26 pines, 17 de propósito general o GPIO&lt;/li&gt;
&lt;li&gt;Salida de audio&lt;/li&gt;
&lt;li&gt;Salida de vídeo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Después de unos años se han lanzado versiones notablemente mejoradas, hasta la fecha la última es la &lt;a href=&#34;http://amzn.to/2mmu6Os&#34;&gt;Raspberry Pi 3&lt;/a&gt; de esta placa que multiplica por 4 la cantidad de memoria RAM hasta 1 GiB y con una CPU de 4 núcleos a una frecuencia de 1.2 Ghz basados en los procesadores ARM Cortex-A53 de 64 bits, incluyendo WIFI N y Bluetooth 4.1, 4 conectores USB, lector microSD y 26 pines GPIO. Aunque la finalidad original de este computador es el aprendizaje de programación y electrónica el uso principal que le he dado hasta ahora ha sido para hacer descargas P2P via torrent. Esta placa es muy popular debido a su bajo coste aunque hay que sumarle posteriormente el precio de una tarjeta microSD y el cargador para proporcionarle energía, su éxito no solo es debido a su coste ya que hay opciones aún más potentes en algunos aspectos a precio similar que no son tan populares, el valor diferenciador de la Raspberry Pi es el apoyo y soporte de la comunidad.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi1b.jpg&#34; title=&#34;Raspberry Pi 1 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi1b-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi3b.jpg&#34; title=&#34;Raspberry Pi 3 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi3b-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Placas modelos Raspberry Pi 1 B y 3 B&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
  &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01CD5VC92&amp;linkId=8984621587929046662fba2b79079f5e&#34;&gt;&lt;/iframe&gt;
  &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01DDFFOYK&amp;linkId=079335c8a813f0df668ada2e897b7562&#34;&gt;&lt;/iframe&gt;
  &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B00J29BR3Y&amp;linkId=4c06245cfc2383a7972edcbe3e42333a&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Hace unas semanas compré un &lt;a href=&#34;http://amzn.to/2mgnpko&#34;&gt;kit de electrónica básico para la Raspberry Pi&lt;/a&gt; pero que incluye una buena cantidad de sensores y elementos de electrónica y sirve para cualquier placa con pines GPIO. Como el &lt;em&gt;kit&lt;/em&gt; es para la Raspberry Pi 3 y viene con un cable de extensión de 40 pines (cantidad de pines que tiene la Raspberry Pi 3) y yo tengo la 1 debí comprar también un &lt;a href=&#34;http://amzn.to/2lSYiDF&#34;&gt;cable de extensión de 26 pines&lt;/a&gt; (los que tiene la Raspberry Pi 1) para la matriz de puntos con la que hacer pruebas sin soldar los elementos. El precio del &lt;em&gt;kit&lt;/em&gt; no es muy caro, de unos 30€ y el barómetro no venía soldado con sus pines por lo que si queremos usarlo deberemos hacer la soldadura primero con un &lt;a href=&#34;http://amzn.to/2mtXv8L&#34;&gt;soldador de electrónica&lt;/a&gt; y &lt;a href=&#34;http://amzn.to/2lSTYUU&#34;&gt;estaño&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;El contenido del &lt;em&gt;kit&lt;/em&gt; es el siguiente que viene en una estupenda caja de plástico para guardar todos los componentes de forma ordenada:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 x GPIO to breadboard 40-pin breakout interface&lt;/li&gt;
&lt;li&gt;1 x solderless prototype breadboard&lt;/li&gt;
&lt;li&gt;40 x pin jumper wires (male to male 15cm)&lt;/li&gt;
&lt;li&gt;2 x 8 pin Jumper Wires (female to female 20cm)&lt;/li&gt;
&lt;li&gt;24 x LED (6 x Bright White, 6 x Red, 6 x Yellow, 6 x Green)&lt;/li&gt;
&lt;li&gt;65 x resistors (200ohm x 20pcs, 1Kohm x 20pcs, 10Kohm x 20pcs, 1Mohm x 5pcs)&lt;/li&gt;
&lt;li&gt;3 x photoresistor (light sensor)&lt;/li&gt;
&lt;li&gt;5 x push buttons&lt;/li&gt;
&lt;li&gt;3 x potentiometer (10kilohm adjustable resistor)&lt;/li&gt;
&lt;li&gt;1 x A/D converter&lt;/li&gt;
&lt;li&gt;1 x DHT11 Temperature/Humidity sensor&lt;/li&gt;
&lt;li&gt;1 x motion sensor&lt;/li&gt;
&lt;li&gt;1 x mercury tilt switch sensor&lt;/li&gt;
&lt;li&gt;1 x I2C 1602 alphanumeric LCD&lt;/li&gt;
&lt;li&gt;1 x servo motor&lt;/li&gt;
&lt;li&gt;1 x piezo Buzzer&lt;/li&gt;
&lt;li&gt;1 x BMP180 Pressure/Temperature Sensor&lt;/li&gt;
&lt;li&gt;1 x relay&lt;/li&gt;
&lt;li&gt;1 x Infrared Remote Controller and Receiver(VS1838B)&lt;/li&gt;
&lt;li&gt;1 x Raspberry Pi/Arduino 8-Channel TTL Logic Level Converter&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/caja.jpg&#34; title=&#34;Caja&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/caja-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/componentes-1.jpg&#34; title=&#34;Componentes&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/componentes-1-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Caja, componentes y sensores&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/display-1.jpg&#34; title=&#34;Display 16x02&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/display-1-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/display-2.jpg&#34; title=&#34;Display 16x02 con adaptador I2C&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/display-2-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Display 16x02 y adaptador I2C&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/breadboard-1.jpg&#34; title=&#34;Breadboard&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/breadboard-1-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/breadboard-2.jpg&#34; title=&#34;Breadboard y adaptador&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/breadboard-2-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Breadboard y adaptador&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/adaptador-breadboard.jpg&#34; title=&#34;Breadboard&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/adaptador-breadboard-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/diodos-resistencias.jpg&#34; title=&#34;Diodos, botones, resistencias y fotoresistores&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/diodos-resistencias-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Adaptador breadboard, diodos, botones, resistencias y fotoresistores&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&#34;media-amazon&#34; style=&#34;text-align: center;&#34;&gt;
  &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01MDUP97N&amp;linkId=a16adfaf3d471a1e94dc0590c0d615be&#34;&gt;&lt;/iframe&gt;
  &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B00W9F5LR6&amp;linkId=5668053b0c5cb1aa9ff20db0e39790e8&#34;&gt;&lt;/iframe&gt;
  &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01KC2AQJK&amp;linkId=e45d6edd69dac157bd5ddf58be2cb301&#34;&gt;&lt;/iframe&gt;
  &lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-eu.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=blobit-21&amp;o=30&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B008DEYEAW&amp;linkId=1f3f2cae44a45a28da37ac44749ed329&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;La matriz de conexiones o &lt;em&gt;breadboard&lt;/em&gt; es una forma cómoda de hacer pruebas sin tener que hacer soldaduras, los puntos en vertical de la mitad superior e inferior están conectados entre si de modo que con los cables macho-macho podamos poner y quitar conexiones. La matriz está numerada horizontalmente con números y verticalmente con letras de forma que cada punto sea identificable individualmente. Las dos filas de puntos superiores suelen usarse para proporcionar un voltaje de 5V y la conexión de tierra, las dos filas de puntos inferiores para proporcionar un voltaje de 3.3V y tierra. La placa está dividida en dos mitades verticalmente de las letras A-D y E-F formando columnas verticales de puntos conectadas en grupos de 5.&lt;/p&gt;

&lt;p&gt;Mi intención para este &lt;em&gt;kit&lt;/em&gt; es hacer unos pequeños ejemplos usando en cada uno de ellos uno o varios elementos y con el lenguaje de programación Java y la librería &lt;a href=&#34;http://rtd.diozero.com/en/latest/&#34;&gt;Diozero&lt;/a&gt;. Entre los ejemplos estará encender y apagar un LED, usar el &lt;em&gt;display&lt;/em&gt; de 16x2 caracteres, el sensor de temperatura y humedad, el sensor de infrarrojos, el motor, los pulsadores, el sensor de movimiento, los detectores de luz, el detector de golpes, etc&amp;hellip;&lt;/p&gt;

&lt;p&gt;En la página del fabricante o distribuidor mayorista &lt;a href=&#34;http://osoyoo.com/&#34;&gt;Osoyoo&lt;/a&gt; hay colgados varios ejemplos usando varios de estos elementos. También deberemos hacernos con las referencias de los pines para saber las conexiones que debemos hacer con los cables junto con la tabla de referencia de colores de las resistencias. Para usar las tablas de referencia debemos saber que hay varias formas de numerar los pines. Está la del &lt;em&gt;header&lt;/em&gt; del 1 al 26 o del 1 al 40 secuencialmente según la disposición en el &lt;em&gt;header&lt;/em&gt;, la que utiliza la librería &lt;a href=&#34;http://wiringpi.com/&#34;&gt;wiringPi&lt;/a&gt; y &lt;a href=&#34;http://pi4j.com/&#34;&gt;Pi4J&lt;/a&gt; para numerar los pines GPIO y la de Broadcom que utiliza la librería Diozero. Estas tablas de referencia de nomenclatura son importantes porque cada una numera los pines de forma diferente, por ejemplo, según la numeración de wiringPi el pin número 3 corresponde al GPIO 8 cuando según la nomenclatura de Broadcom el mismo pin corresponde al GPIO 0 en el modelo RPi 1 modelo B rev1 y al GPIO 2 en la RPi 3.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi1b-header-rev1.png&#34; title=&#34;Header de pines Raspberry Pi 1 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi1b-header-rev1-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi3b-header.png&#34; title=&#34;Header de pines Raspberry Pi 3 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi3b-header-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Header de pines Raspberry Pi 1 B y Raspberry Pi 3 B, nomenclatura wiringPi&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi1b-header-rev1-broadcom.png&#34; title=&#34;Header de pines Raspberry Pi 1 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi1b-header-rev1-broadcom-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi3b-header-broadcom.png&#34; title=&#34;Header de pines Raspberry Pi 3 B&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi3b-header-broadcom-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Headers de pines Raspberry Pi 1 B y Raspberry Pi 3 B, nomenclatura Broadcom&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/codigo-colores-resistencias.jpg&#34; title=&#34;Código de colores de las resistencias&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/codigo-colores-resistencias-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Código de colores de las resistencias&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Un ejemplo básico sin necesidad de programar nada es encender un diodo LED. Los elementos a usar son el diodo LED, una resistencia, los cables macho-macho, el cable de extensión y la matriz de puntos. Para ello conectamos el cable de extensión a la matriz de puntos donde con los cables macho-macho haremos las conexiones en los agujeros de la matriz de puntos. Usaremos la conexión de voltaje de 3.3V y una resistencia de 200 ohmios para que el LED no reciba demasiada intensidad. Los diodos LED tienen dos patitas, una más corta que la otra que indican la polaridad, la corta es el polo negativo y se conecta a tierra, la larga es el polo positivo que se conecta a uno de los extremos de la resistencia y el otro extremo de esta la voltaje de 3.3V.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/hola-mundo-led.jpg&#34; title=&#34;Ejemplo conexión LEDs&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/hola-mundo-led-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi.jpg&#34; title=&#34;Raspberry Pi&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/raspberrypi-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Ejemplo conexión LEDs y Raspberry Pi&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Con el programa &lt;a href=&#34;http://fritzing.org/home/&#34;&gt;Fritzing&lt;/a&gt; podremos prototipar y documentar el esquema de  conexiones que realicemos de los proyectos. Posee numerosos modelos, elementos electrónicos y dispositivos de entrada y salida aunque no he encontrado el correspondiente la placa de extensión de wiringPi.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/fritzing.png&#34; title=&#34;Fritzing&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/212/fritzing-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Fritzing&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;En el siguiente artículo explicaré como crear un programa Java para encender y apagar varias veces un diodo LED con la librería Doizero. Además explicaré como con &lt;a href=&#34;http://gradle.org/&#34;&gt;Gradle&lt;/a&gt;, &lt;a href=&#34;https://es.wikipedia.org/wiki/Secure_Shell&#34;&gt;SSH&lt;/a&gt; y &lt;a href=&#34;http://www.ansible.com&#34;&gt;Ansible&lt;/a&gt; hacerlo de forma cómoda desde nuestra máquina de desarrollo y no directamente desde la más lenta Raspberry Pi.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Software. Hardware. Complete.&lt;/em&gt;&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/02/como-crear-un-servicio-de-systemd-para-una-aplicacion-con-spring-boot/</id>
        <title>Cómo crear un servicio de systemd para una aplicación con Spring Boot</title>        
        <updated>2017-02-11T10:00:00+01:00</updated>
        <published>2017-02-11T10:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/02/como-crear-un-servicio-de-systemd-para-una-aplicacion-con-spring-boot/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;La mayoría de distribuciones Linux ya usan systemd como gestor y supervisor de los servicios del sistema.  Creando un descriptor podremos gestionar un servicio propio con los mismos comandos de systemd que usamos para cualquier otro servicio del sistema.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/linux.png&#34; class=&#34;right&#34; alt=&#34;Linux&#34; title=&#34;Linux&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/java.png&#34; class=&#34;right&#34; alt=&#34;Java&#34; title=&#34;Java&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Habiendo creado una aplicación o microservicio, por ejemplo con &lt;a href=&#34;http://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt;, necesitaremos que se inicie con el sistema y una forma de gestionarlo para detenerlo, reiniciarlo y que se reinicie en caso de salida abrupta.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.freedesktop.org/wiki/Software/systemd/&#34;&gt;systemd&lt;/a&gt; es el gestor de servicios que han adoptado la mayoría de distribuciones importantes como &lt;a href=&#34;https://www.debian.org/&#34;&gt;Debian&lt;/a&gt;, &lt;a href=&#34;http://www.centos.org/&#34;&gt;CentOS&lt;/a&gt;, &lt;a href=&#34;http://es.redhat.com/products/enterprise-linux/&#34;&gt;RHEL&lt;/a&gt;, &lt;a href=&#34;http://www.opensuse.org/es/&#34;&gt;openSUSE&lt;/a&gt;, incluso &lt;a href=&#34;http://www.ubuntu.com/&#34;&gt;Ubuntu&lt;/a&gt; después de abandonar su propio gestor de servicios &lt;a href=&#34;http://upstart.ubuntu.com/&#34;&gt;Upstart&lt;/a&gt;. Podemos usar systemd para que gestione como servicio una aplicación propia. Para ello deberemos crear un archivo &lt;em&gt;unit&lt;/em&gt; que describa el servicio y sus dependencias con otros servicios para que se inicie correctamente, él y sus dependencias.&lt;/p&gt;

&lt;p&gt;Los servicios se definen en archivos de texto denominados &lt;em&gt;unit&lt;/em&gt; que tienen un formato similar a los archivos &lt;em&gt;.desktop&lt;/em&gt; que a su vez están inspirados en los archivos &lt;em&gt;.ini&lt;/em&gt; de Windows. En la &lt;a href=&#34;http://www.freedesktop.org/software/systemd/man/systemd.unit.html&#34;&gt;documentación de los archivos &lt;em&gt;unit&lt;/em&gt; de systemd&lt;/a&gt; se detalla con amplitud los archivos &lt;em&gt;unit&lt;/em&gt; de systemd, tienen tres secciones:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[Unit]: contiene información genérica independiente del tipo de servicio como descripción, requerimientos, deseos o orden de inicio.&lt;/li&gt;
&lt;li&gt;[Service]: define el tipo de servicio, los comandos de preinicio, inicio, postinicio, parada, postparada, condiciones reinicio y más parámetros comentados en la &lt;a href=&#34;http://www.freedesktop.org/software/systemd/man/systemd.service.html&#34;&gt;documentación de los sevicios de systemd&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;[Install]: esta sección es usada al habilitar o deshabilitar un servicio en el sistema con el comando &lt;em&gt;systemctl&lt;/em&gt;, pudiendo por ejemplo que se inicie este servicio cuando otro se inicie siendo otra forma de declarar dependencias. De este modo se puede indicar que un servicio tiene otros como dependencia pero también se puede indicar que un servicio se inicie cuando otro lo haga.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Usando la aplicación del &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/09/ejemplo-de-api-rest-en-java-con-jax-rs-y-spring-boot/&#34;&gt;Ejemplo de API REST en Java con JAX-RS y Spring Boot&lt;/a&gt;, crearé un archivo &lt;em&gt;unit&lt;/em&gt; de systemd para que se inicie con el sistema y se reinicie en caso de fallo. Primeramente deberemos crear los archivos que definen el servicio para systemd y sus dependencias si las tienen. En los siguientes ejemplos &lt;em&gt;spring-boot-jaxrs.service&lt;/em&gt; es una aplicación de &lt;a href=&#34;http://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt; con una interfaz REST que simplemente devuelve el mensaje indicado por parámetro con la fecha en la dirección &lt;em&gt;http://localhost:8080/message?message=Hola&lt;/em&gt;. &lt;em&gt;spring-boot-jaxrs-postgres.service&lt;/em&gt; es el mismo servicio pero que tiene una dependencia sobre un contenedor de &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; con una base &lt;a href=&#34;http://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt;, aunque la aplicación Spring Boot no hace uso de la base de datos PostgreSQL sirve para observar que si se inicia el servicio de la aplicación Java también se inicia el servicio de la base de datos si no estuviera ya en ejecución. &lt;em&gt;postgres.service&lt;/em&gt; es el servicio de la base de datos PostgreSQL en un contenedor de Docker y que tiene como dependencia el servicio de Docker.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/3c6603987257cde5e0b182bf8066798f.js?file=spring-boot-jaxrs.service&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/3c6603987257cde5e0b182bf8066798f.js?file=spring-boot-jaxrs-postgres.service&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/3c6603987257cde5e0b182bf8066798f.js?file=postgres.service&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
        &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/102785.js&#34; id=&#34;asciicast-102785&#34; async&gt;&lt;/script&gt;
        &lt;noscript&gt;&lt;a href=&#34;https://asciinema.org/a/102785&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/102785.png&#34; width=&#34;734&#34;/&gt;&lt;/a&gt;&lt;/noscript&gt;
        
        &lt;figcaption&gt;Servicio de systemd para una aplicación con Spring Boot&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;La instalación de la aplicación y de los servicios de systemd en el sistema se realizan copiando archivos, cambiando algunos permisos y usando los comandos de systemd para gestionar los servicios. Los mensajes de salida que emite el servicio se obtienen con el comando &lt;code&gt;journalctl -u spring-boot-jaxrs.service&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Los archivos &lt;em&gt;unit&lt;/em&gt; propios deben ser ubicados en el directorio &lt;em&gt;/etc/systemd/system/&lt;/em&gt;, siendo el directorio &lt;em&gt;/usr/lib/systemd/system/&lt;/em&gt; donde se ubican los instalados por los paquetes del sistema. Iniciado el servicio con el comando &lt;code&gt;sudo systemctl start spring-boot-jaxrs.service&lt;/code&gt;, si queremos habilitarlo con el inicio del sistema usamos el comando &lt;code&gt;sudo systemctl enable spring-boot-jaxrs.service&lt;/code&gt;. Para ver el estado del servicio usamos el comando &lt;code&gt;sudo systemctl status spring-boot-jaxrs.service&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/3c6603987257cde5e0b182bf8066798f.js?file=install.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/3c6603987257cde5e0b182bf8066798f.js?file=manage.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;En los enlaces de referencia hay documentación más detallada tanto para gestionar los servicios con systemd como también documentación de sus archivos &lt;em&gt;unit&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/blog-ejemplos/tree/master/SpringBootJaxrs&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; y probarlo en tu equipo ejecutando el comando &lt;code&gt;sudo systemctl start spring-boot-jaxrs.service&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&#34;reference&#34;&gt;
    Referencia:&lt;br&gt;
    &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files&#34;&gt;Understanding Systemd Units and Unit Files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.freedesktop.org/software/systemd/man/systemd.unit.html&#34;&gt;systemd unit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.freedesktop.org/software/systemd/man/systemd.service.html&#34;&gt;systemd service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/admin/host_integration/&#34;&gt;Docker host integration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.spring.io/spring-boot/docs/1.5.1.RELEASE/reference/htmlsingle/#deployment-install&#34;&gt;Installing Spring Boot applications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Systemd&#34;&gt;Systemd (Arch Linux Wiki)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/01/distribuciones-gnu-linux-mas-seguras-que-windows/</id>
        <title>Distribuciones GNU/Linux, ¿más seguras que Windows?</title>        
        <updated>2017-01-21T20:00:00+01:00</updated>
        <published>2017-01-21T10:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/01/distribuciones-gnu-linux-mas-seguras-que-windows/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Los sistemas GNU/Linux pueden ser igual de seguros o inseguros que los sistemas Windows. Sin embargo, en ambas plataformas hay algunas diferencias que explican por que los sistemas Windows tienen peor fama y por que los sistemas GNU/Linux se consideran más seguros que Windows.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/linux.png&#34; class=&#34;right&#34; alt=&#34;Linux&#34; title=&#34;Linux&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/gnu.png&#34; class=&#34;right&#34; alt=&#34;GNU&#34; title=&#34;GNU&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Habitualmente se comenta que los sistemas con alguna distribución &lt;a href=&#34;https://www.gnu.org/&#34;&gt;GNU&lt;/a&gt;/&lt;a href=&#34;http://www.linux.com/&#34;&gt;Linux&lt;/a&gt; son más seguros que los sistemas &lt;a href=&#34;http://www.microsoft.com/es-es/windows/&#34;&gt;Windows&lt;/a&gt;. Probablemente bien configurados y debidamente actualizados ambas opciones sean muy seguras. Sin embargo, desde el punto de vista de un usuario es común que Windows se vea infectado con virus o &lt;em&gt;malware&lt;/em&gt; aún con un antivirus instalado.&lt;/p&gt;

&lt;p&gt;Las razones de que Windows se vea más amenazado son varias, una es que es una plataforma con una cuota de uso enorme por tanto muy atractiva de atacar. Otra es que instalar programas o software en las distribuciones GNU/Linux se realiza en su mayor parte desde los repositorios oficiales, es decir, de una fuente confiable. En Windows hay que buscar la página oficial del programa y en los resultados de Google no siempre es la primera opción si se busca por «windows reproductor de vídeo», «windows programa para descargar películas» o segundas o terceras opciones es software dudoso. Esas páginas no oficiales de los programas pueden realmente hospedar programas con virus. Quizá ahora que &lt;a href=&#34;http://www.microsoft.com/&#34;&gt;Microsoft&lt;/a&gt; ha añadido en sus últimas versiones de Windows &lt;a href=&#34;https://www.microsoft.com/en-us/windows/windows-10-apps&#34;&gt;una tienda de aplicaciones&lt;/a&gt; se podrán instalar desde ella con más garantías de forma similar a lo que desde hace mucho tiempo en GNU/Linux son los repositorios de paquetes.&lt;/p&gt;

&lt;p&gt;Otro motivo es que &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/01/windows-10-y-office-2016-tan-faciles-de-usar-sin-licencia-como-siempre/&#34;&gt;muchos usuarios de Windows y Office los usan sin licencia&lt;/a&gt; y no hay mayor problema ya que incluso Microsoft ofrece la descarga de la &lt;a href=&#34;https://www.microsoft.com/es-es/software-download/windows10ISO&#34;&gt;imagen ISO de Windows 10&lt;/a&gt; desde su propia página pero para realizar la activación sin la correspondiente licencia hay que usar un programa que puede contener un virus y en un buen caso obligar a reinstalar Windows para deshacerse de él, un peor caso es que el virus no muestre síntomas de su presencia y pase desapercibido pero recolectando datos (contraseñas, fotos, documentos, &amp;hellip;) del usuario sin que este lo sepa. La lista de programas que los usuarios de Windows usan sin licencia es mucho más extensa &lt;a href=&#34;http://www.adobe.com/es/products/photoshop.html&#34;&gt;Photoshop&lt;/a&gt;, &lt;a href=&#34;https://www.adobe.com/es/products/illustrator.html&#34;&gt;Illustrator&lt;/a&gt;, &lt;a href=&#34;https://www.adobe.com/es/products/indesign.html&#34;&gt;InDesign&lt;/a&gt;, &lt;a href=&#34;https://www.adobe.com/es/products/premiere.html&#34;&gt;Premiere Pro&lt;/a&gt;, &lt;a href=&#34;https://www.adobe.com/es/products/aftereffects.html&#34;&gt;After Effects&lt;/a&gt;, &lt;a href=&#34;https://www.adobe.com/es/products/photoshop-lightroom.html&#34;&gt;Lightroom&lt;/a&gt;, &lt;a href=&#34;https://acrobat.adobe.com/es/es/acrobat.html&#34;&gt;Acrobat&lt;/a&gt;, &lt;a href=&#34;https://www.adobe.com/es/creativecloud/catalog/desktop.html&#34;&gt;otro software de Adobe&lt;/a&gt;, &lt;a href=&#34;http://www.autodesk.es/products/autocad/overview&#34;&gt;AutoCAD&lt;/a&gt;, &lt;a href=&#34;http://www.winzip.com/win/es/index.htm&#34;&gt;Winzip&lt;/a&gt;, &amp;hellip; que igualmente al &lt;em&gt;crackearlos&lt;/em&gt; para usarlos después de su periodo de prueba, con la que la seguridad de los sistemas Windows se ve comprometida. Para cada uno de estos programas hay otros &lt;a href=&#34;http://alternativeto.net/&#34;&gt;alternativos con licencias de software libre&lt;/a&gt; mejores o las suficientes funciones para la mayoría de usuarios. Los juegos también son muy pirateados y los &lt;em&gt;cracks&lt;/em&gt; usados también pueden contener funciones maliciosas y es otra fuente de entrada para comprometer la seguridad.&lt;/p&gt;

&lt;p&gt;Con la cuota de uso que tiene Windows serán muchos usuarios con muchos conocimientos que lo usan pero es mayor el número de sus usuarios que tienen pocos conocimientos informáticos y que a la mayoría les vino con el ordenador preinstalado con &lt;a href=&#34;http://elblogdepicodev.blogspot.com.es/2011/05/impuesto-windows.html&#34;&gt;el impuesto Windows&lt;/a&gt; con lo que la seguridad de los sistemas Windows queda inutilizada. Algunas páginas de reputación dudosa muestran mensajes o correos electrónicos fraudulentos contienen &lt;em&gt;banners&lt;/em&gt; advirtiendo que se debe descargar y ejecutar un programa, un usuario con conocimientos simplemente los ignoraría pero algunos usuarios sin conocimientos pueden hacerles caso. E incluso los usuarios con conocimientos si no usan el software con su licencia y usan activadores pueden comprometer la seguridad de sus sistemas.&lt;/p&gt;

&lt;p&gt;Descargar y ejecutar un programa en GNU/Linux de una fuente externa a los repositorios oficiales igualmente puede comprometer la seguridad pero dado que todo el software normalmente se encuentra en los repositorios no suele haber necesidad. Sin embargo, también hay que tener precauciones de &lt;em&gt;scritps&lt;/em&gt; como estos dos que pueden destruir de forma catastrófica un sistema GNU/Linux.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ADVERTENCIA: no los ejecutes!&lt;/strong&gt;. El primero elimina todos los archivos del sistema y el segundo por mucho que parezcan unos extraños inocentes emoticonos crea procesos hasta que agota los recursos del sistema. Un usuario de GNU/Linux precavido y con conocimientos antes revisaría el contenido de cualquier &lt;em&gt;script&lt;/em&gt; o binario ejecutable y no ejecutaría nada en caso de duda.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/dde4ffdff673e05692c2714fc2ca40ba.js?file=nuke.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Dicho lo cual, tanto GNU/Linux y Windows tendrán un nivel de seguridad no tan diferente bien configurados pero el hecho de que los primeros normalmente se basan en software libre, usan repositorios de software confiables, se mantienen siempre actualizados y más rápidamente (al no suponer un coste en nuevas licencias de Windows ni tiene una fecha de expiración del soporte como Windows XP, Vista o Windows 7), se evitan usar activadores, el código fuente está disponible para cualquiera que quiera verlo, la seguridad es auditable y si contuviese alguna función maliciosa podría ser descubierta con mayor facilidad, junto con que los usuarios de GNU/Linux tienen de media más conocimientos que los usuarios Windows, es una plataforma minoritaria en cuota de uso, más fragmentada en diferentes distribuciones y por tanto menos atractiva para atacar hace que GNU/Linux a nivel de usuario tenga menos problemas de seguridad.&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="microsoft"/>
            
                <category term="opinion"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2017/01/script-de-instalacion-de-arch-linux-desatendido-automatizado-y-personalizable/</id>
        <title>Script de instalación de Arch Linux desatendido, automatizado y personalizable</title>        
        <updated>2017-01-13T00:00:00+01:00</updated>
        <published>2017-01-13T00:00:00+01:00</published>
        <link rel="alternate" href="https://picodotdev.github.io/blog-bitix/2017/01/script-de-instalacion-de-arch-linux-desatendido-automatizado-y-personalizable/"/>
        <author><name>pico.dev</name></author>
        <content type="html">
        
          &lt;p&gt;&lt;strong&gt;Arch Linux es una de las distribuciones más personalizables de GNU/Linux pero cuya instalación requiere leer una buena cantidad de documentación para saber que comandos ejecutar en el &lt;em&gt;prompt&lt;/em&gt; del sistema en el que te deja se medio de instalación. Algunos usuarios eligen una distribución como Antergos, KaOS o Manjaro con un instalalador gráfico y guiado simplemente por el hecho de no enfrentarse al instalador de Arch Linux. Ejecutar un comando y esperar a que termine para introducir otro es lento y requiere de atención.&lt;/strong&gt;&lt;/p&gt;
        
        &lt;div class=&#34;logotypes&#34; style=&#34;float: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/archlinux.png&#34; class=&#34;right&#34; alt=&#34;Arch Linux&#34; title=&#34;Arch Linux&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/linux.png&#34; class=&#34;right&#34; alt=&#34;Linux&#34; title=&#34;Linux&#34;/&gt;
&lt;/div&gt;

&lt;div class=&#34;logotypes&#34; style=&#34;float: right; clear: right;&#34;&gt;
    &lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/logotipos/gnu.png&#34; class=&#34;right&#34; alt=&#34;GNU&#34; title=&#34;GNU&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Hace tiempo que instalar una distribución &lt;a href=&#34;https://www.gnu.org/&#34;&gt;GNU&lt;/a&gt;/&lt;a href=&#34;http://www.linux.com/&#34;&gt;Linux&lt;/a&gt; no tiene más dificultad que instalar un sistema operativo como &lt;a href=&#34;http://www.microsoft.com/es-es/windows/&#34;&gt;Windows&lt;/a&gt;, que consiste en descargar la imagen ISO del CD o DVD, grabarla en un CD, DVD o memoria USB e iniciar el sistema con el medio. Las &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2016/10/elegir-una-distribucion-gnu-linux-segun-el-usuario-uso-o-equipo/&#34;&gt;distribuciones aconsejadas para usuarios que provienen de Windows o macOS&lt;/a&gt; o no tiene muchos conocimientos informáticos poseen instaladores gráficos o basados en texto y guiados en varios pasos hasta completar la instalación en menos de una hora. Distribuciones como &lt;a href=&#34;http://www.ubuntu.com/&#34;&gt;Ubuntu&lt;/a&gt;, &lt;a href=&#34;https://elementary.io/es/&#34;&gt;elementary OS&lt;/a&gt; o &lt;a href=&#34;http://www.linuxmint.com/&#34;&gt;Linux Mint&lt;/a&gt; hacen que la instalación no requiera muchos conocimientos y sea completada con éxito por cualquier usuario.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/debian-installer-text.png&#34; title=&#34;Instalador de Debian en modo texto&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/debian-installer-text-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/debian-installer-graphics.png&#34; title=&#34;Instalador de Debian en modo gráfico&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/debian-installer-graphics-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Instalación guíada de Debian basada en texto y gráfica&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Otras distribuciones basadas en principios diferentes y usuarios a los que está destinadas con otras necesidades o preferencias puede que requieran algo más de conocimientos a cambio de realizar configuraciones más avanzadas como el particionado del disco, cifrado del disco o software que se instala. Algunas distribuciones como &lt;a href=&#34;https://www.archlinux.org/&#34;&gt;Arch Linux&lt;/a&gt; incluso no proporcionan ningún instalador.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It is targeted at the proficient GNU/Linux user, or anyone with a do-it-yourself attitude who is willing to read the documentation, and solve their own problems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;En Arch Linux con su &lt;a href=&#34;https://wiki.archlinux.org/index.php/Arch_Linux&#34;&gt;forma de hacer las cosas&lt;/a&gt; deja al usuario el poder de personalizar el sistema completamente a sus necesidades y preferencias únicamente limitado por su determinación de conseguirlo. Solo proporciona &lt;a href=&#34;https://www.archlinux.org/download/&#34;&gt;el medio con el que iniciar la instalación&lt;/a&gt; que comienza con una terminal y un &lt;em&gt;prompt&lt;/em&gt; del sistema, una &lt;a href=&#34;https://wiki.archlinux.org/index.php/Installation_guide&#34;&gt;guía de instalación&lt;/a&gt; junto con las &lt;a href=&#34;https://wiki.archlinux.org/index.php/General_recommendations&#34;&gt;recomendaciones generales&lt;/a&gt; y &lt;a href=&#34;https://wiki.archlinux.org/&#34;&gt;una de las mejores fuentes de información en GNU/Linux&lt;/a&gt; además de completa de cada aspecto que necesitemos en la instalación. Después de haber leído las páginas relevantes de la wiki de Arch Linux, seguramente más de una y dos veces, hasta comprenderla en su mayor parte se empieza a realizar la receta que contenga los comandos necesarios hasta completar la instalación.&lt;/p&gt;

&lt;p&gt;En multitud de blogs y vídeos de YouTube hay guías que contienen los comandos y las explicaciones necesarias. Cualquier usuario de Arch Linux con un blog seguramente ha publicado un artículo con su guía de instalación (sí, &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2014/05/anexo-a-la-guia-de-instalacion-y-del-principiante-de-arch-linux/&#34;&gt;yo también publiqué la mía&lt;/a&gt;). Un usuario que quiera instalar Arch Linux debe leer varios de esos artículos además de la guía oficial de instalación. Según la filosofía de Arch Linux este proceso de aprendizaje se considera necesario y permite una mayor compresión del sistema. Pero saber los comandos que hay que introducir para realizar la instalación de Arch Linux no evita tener que teclearlos uno de tras de otro y esperar a que termine el anterior para introducir el siguiente. Tampoco todas las personas tienen el tiempo para realizarlo. Varias &lt;a href=&#34;https://wiki.archlinux.org/index.php/Arch-based_distributions&#34;&gt;distribuciones derivadas de Arch Linux&lt;/a&gt; como &lt;a href=&#34;https://antergos.com/&#34;&gt;Antergos&lt;/a&gt;, &lt;a href=&#34;https://kaosx.us/&#34;&gt;KaOS&lt;/a&gt; o &lt;a href=&#34;https://manjaro.org/&#34;&gt;Manjaro&lt;/a&gt; ofrecen los instaladores gráficos y guiados más amigables que atraen a algunos usuarios buscando usar Arch Linux pero no pasar por su poco amigable proceso de instalación. Por fortuna al ser una distribución &lt;em&gt;rolling release&lt;/em&gt; (en constante actualización) solo hay que hacer una única instalación por equipo en principio durante toda su vida de uso. Pero incluso para los usuarios de Arch Linux realizar una segunda instalación en un nuevo equipo es cansina.&lt;/p&gt;

&lt;p&gt;Hace unos meses conocí &lt;a href=&#34;https://arch-anywhere.org/&#34;&gt;arch-anywhere&lt;/a&gt; que básicamente es un &lt;em&gt;script&lt;/em&gt; de bash, con un instalador guiado y basado en texto que hace menos laboriosa la instalación de Arch Linux de forma similar a las existentes en otras distribuciones más amigables. Sin embargo, hay un dos cosas que no me convencen de &lt;em&gt;arch-anywhere&lt;/em&gt;, una es que no es desatendido requiriendo contestar a varias preguntas de forma interactiva, esperar a que termine ejecute algún comando según la contestación anterior y contestar a la siguiente pregunta. Por lo demás, ofrece un buen nivel de personalización cubriendo las necesidades más comunes de los usuarios como personalizar el particionado, elegir el sistema de archivos, si se quiere LVM, cifrado, el entorno de escritorio (GNOME, KDE, XFCE, &amp;hellip;), kernel, cargador de arranque (GRUB) y programas a instalar. Otra cosa que no me convence es que usa una imagen ISO propia y no la original de Arch Linux.&lt;/p&gt;

&lt;p&gt;Basándome en &lt;em&gt;arch-anywhere&lt;/em&gt; y dedicando un poco de tiempo he creado un &lt;em&gt;script&lt;/em&gt; en bash para instalar Arch Linux de forma automatizada, desatendida y personalizable hasta cierto punto aunque siendo útil para los casos de configuraciones más comunes. Algunas de las funcionalidades que soporta son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BIOS con &lt;a href=&#34;https://wiki.archlinux.org/index.php/Partitioning&#34;&gt;particionado&lt;/a&gt; GPT&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface&#34;&gt;UEFI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/LVM&#34;&gt;LVM&lt;/a&gt; y no LVM&lt;/li&gt;
&lt;li&gt;Partición &lt;em&gt;root&lt;/em&gt; &lt;a href=&#34;https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_an_entire_system&#34;&gt;cifrada&lt;/a&gt; y sin cifrar&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/File_systems&#34;&gt;Sistemas de archivos&lt;/a&gt; ext4, btrfs (sin swap) o xfs&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Swap&#34;&gt;swap&lt;/a&gt; con archivo&lt;/li&gt;
&lt;li&gt;Instalación con &lt;a href=&#34;https://wiki.archlinux.org/index.php/Wireless_network_configuration&#34;&gt;red WIFI&lt;/a&gt; WPA&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Solid_State_Drives&#34;&gt;Soporte TRIM&lt;/a&gt; para discos SSD&lt;/li&gt;
&lt;li&gt;Utilidades como invitado de &lt;a href=&#34;https://wiki.archlinux.org/index.php/VirtualBox&#34;&gt;VirtualBox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Microcode&#34;&gt;Microcódigo&lt;/a&gt; para procesadores Intel&lt;/li&gt;
&lt;li&gt;Creación de usuario&lt;/li&gt;
&lt;li&gt;Instalación de &lt;a href=&#34;https://wiki.archlinux.org/index.php/AUR_helpers&#34;&gt;yaourt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instalación de paquetes&lt;/li&gt;
&lt;li&gt;Instalación de entorno de escritorio (&lt;a href=&#34;https://wiki.archlinux.org/index.php/GNOME&#34;&gt;GNOME&lt;/a&gt;, &lt;a href=&#34;https://wiki.archlinux.org/index.php/KDE&#34;&gt;KDE&lt;/a&gt;, &lt;a href=&#34;https://wiki.archlinux.org/index.php/Xfce&#34;&gt;Xfce&lt;/a&gt;, &lt;a href=&#34;https://wiki.archlinux.org/index.php/MATE&#34;&gt;Mate&lt;/a&gt;, &lt;a href=&#34;https://wiki.archlinux.org/index.php/Cinnamon&#34;&gt;Cinnamon&lt;/a&gt;, &lt;a href=&#34;https://wiki.archlinux.org/index.php/LXDE&#34;&gt;LXDE&lt;/a&gt;) y gestor de sesiones (&lt;a href=&#34;https://wiki.archlinux.org/index.php/GDM&#34;&gt;gdm&lt;/a&gt;, &lt;a href=&#34;https://wiki.archlinux.org/index.php/SDDM&#34;&gt;sddm&lt;/a&gt;, &lt;a href=&#34;https://wiki.archlinux.org/index.php/LightDM&#34;&gt;lightdm&lt;/a&gt;, &lt;a href=&#34;https://wiki.archlinux.org/index.php/LXDM&#34;&gt;lxdm&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Instalación base sin entorno de escritorio&lt;/li&gt;
&lt;li&gt;Instalación de &lt;a href=&#34;https://wiki.archlinux.org/index.php/Kernels&#34;&gt;kernels&lt;/a&gt; adicionales (linux-lts, linux-grsec, linux-zen)&lt;/li&gt;
&lt;li&gt;Instalación de controlador gráfico (intel, nvidia, amd)&lt;/li&gt;
&lt;li&gt;Cargador de arranque con &lt;a href=&#34;https://wiki.archlinux.org/index.php/GRUB&#34;&gt;GRUB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La forma aconsejada de instalar Arch Linux es aprendiendo cuales son los comandos a ejecutar y que hace cada uno de ellos, primero lee la guía oficial de instalación de Arch Linux y comprende que hacen los comandos del &lt;em&gt;script&lt;/em&gt;. Este &lt;em&gt;script&lt;/em&gt; no es oficial y por ello en el &lt;a href=&#34;https://foros.archlinux-es.org/&#34;&gt;foro de Arch Linux en español&lt;/a&gt; o &lt;a href=&#34;https://bbs.archlinux.org/&#34;&gt;en inglés&lt;/a&gt; no podrán darte soporte aunque yo en los comentarios de este artículo te ayudaré si preguntas. Ten en cuenta que de momento solo lo he probado en &lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt; no en un sistema real y que este &lt;em&gt;script&lt;/em&gt; elimina toda la información del dispositivo de instalación. Si lo pruebas deja un comentario al final de artículo.&lt;/p&gt;

&lt;p&gt;Iniciado el instalador de la imagen ISO de Arch Linux, hay que descargar el &lt;em&gt;script&lt;/em&gt;, editar algunas variables de entorno y darle permisos de ejecución. Los comandos y variables a editar según el sistema a instalar son los siguientes:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/536d786ca788113b1b088957d001d294.js?file=alis-install.sh&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//gist.github.com/picodotdev/536d786ca788113b1b088957d001d294.js?file=alis.conf&#34;&gt;&lt;/script&gt;

&lt;p&gt;El código del instalador no es muy complicado y mucho más sencillo que el &lt;a href=&#34;https://github.com/deadhead420/arch-linux-anywhere/blob/master/arch-installer.sh&#34;&gt;código de arch-anywhere&lt;/a&gt; al no estar mezclado con los mensajes interactivos que hacen preguntas y esperan respuestas. Los comandos que he recopilado de la receta son los que ejecutaríamos uno detrás de otro con únicamente el medio de instalación de Arch Linux. La función &lt;em&gt;main&lt;/em&gt; contiene los pasos en los que consiste la instalación, desde el paticionado y cifrado del disco hasta el reinicio una vez completada la instalación, el resto de las funciones los comandos de ese paso de la instalación.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/picodotdev/536d786ca788113b1b088957d001d294.js?file=alis.sh&#34;&gt;&lt;/script&gt;

&lt;p&gt;Estas son algunas capturas de pantalla con diferentes entornos de escritorio que he probado con VirtualBox.&lt;/p&gt;

&lt;div class=&#34;media&#34; style=&#34;text-align: center;&#34;&gt;
    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-gnome.jpg&#34; title=&#34;GNOME&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-gnome-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-kde.jpg&#34; title=&#34;KDE&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-kde-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Entornos de escritorio GNOME y KDE&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-xfce.jpg&#34; title=&#34;XFCE&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-xfce-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-cinnamon.jpg&#34; title=&#34;Cinnamon&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-cinnamon-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Entornos de escritorio Xfce y Cinnamon&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-lxde.jpg&#34; title=&#34;LXDE&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-lxde-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-mate.jpg&#34; title=&#34;Mate&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-mate-thumb.jpg&#34;/&gt;&lt;/a&gt;
  
  
  &lt;figcaption&gt;Entornos de escritorio LXDE y Mate&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;figure&gt;
  
  &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-root-password.png&#34; title=&#34;Solicitud de contraseña para descifrar partición root&#34; data-gallery&gt;&lt;img src=&#34;https://picodotdev.github.io/blog-bitix/assets/images/posts/204/archlinux-root-password-thumb.png&#34;/&gt;&lt;/a&gt;
  
  
  
  &lt;figcaption&gt;Solicitud de contraseña para descifrar partición root&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;
    El &lt;a href=&#34;https://github.com/picodotdev/alis/tree/master/&#34;&gt;código fuente completo del ejemplo&lt;/a&gt; puedes descargarlo del repositorio de ejemplos de Blog Bitix alojado en &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt;.
&lt;/p&gt;



        </content>
        
            
                <category term="blog-stack"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
                <category term="planeta-linux"/>
            
                <category term="software-libre"/>
            
        
    </entry>
    
</feed>